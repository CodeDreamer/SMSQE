; DV3 SDHC Write Sector for Q68  0.00	 2016 W. Lenerz
; based on

; DV3 QXL Hard Disk Read Sector      1993     Tony Tebby
; 2006.10.20	1.01	BLAT macro definitions commented out - macro wasn't used (wl)


	section dv3

	xdef	hd_wdirect		; direct write sector
	xdef	hd_wsint		; internal write sector

	xref	hd_hold 		; reserve the interface
	xref	hd_release		; release the interface
	xref	snd_cmd 		; send a command to sdhc


	include 'dev8_keys_java'
	include 'DEV8_dv3_keys'
	include 'DEV8_keys_err'
	include 'DEV8_dv3_hd_keys'
	include 'dev8_keys_q68'

sendreg reg	d1/d2/d3/d7/a1/a2/a3


;+++
; This routine writes a sector to an sdhc card, normally for direct sector I/O.
;+++
hd_wdirect
	tst.w	ddf_ftype(a4)		; really direct sector I/O?
	bge.s	hd_wsint		; no
	add.l	ddf_psoff(a4),d0	; yes, add "partition start"
	bra.s	hd_wsint
;+++
; This routine writes a sector to a sdhc card via background transfer.
;
;	d0 cr	sector number / error code
;	d2 c  p number of sectors (at least 1!)
;	d7 c  p drive ID / number  (from 0 to 7)
;	a1 c  p address to read from
;	a3 c  p linkage block
;	a4 c  p drive definition
;
;	status return 0 or ERR.TRNS
;
;	The sector number is for sectors 512 bytes long. The interface needs
;	the sector (or "block") number.
;---

hdw_inus
	rts
hd_wsint
	jsr	hd_hold 		; hold the drive for me
	bne	hdw_inus		; can't
	movem.l sendreg,-(a7)
	lea	hdl_unit-1(a3),a2	; point to "unit" = card for ths drive
	clr.l	d1
	move.b	(a2,d7.w),d1

	move.l	#mmc1_cs,a2		; point to card physical addresses
	add.w	d1,a2			; a2 points to the correct addresses for this drive
	st	drv_cs(a2)		; enable the card

;;;;; debug code
	genif	debug = 1

	cmp.l	#'gold',q68_jflg
	bne.s	nodebug
					; java interface
	move.l	d0,-(a7)		; will be popped up in java
	moveq	#jd3.wsec,d0
	dc.w	jva.trpa		; d0 will be set
	bra	hdw_dis
nodebug
	endgen
;;;;; end debug code
		    
	move.l	d0,d7			; address to read from
	subq.w	#1,d2			; prepare for dbf

; first send command24	($58) to the card
; ($58, 4 bytes with the address to read from, $ff)
wrtloop move.l	d7,d0
	moveq	#-1,d1
	move.b	d0,d1
	rol.w	#8,d1			; d1.w = last byte of address , $ff
	move.b	#$58,d0
	ror.l	#8,d0			; $58 and first 3 bytes of address
	bsr	snd_cmd 		; send command now
	bne.s	hdw_dis 		; ooops
	tst.b	d1			; return needs to be 0
	bne.s	hdw_dis 		; ooops again

lp	st	drv_xfer(a2)		; get another byte back from card
	move.b	drv_read(a2),d0 	; (why ???)

	move.b	#$fe,drv_writ(a2)	; write start signal
	st	drv_xfer(a2)

; now write 512 times one byte, 8 bytes a pop
	lea	drv_xfer(a2),a3
	add.w	#drv_writ,a2
	move.w	#63,d3
sendlp
	move.b	(a1)+,(a2)		; copy byte to write port
	st	(a3)			; start transfer
	move.b	(a1)+,(a2)
	st	(a3)
	move.b	(a1)+,(a2)
	st	(a3)
	move.b	(a1)+,(a2)
	st	(a3)
	move.b	(a1)+,(a2)
	st	(a3)
	move.b	(a1)+,(a2)
	st	(a3)
	move.b	(a1)+,(a2)
	st	(a3)
	move.b	(a1)+,(a2)
	st	(a3)
	dbf	d3,sendlp		; do it for 512 bytes
		
	move.b	d3,(a2) 		; d3.b =$ff due to dbf
	st	(a3)
	move.b	d3,(a2)
	st	(a3)			; senmd 2 fake CRCs
	st	(a2)			; dumy write
	sub.w	#drv_writ,a2		; point start port again

; wait for reply from card **** possible total blockage if card never replies correctly
sndlp2
wct	st	(a3)
	cmp.b	#$ff,drv_read(a2)
	bne.s	sndlp2			; not yet

	addq.l	#1,d7			; next sector to read
	dbf	d2,wrtloop
	moveq	#0,d0			; done and ok
hdw_dis clr.b	drv_cs(a2)		; disable the card
hdw_out movem.l (a7)+,sendreg
	tst.l	d0			; necessary due to clr.b
	jmp	hd_release		; release & return
hdw_err
	moveq	#err.mchk,d0
	bra.s	hdw_dis


	end
