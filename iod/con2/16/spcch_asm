; General 16 bit sprite cache	  V2.00   1999  Tony Tebby
;
	section driver

	xdef	pt_cchset
	xdef	pt_cchloc

	xdef	pt.spxsw
	xdef	pt.rpxsw
	xdef	pt.spsln
	xdef	pt.spcln

	xref	pt_sppref     ; 4 sprite preference table
	xref	pt_spnative   ; and native mode
pt.sppref equ	 4
	xref	pt_palsprite

	xref	sp_arrow
	xref	sp_null

	include 'dev8_keys_con'
	include 'dev8_keys_qdos_pt'

pt.spxsw equ	1	  ; shift pixels to sprite word
pt.rpxsw equ	1	  ; round up pixels to sprite word
pt.spsln equ	(pt.spspx*2+4)*pt.spspy ; length of sprite save area
pt.spmax equ	(pt.spspx*2+4)*pt.spspy*2+pto.hdrl+8
pt.blmax equ	(pt.spspx*2+4)*pt.spspy+pto.hdrl
pt.spcln equ	16*4+pt.spmax*2+pt.blmax*2  ; length of sprite cache


;+++
; Sprite cache setup
;
;	a3 c  p pointer to pointer linkage
;	a5 c  p pointer to sprite cache
;
;---
pt_cchset
	movem.l a1/a2,-(sp)
	lea	(a5),a1
	lea	$20(a5),a2

; the cache table has 16 byte entries
;
ptc_defn    equ $00	; long	pointer to definition
ptc_native  equ $04	; long	pointer to native version
ptc_vcch    equ $08	; byte	cache control version number

	clr.l	(a1)+
	move.l	a2,(a1)+
	lea	pt.spmax(a2),a2
	clr.l	(a1)+
	move.l	a2,(a1)+
	lea	pt.spmax(a2),a2
	clr.l	(a1)+
	move.l	a2,(a1)+
	lea	pt.blmax(a2),a2
	clr.l	(a1)+
	move.l	a2,(a1)+
	movem.l (sp)+,a1/a2
	moveq	#0,d0
	rts

;+++
; Sprite cache locate sprite
;
;	d0 c  s -ve pointer,
;		0 ordinary sprite  (or pattern with mask!!!)
;		1 pattern
;		2 blob
;	d2    r pointer to the correct form sprite
;	a1 c  r pointer to sprite type 0 / pointer to native mode sprite
;	d2
;	a3 c  p pointer to pointer linkage
;
;---
pt_cchloc
ptcc.reg reg	d1-d7/a0/a2/a3/a4/a5
stk_d2	equ	4
	movem.l ptcc.reg,-(sp)
	move.b	d0,d7			 ; mask of pattern / blob to convert
	bne.s	ptc_cchent		 ; ok, look for cache entry
	moveq	#3,d7			 ; 0 is actually both
ptc_cchent
	addq.w	#1,d0
	lsl.w	#4,d0			 ; 4 long word entries
	move.l	pt_spcch(a3),a5 	 ; sprite cache table
	add.w	d0,a5

	moveq	#-1,d3			 ; no suitable object found
	move.l	a1,a0			 ; keep start of list

ptc_srstrt
	moveq	#0,d0			 ; assume sprite isn't dynamic
ptc_sslp
	move.w	pto_form(a1),d4 	 ; get the form
	moveq	#pt.sppref-1,d1
	lea	pt_sppref,a2
ptc_prloop
	cmp.w	(a2)+,d4		 ; look for acceptable form
	dbeq	d1,ptc_prloop
	bne.s	ptc_cnext		 ; not acceptable, try next
	tst.b	d7			 ; pointer sprite?
	bpl.s	ptc_psave		 ; ... no
	move.b	pto_vers(a1),d0 	 ; get version number
	beq.s	ptc_psave		 ; not dynamic, just use it
	cmp.b	pt_svers(a3),d0 	 ; OK for use now?
	bls.s	ptc_cnext		 ; ... no
ptc_psave
	cmp.w	d3,d1			 ; is this one better than last?
	ble.s	ptc_cnext		 ; ... no
	move.l	a1,d2			 ; new good version
	move.w	d1,d3
ptc_cnext
	move.l	pto_nobj(a1),d4 	 ; next object
	beq.s	ptc_cfound		 ; there are no more
	lea	pto_nobj(a1,d4.l),a1	 ; there it is
	bra.s	ptc_sslp		 ; so try it

ptc_cfound
	tst.w	d3			 ; any suitable sprite found?
	bpl.s	ptc_setp
					 ; .. yes
	tst.b	d0			 ; .. no, is this object dynamic?
	beq.s	ptc_default		 ; .... no, there isn't an OK one, tough
	clr.b	pt_svers(a3)		 ; .... yes, restart version counter
	move.l	a0,a1			 ; and scan list again
	bra.s	ptc_srstrt

ptc_default
	lea	sp_arrow,a1
	bra.s	ptc_srstrt

ptc_setp
	move.l	d2,stk_d2(sp)		 ; return this
	move.l	d2,a1			 ; the best we have found
	sub.w	#pt.sppref-1,d3 	 ; native?
	beq.s	ptc_retnative

	move.b	pto_vcch(a1),d0 	 ; cache control

	cmp.l	ptc_defn(a5),a1 	 ; object is cached?
	bne.s	ptc_index		 ; ... no, go ahead and convert

	cmp.b	ptc_vcch(a5),d0 	 ; ... is version the same?
	beq.s	ptc_retcch		 ; ... yes

ptc_index
	move.l	a1,ptc_defn(a5) 	 ; save address
	move.b	d0,ptc_vcch(a5) 	 ; set version

	add.w	d3,d3			 ; index convert code

	move.l	ptc_native(a5),a0	 ; cache entry address

	move.l	(a1)+,d0
	move.w	pt_spnative,(a0)+
	move.w	d0,(a0)+
	move.w	(a1)+,d1  ;x size
	move.w	(a1)+,d2  ;y size
	move.w	d1,(a0)+
	move.w	d2,(a0)+
	move.w	d1,d0
	or.w	d2,d0
	lsr.w	#6,d0			 ; big sprite?
	beq.s	ptc_setorg
	clr.l	(a5)			 ; ... yes, do not cache
	move.l	d1,d0
	addq.w	#1,d0
	bclr	#0,d0
	mulu	d2,d0
	cmp.l	#pt.spspx*pt.spspy,d0	 ; giant sprite?
	ble.s	ptc_setorg
	lea	sp_null,a1		 ; ... yes, do not draw
	bra	ptc_srstrt

ptc_setorg
	move.l	(a1)+,(a0)+		 ; origin
	lea	$c(a0),a4		 ; start of data

	move.w	ptc_pattern(pc,d3.w),d0
	move.w	ptc_mask(pc,d3.w),-(sp)
	bsr.s	ptc_setcache		 ; set two blocks of data
	move.w	(sp)+,d0
	bsr.s	ptc_setcache
	clr.l	(a0)+			 ; ... no next

ptc_retcch
	move.l	4(a5),a1		 ; native mode object is here

ptc_retnative
	movem.l (sp)+,ptcc.reg
	moveq	#0,d0
	rts

ptc_nofill
	addq.l	#4,a1			 ; ... no, skip
ptc_nodata
	clr.l	(a0)+			 ; no data
	rts

ptc_setcache
	asr.b	#1,d7			 ; fill this bit?
	bcc.s	ptc_nofill
	move.l	a1,a2
	move.l	(a1)+,d4		 ; original data  offset
	beq.s	ptc_nodata
	add.l	d4,a2

ptc_fillcache
	move.l	a4,d4			 ; address of data
	sub.l	a0,d4
	move.l	d4,(a0)+		 ; offset to data

	jmp	ptc_convert(pc,d0.w)

ptc_convert
	dc.w	ptcp_ql4-ptc_convert
	dc.w	ptcp_pal-ptc_convert
	dc.w	ptcp_8bt-ptc_convert
ptc_pattern
	dc.w	ptcm_ql4-ptc_convert
	dc.w	ptcm_pal-ptc_convert
	dc.w	ptcm_8bt-ptc_convert
ptc_mask

ptcpql_pal dc.b   0,2*2,2*4,2*7

ptcp_ql4
	swap	d7
	move.l	pt_palql(a3),a3  ; palette
	move.w	d2,d7
	bra.s	ptcpql_emake

ptcpql_make
	move.w	d1,d3
ptcpql_word
	moveq	#32,d6	   ; 32 bits at a time
	move.b	(a2)+,d4
	move.b	(a2)+,d5
	lsl.w	#8,d4
	lsl.w	#8,d5
	move.b	(a2)+,d4
	move.b	(a2)+,d5
ptcpql_bit
	moveq	#0,d0
	add.w	d4,d4
	addx.b	d0,d0
	add.w	d5,d5
	addx.b	d0,d0
	move.b	ptcpql_pal(pc,d0.l),d0
	move.w	(a3,d0.l),(a4)+

	moveq	#0,d0
	add.w	d4,d4
	addx.b	d0,d0
	add.w	d5,d5
	addx.b	d0,d0
	move.b	ptcpql_pal(pc,d0.l),d0
	move.w	(a3,d0.l),(a4)+

	subq.w	#2,d3
	ble.s	ptcpql_emake
	subq.w	#4,d6
	bgt.s	ptcpql_bit
	bra.s	ptcpql_word
ptcpql_emake
	dbra	d7,ptcpql_make
	swap	d7
	rts

ptcm_ql4
	bra.s	ptcmql_emake
ptcmql_make
	move.w	d1,d3
ptcmql_word
	moveq	#32,d6	   ; 32 bits at a time
	move.b	(a2)+,d5
	or.b	(a2)+,d5
	lsl.w	#8,d5
	move.b	(a2)+,d5
	or.b	(a2)+,d5
ptcmql_bit
	moveq	#0,d0
	add.w	d5,d5
	bcc.s	ptcmql_bit2
	moveq	#-1,d0
	clr.w	d0

ptcmql_bit2
	add.w	d5,d5
	bcc.s	ptcmql_set
	not.w	d0
ptcmql_set
	move.l	d0,(a4)+

	subq.w	#2,d3
	ble.s	ptcmql_emake
	subq.w	#4,d6
	bgt.s	ptcmql_bit
	bra.s	ptcmql_word
ptcmql_emake
	dbra	d2,ptcmql_make
	rts

ptcp_pal
	move.l	pt_pal256(a3),a3	 ; palette
	bra.s	ptcp_256
ptcp_8bt
ptcm_8bt
	lea	pt_palsprite,a3 	 ; grbgrbgm palette
ptcp_256
	move.l	d2,d6
	move.w	d1,d5
	addq.w	#1,d5
	and.w	#2,d5			 ; flag extra word
	bra.s	ptcppl_emake

ptcppl_make
	move.w	d1,d3
ptcppl_word
	moveq	#0,d4
	move.b	(a2)+,d4
	add.w	d4,d4
	move.w	(a3,d4.w),(a4)+
	moveq	#0,d4
	move.b	(a2)+,d4
	add.w	d4,d4
	move.w	(a3,d4.w),(a4)+
	subq.w	#2,d3
	bgt.s	ptcppl_word
	add.w	d5,a2			 ; skip extra words
ptcppl_emake
	dbra	d6,ptcppl_make

	rts

ptcm_pal
	bra.s	ptcmpl_emake
ptcmpl_make
	move.w	d1,d3
ptcmpl_word
	tst.b	(a2)+
	sne	d4
	ext.w	d4
	move.w	d4,(a4)+
	tst.b	(a2)+
	sne	d4
	ext.w	d4
	move.w	d4,(a4)+
	subq.w	#2,d3
	bgt.s	ptcmpl_word
	add.w	d5,a2			 ; skip extra words
ptcmpl_emake
	dbra	d2,ptcmpl_make
	rts

	end
