; concatenate lib files
; EX cctf,cct$,lib$
; where:
; cctf =	this software
; cct$ =	name of the _cct file, which is just a list of filenames
;	which are to be concatenated into the lib file
; lib$ =	name of resulting library file


	FILETYPE	1

	section	cctf

	DATA	1000


	BRA.S	start
	DC.W	'W.L.'		; normal job header
	DC.W	$4AFB
	DC.W	len-*-2
	DC.B	'CCTF'
len

start	MOVEQ	#-15,D0		; preset error
	CMP.W	#2,(A7)+		; are there two filenames on my stack?
	BNE	hara		; no!
	MOVE.L	(A7)+,D6		; infile
	MOVE.L	(A7)+,D7		; outfile
	MOVEQ	#40,D0
	BSR.S	get_mem
	BNE	hara
	MOVE.L	A0,D5		; D5 = memo
	ADDQ.L	#2,D5		; but after tje mength word
	MOVEQ	#-1,D3

loop	MOVE.L	D6,A0		; channel ID for infile
	MOVE.L	D5,A1		; point to memory for name
	MOVEQ	#2,D0
	MOVEQ	#38,D2
	TRAP	#3		; get one line ending in LF
	TST.L	D0
	BNE	harakiri2 	; ooops, or end of file!
	SUBQ.W	#1,D1		; length of name, minus LF
	BEQ.S	loop		; if just an LF (empty line): next line
	MOVE.L	D5,A1		; point to memory again
	MOVE.W	D1,-(A1)		; into place now
	MOVE.L	A1,A0		; A0 points to filename
	MOVEQ	#1,D0
	MOVEQ	#1,D3
	MOVEQ	#-1,D1
	TRAP	#2		; OPEN FILE
	TST.L	D0
	BNE.S	harakiri		; ooops!
	BSR.S	concat		; concat now
	BNE.S	harakiri		; ooops!
	BRA.S	loop		; and do again


concat	MOVEQ	#38,D2		; space needed for reading file header
	MOVEQ	#-1,D3
	MOVE.L	D5,A1
	MOVEQ	#$47,D0
	TRAP	#3		; read file header
	TST.L	D0
	BNE.S	con_out		; ooops->...
	MOVE.L	D5,A1
	MOVE.L	(A1),D4		; D4 = file length
	BEQ.S	con_out		; if 0 length file (???) ->...
	MOVE.L	A0,A5		; keep channel ID
	MOVE.L	D4,D0		; memory space need for this file
	BSR.S	get_mem		; get it...
	BNE.S	con_out		; ooops->...
	MOVE.L	A0,A1		; point to space now
	EXG	A0,A5		; A0 = channel ID, A5 =  memory
	MOVE.L	D4,D2		; how much we read in (all of it)
	MOVEQ	#$48,D0
	TRAP	#3		; read entire file
	TST.L	D0
	BNE.S	con_out
	MOVEQ	#2,D0
	TRAP	#2		; close file
	MOVE.L	A5,A1		; A1 = file bytes
	MOVE.L	D4,D2		; D2 = length
	MOVE.L	D7,A0		; A0 = output file ID
	MOVEQ	#$7,D0
	TRAP	#3		; send the bytes
	TST.L	D0
	BNE.S	con_out
	MOVE.L	A5,A0		; release memory
	BRA.S	rel_mem		; and return with possible error from there
con_out	RTS


myregs	REG	D1-D3/A1-A3
get_mem	MOVEM.L	myregs,-(A7)	; typical get mem call
	MOVEQ	#-1,D2
comn	MOVE.L	D0,D1
	MOVEQ	#$18,D0		; MT_ALCHP
	TRAP	#1
	MOVEM.L	(A7)+,myregs
	TST.L	D0
	RTS

rel_mem	MOVEM.L	myregs,-(A7)
	MOVEQ	#$19,D0		; MT_RECHP
	TRAP	#1
	MOVEM.L	(A7)+,myregs
	TST.L	D0
	RTS

harakiri2 MOVEQ	#0,D0		; simulate no error
harakiri	MOVE.L	D0,D7		; keep error
	SUBQ.L	#2,D5
	MOVE.L	D5,A0		; point to mem for names
	BSR.S	rel_mem		; release it
	MOVE.L	D7,D0		; get original error back
hara	MOVE.L	D0,D3		; put it in reg now
hara3	MOVEQ	#-1,D1
	MOVEQ	#5,D0
	TRAP	#1		; remove this job now




	END
