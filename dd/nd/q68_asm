; Q68 timing constants          0.00 (c) W. Lenerz 2017

        section init

        xdef        nd_q68

        xref        nd_initb
        xref        nd_proctab
        xref        ut_procdef

        include 'dev8_keys_q68'


nd_q68  lea        ndt_q68,a1
        jsr        nd_initb
        lea        nd_proctab,a1
        jmp        ut_procdef




; when updating a counter
; 1 °s <-> 1 MHz : a 1 Mhz timer will update the counter once every 1 °s
; a 40 MHz timer will update the counter by 40 every °s
; so these timings here are just the number of ticks to get to the
; desired nbr of °s
diff        equ        0

ndt_q68
nsg_wgap dc.l        8000-diff        ; wait for gap constant                200us
nsg_lsct                              ; look for scout (wait 20 ms)        20000us
nsg_bace dc.l        800000-diff      ; look for broadcast acknowledge end 20000us
nsg_csct dc.l        1200-diff        ; check scout                           30us
nsg_esct dc.l        19400-diff       ; end of scout                         485us  486.7us
nsg_wsct dc.l        120000           ; wait to send scout                  3000us
nsg_tsct dc.l        282-diff        ; timer for scout active / inactive     31us/3 (282)
nsg_bsct                              ; broadcast scout detect               500us
nsg_back dc.l        20000-diff       ; broadcast acknowledge detect         500us
nsg_xsct                              ; extension to scout                  5000us
nsg_xack dc.l        200000-diff      ; (extension to) acknowledge          5000us
nsg_bnak dc.l        8000-diff        ; broadcast NACK delay                 200us
nsg_stmo dc.l        800000-diff      ; serial port timout                 20000us
nsg_paus dc.l        5600-diff        ; pause before send                    140us
nsg_send dc.l        448-diff         ; send loop timer, bit should be held for 11.2us
nsg_rtmo dc.l        100000-diff      ; receive timout                      2500us
nsg_rbto dc.l        3200-diff        ; receive bit timout  :  wait betwen last bit of old byte & 1st bit of new byte 80us
nsg_rdly dc.l        224-diff         ; receive delay start bit to mid-start-bit 5.6us
nsg_rbit dc.l        448-diff         ; receive bit loop timer                  11.2us
nsg_rept dc.l        280000-diff      ; NEW! Repeated Operation delay       7000us

        end
        
; the timings could be done as follows (?):

        move.l #nsg_wgap,d0
        add.l  q68_timer,d0
loop        ....
        cmp.l  q68_timer,d0
        bge.s  exit

; HOWEVER, the current phys_q68 code, like its predecessors, sometimes uses pairs of words per register
;  (e.g. ndt_rdly & ndt_rbit) and swaps between them dynamically during the bit-loops.
;   Loading full LWs thus wouldn't work without changing the code logic (not impossible, but not for v2.1).
; So, instead, we need to:
;   a) Extend the Linkage block to accomodate LW timing constants (currently only 16-bit Words) - in dd_nd_keys - see below
;   b) Adjust dd_nd_init (nd_initb) to move LWs in to the PDB/Linkage block
;   c) Use the indirect lookup scheme previously employed:

        moveq    #<ndt_offset>,d0      ; Load the <offset> WORD
        bsr      <ndt_timer_primitive>

ndt_timer_primitive
        move.l   (a3,d0.w),d0          ; Load the actual <timer-constant> LWORD
        add.l    (a2),d0               ; Calculate <end_time> = <now> + <timer_constant>
loop
        cmp.l    (a2),d0               ; Compare <current_time> against <end_time>
        bcc.s    exit                  ; Unsigned
        ...

; In fact, its a bit more complicated than that, due to the intermittent 'roll-over' of the UNSIGNED 32-bit HW timer
;  which is known to take place every 107s or so.
; To accomodate this, we explicitly check for a 'roll-over' falling between <start_time> and <end_time>, thus:

...
ndt_timer_primitive
        move.l   (a3,d0.w),d0          ; Load the actual <timer-constant> LWORD
        add.l    (a2),d0               ; Calculate <end_time> = <start_time=now> + <timer_constant>
        
        bcc.s    loop                  ; Did we roll-over?

; Yes? Then, first wait for the HW timer itself to roll-over...
wait_rollover
        tst.l    (a2)                  ; Where's d0? Actually, it's irrelevant right now...
        bmi.s    wait_rollover         ; NB! We are consciously (mis)treating the timer as a SIGNED value here
                                       ; When treated as SIGNED, exit the loop once it is no longer NEGative and hits zero
                                       
; Otherwise/thereafter, just test as usual for (smaller) UNSIGNED LW values before exiting the delay loop...
loop
        cmp.l    (a2),d0               ; Compare <current_time> against <end_time> - as usual
        bcc.s    exit                  ; Unsigned
        ...

; This logic works (?) because, when our relatively small constants (max 800,000) addition to an UNSIGNED LW causes a Carry,
;  then not only has the addition rolled-over zero, but the original <start_time> must have been > (2^32 - 800,000)
;  i.e., from the perspective of a SIGNED LW, <start_time> MUST have been NEGative to start with (> 2^31 in absolute terms).
; Or, at least I think so... Anyway, its looks neat and is the sort of nonsense that a Obfuscated PERL programmer might enjoy.

; And what about our Timer Table at ndt_ctab(a3)?
; We need to double-up the size of each constant from W to LW by adjusting each offset, thus

* timing constants (table offsets - extract from dd_nd_keys_q68)
ndt_ctab equ    $50

ndt_wgap equ    $50     wait for gap constant                200us
ndt_lsct equ    $54     (was $52) look for scout                     20000us
ndt_bace equ    $54     (was $52) look for broadcast acknowledge end 20000us
ndt_csct equ    $58     (was $54) check scout                        30;40us
ndt_esct equ    $5c     (was $56) end of scout                     475;485us
ndt_wsct equ    $60     (was $58) wait to send scout                  3000us
ndt_tsct equ    $64     (was $5a) timer for scout active / inactive   4;59(2)
ndt_bsct equ    $68     (was $5c) broadcast scout detect               500us
ndt_back equ    $68     (was $5c) broadcast acknowledge detect         500us
ndt_xsct equ    $6c     (was $5e) extension to scout                  5000us
ndt_xack equ    $6c     (was $5e) (extension to) acknowledge          5000us
ndt_bnak equ    $70     (was $60) broadcast NACK delay                 200us
ndt_stmo equ    $74     (was $62) serial port timout                 20000us
ndt_paus equ    $78     (was $64) pause before send                120;140us
ndt_send equ    $7c     (was $66) send loop timer                     2;33(0)
ndt_rtmo equ    $80     (was $68) receive timout                      2500us
ndt_rbto equ    $84     (was $6a) receive bit timout                    80us
ndt_rdly equ    $88     (was $6c) receive delay start bit to mid-start-bit 6;63(0)
ndt_rbit equ    $8c     (was $6e) receive bit loop timer              5;32(0)
ndt_ctop equ    $90     (was $70) 

ndd_endf equ    $90     end of net file linkage block