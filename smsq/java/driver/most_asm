; base area SMSQ JAVA Drivers
; v. 1.01  possibly set up scheduler loop to check if idle  & cleanup

	section header

	xref	smsq_end

header_base
	dc.l	gl_most-header_base	 ; length of header
	dc.l	0			 ; module length unknown
	dc.l	smsq_end-gl_most	 ; loaded length
	dc.l	0			 ; checksum
	dc.l	0			 ; always select
	dc.b	1			 ; 1 level down
	dc.b	0
	dc.w	smsq_name-*

smsq_name
	dc.w	17,'SMSQ JAVA Drivers '
	dc.l	'    '
	dc.w	$200a


	section base

	xref	iob_smsq		 ; SMSQ IOB bits

	xref	qd_int2

	xref	hdop_init
	xref	nfa_init
	xref	mem_init
	xref	sfa_init
	xref	win_init
	xref	sms_hdop
	xref	dev_init
	xref	nul_init
	xref	pipe_init
	xref	rd_init
	xref	iob_init
	xref	history_init
	xref	ssss_init
	xref	hdop_keyr
	xref	scrap_init
	xref	snd_init
	xref	tmr_init

	include 'dev8_keys_qlv'
	include 'dev8_keys_sys'
	include 'dev8_keys_psf'
	include 'dev8_keys_68000'
	include 'dev8_keys_qlhw'
	include 'dev8_keys_qdos_sms'
	include 'dev8_smsq_smsq_base_keys'
	include 'dev8_smsq_smsq_config_keys'
	include 'dev8_smsq_gold_keys'
	include 'dev8_keys_qdos_ioa'
	include 'dev8_keys_java'
	include 'dev8_mac_assert'


gl_most
	bra.l	start

	xdef	iou_dirshr
iou_dirshr dc.w 0	; shared directories supported	(RAM disk)


	section init
start
	jsr	hdop_init
	jsr	dev_init
	jsr	nul_init
	jsr	pipe_init
	jsr	rd_init
	jsr	iob_init
	jsr	history_init
	jsr	sfa_init
	jsr	nfa_init
	jsr	mem_init
	jsr	win_init
	jsr	ssss_init
	jsr	scrap_init
	jsr	snd_init
	jsr	tmr_init

sys_init

; When we have linked in the interrupt servers, we can enable the interrupts

	moveq	#sms.xtop,d0
	trap	#do.sms2

	clr.w	psf_sr(a5)		; we can clear interrupts on return

	lea	qd_int2,a0		; set interrupt routine address
	lea	exv_i2,a5
	move.l	a0,(a5)

	move.b	 #0,sys_qlir(a6)	 ; always clear interface int

	lea	hw_poll,a0
	lea	sms.hpoll,a5		; setup harware poll, which is just anrts
	move.l	a0,(a5)

	lea	sms_hdop,a0
	lea	sms.t1tab+sms.hdop*4,a5 ; set hdop
	move.l	a0,(a5)+


	tst.b	sms.conf+sms_nqimi	; use less cpu if idle?
	beq.s	exit			; no ->...
	lea	sched,a0		; yes, link in my scheduler routine
	clr.l	(a0)+			; just in case
	lea	jva_sched,a1
	move.l	a1,(a0)
	subq.l	#4,a0
	moveq	#sms.lshd,d0
	trap	#$1
exit	clr.l	d0
hw_poll 				; this is the "hardware poll" !!!!!!
	rts

	dc.l	0			; space for possible scheduler routine link
sched	dc.l	0,0


**********
*
* Java scheduler routine - tries to see whether machine is busy
*
**********
jva_sched
	dc.w	jva.trp7
	rts

	end
