; base area SMSQ JAVA Drivers
; v. 1.01  possibly set up scheduler loop to check if idle  & cleanup
; v. 1.02 2015 May 24  possibly use ieee routines
; v. 1.03 2015 Jul 29  integrated the rtc routines

	section header

	xref	smsq_end

header_base
	dc.l	gl_most-header_base	 ; length of header
	dc.l	0			 ; module length unknown
	dc.l	smsq_end-gl_most	 ; loaded length
	dc.l	0			 ; checksum
	dc.l	0			 ; always select
	dc.b	1			 ; 1 level down
	dc.b	0
	dc.w	smsq_name-*

smsq_name
	dc.w	24,'SMSQ JAVA Drivers & RTC '
	dc.w	$200a


	section base
	xdef	qpc_patchfpu
	xdef	qpc_patch2ql

	xref	iob_smsq		 ; SMSQ IOB bits

	xref	qd_int2

	xref	hdop_init
	xref	nfa_init
	xref	mem_init
	xref	sfa_init
	xref	win_init
	xref	sms_hdop
	xref	dev_init
	xref	nul_init
	xref	pipe_init
	xref	rd_init
	xref	iob_init
	xref	history_init
	xref	ssss_init
	xref	hdop_keyr
	xref	scrap_init
	xref	snd_init
	xref	tmr_init

	include 'dev8_keys_qlv'
	include 'dev8_keys_sys'
	include 'dev8_keys_psf'
	include 'dev8_keys_68000'
	include 'dev8_keys_qlhw'
	include 'dev8_keys_qdos_sms'
	include 'dev8_smsq_smsq_base_keys'
	include 'dev8_smsq_smsq_config_keys'
	include 'dev8_smsq_gold_keys'
	include 'dev8_keys_qdos_ioa'
	include 'dev8_keys_java'
	include 'dev8_mac_assert'


gl_most
	bra.l	start

	xdef	iou_dirshr
iou_dirshr dc.w 0	; shared directories supported	(RAM disk)


	section init
start
	jsr	hdop_init
	jsr	dev_init
	jsr	nul_init
	jsr	pipe_init
	jsr	rd_init
	jsr	iob_init
	jsr	history_init
	jsr	sfa_init
	jsr	nfa_init
	jsr	mem_init
	jsr	win_init		; keep as last device driver
	jsr	ssss_init
	jsr	scrap_init
	jsr	snd_init
	jsr	tmr_init
sys_init

; When we have linked in the interrupt servers, we can enable the interrupts

	moveq	#sms.xtop,d0
	trap	#do.sms2

	clr.w	psf_sr(a5)		; we can clear interrupts on return

	lea	qd_int2,a0		; set interrupt routine address
	lea	exv_i2,a5
	move.l	a0,(a5)

	move.b	 #0,sys_qlir(a6)	 ; always clear interface int

	lea	hw_poll,a0
	lea	sms.hpoll,a5		; setup harware poll, which is just anrts
	move.l	a0,(a5)

	lea	sms_hdop,a0
	lea	sms.t1tab+sms.hdop*4,a1 ; set hdop
	move.l	a0,(a1)+
	tst.b	sms.conf+sms_ieee	; use patched FP routines?
	beq.s	cpu_rtc 		; no ->
	bsr.s	qpc_patchfpu

cpu_rtc
	assert	sms.rrtc,sms.srtc-1,sms.artc-2
	lea	sms.t1tab+sms.rrtc*4,a1  ; set rtc
	lea	sms_rrtc,a0
	move.l	a0,(a1)+
	lea	sms_srtc,a0		; srtc and artc are not implemented
	move.l	a0,(a1)+
	move.l	a0,(a1)

cpu_idl tst.b	sms.conf+sms_nqimi	; use less cpu if idle?
	beq.s	exit			; no ->...
	lea	sched,a0		; yes, link in my scheduler routine
	clr.l	(a0)+			; just in case
	lea	jva_sched,a1
	move.l	a1,(a0)
	subq.l	#4,a0
	moveq	#sms.lshd,d0
	trap	#$1
exit	clr.l	d0
hw_poll 				; this is the "hardware poll" !!!!!!
	rts

	dc.l	0			; space for possible scheduler routine link
sched	dc.l	0,0


**********
*
* Java scheduler routine - tries to see whether machine is busy
*
**********
jva_sched
	dc.w	jva.trp7
	rts




; this is a pure copy of the corresponding code in qpc
; patch the FP routines to call java routines

qpc_patchfpu
	movem.l a0/a1,-(a7)
	movea.w $11c,a0 		 ; FP vector (points to a jump)
	movea.l 2(a0),a0		 ; Get address from jmp and use as base
	lea	qpc_patchtable(pc),a1
qpc_patchloop
	move.w	(a1)+,d0
	beq.s	qpc_endpatch
	move.w	(a1)+,d1
	cmp.w	(a0,d0.w),d1		 ; Original code ok?
	bne.s	qpc_endpatch		 ; No, just quit patching
	move.w	(a1)+,(a0,d0.w) 	 ; Patch new code
	bra.s	qpc_patchloop

qpc_endpatch
	movem.l (a7)+,a0/a1
	rts

ib	equ	$ab00

qpc_patchtable
;		adr  ,origi,patch
	dc.w	$0a2c,$48e7,ib+0	 ; ADDD
	dc.w	$0a62,$48e7,ib+1	 ; ADD
	dc.w	$0a3c,$48e7,ib+2	 ; SUBD
	dc.w	$0a5e,$4eba,ib+3	 ; SUB
	dc.w	$0ad8,$3011,ib+4	 ; DOUBLE
	dc.w	$0aec,$5351,ib+5	 ; HALVE
	dc.w	$08ae,$48e7,ib+6	 ; DIVD
	dc.w	$08be,$48e7,ib+7	 ; DIV
	dc.w	$08b6,$4eba,ib+8	 ; 1/x
	dc.w	$0934,$48e7,ib+9	 ; MULD
	dc.w	$0948,$48e7,ib+10	 ; MUL
	dc.w	$093c,$48e7,ib+11	 ; x^2
	dc.w	$09fc,$2341,ib+12	 ; SQRT
	dc.w	$06b0,$48e7,ib+13	 ; COS
	dc.w	$06bc,$48e7,ib+14	 ; SIN
	dc.w	$0702,$4eba,ib+15	 ; COT
	dc.w	$0714,$4eba,ib+16	 ; TAN
	dc.w	0

; patch old smsq/e routines back in

qpc_patch2ql
	movem.l a0/a1,-(a7)
	movea.w $11c,a0 		; FP vector (points to a jump)
	movea.l 2(a0),a0		; Get address from jmp and use as base
	lea	qpc_patchtable(pc),a1
qpc_patchlp
	move.w	(a1)+,d0
	beq.s	qpc_end
	move.w	(a1)+,d1		: original SMSQ/E code
	move.w	(a1)+,d2		; patched code
	cmp.w	(a0,d0.w),d2		; patched code ok?
	bne.s	qpc_end 		; no, just quit patching
	move.w	d1,(a0,d0.w)		; patch original code back in
	bra.s	qpc_patchlp

qpc_end
	movem.l (a7)+,a0/a1
	rts

;+++
; Read date taking the Year Month Day Hour Minute and Second from the RTC
;
;	d1  r  date
;	status return 0 or err.nc
;---
sms_rrtc
	move.l	sms.rte,-(sp)
	moveq	#jt5.time,d0
	dc.w	jva.trp5			; get time from JVM
	rts

;+++
; Adjust the RTC date by D1 seconds
;
;	d1 cr  adjustment / date
;	status return 0
;---
;+++
; Set date taking putting Year Month Day Hour Minute and Second into the RTC
;
;	d1 cp  date
;	status return 0 or err.nc
;---

; these are not implemented

sms_srtc
sms_artc
	move.l	sms.rte,-(sp)
	moveq	#0,d0
	rts




	end
