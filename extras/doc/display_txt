Preliminary documentation to most of the enhancements to SMSQ/E v3.00 and following,
mostly directed at programmers. "Preliminary" means that here is at least
some text to see what's new and how to use it. This documentation certainly
needs to be enhanced and improved. "Preliminary" does not mean that facts
stated herein are going to get changed, due to the release of SMSQ/E v3.00
they are now fixed.

All the best, Marcel Kilgus


Contents:


	I - New CON Drivers Vectors
	II - New Wman vectors
	III - New Sprite definition
	IV - New WMAN colour format
	V - System palette entries
	VI - New Basic commands
	VII - New Move modes
	VIII - Csizes for menu appsub windows
	IX - Using alpha blending


I - New CON driver vectors
=-=-=-=-=-=-=-=-=-=-=-=-=-


A new vector block has been introduced to provide direct access to new
screen driver functions. To call one of those functions, one first needs
a pointer to the CON linkage block. This can either be obtained in the traditional
way or by reading the sys_clnk ($c4) system variable. It is planned that future
PTR_GEN/WMANs for non-SMSQ/E version will also support this system variable.
On current non-SMSQ/E systems its value should be 0.

The pointer to the vector table itself is located in the new pt_vecs variable
within the linkage block. A typical call sequence can thus look like this:

	moveq	#sms.info,d0
	trap	#1			; get ptr to system variables in a0
	move.l	sys_clnk(a0),a3 	; ptr to CON linkage
	move.l	pt_vecs(a3),a0		; vector table
	jsr	pv_fspr(a0)		; actual call


PLEASE NOTE:

All vectors so far expect a3 to be the pointer to the CON linkage block on
entering the call.

With the above code, this is done automatically.


The keys (e.g. the values of pv_pinf, pv_fspr etc) are contained in the
file "dev8_keys_con".


|									      |
|  Vector $00							pv_pinf       |
|									      |
|	Like iop.pinf, but one doesn't need a channel to call this routine.   |
|									      |
|  Call parameters							      |
|  D1					D1   pointer version number	      |
|  D2					D2   preserved			      |
|  D3					D3   preserved			      |
|									      |
|  A0					A0   preserved			      |
|  A1					A1   pointer to WMAN		      |
|  A2					A2   preserved			      |
|  A3	pointer to CON linkage block	A3   preserved			      |
|									      |
No error returns - this routine always succeeds.



|									      |
|  Vector $06							pv_fspr       |
|									      |
|	Look in linked sprite list for the definition that would actually     |
|	be used in the current display mode.				      |
|									      |
|  Call parameters			Return parameters		      |
|  D1					D1   preserved			      |
|  D2					D2   preserved			      |
|  D3					D3   preserved			      |
|									      |
|  A1	ptr to 1st sprite		A1   ptr to fitting sprite	      |
|  A2					A2   preserved			      |
|  A3	ptr to CON linkage block	A3   preserved			      |
|									      |

No error returns - this routine always "succeeds".
If no fitting sprite is found, a pointer to the arrow sprite is returned!



|									      |
|  Vector $0C							pv_sspr       |
|									      |
|	Set system sprites/Get system sprite address			      |
|									      |
|  Call parameters			Return parameters		      |
|									      |
|  D1.w sprite number / -ve		D1   pres./ Max allowed | max current |
|  D2					D2   preserved			      |
|  D3					D3   preserved			      |
|									      |
|  A0					A0   preserved			      |
|  A1	pointer to sprite / 0		A1   preserved / pointer to sprite    |
|  A2					A2   preserved			      |
|  A3	pointer to CON linkage block	A3   preserved			      |
|									      |
|  Error returns:							      |
|	IPAR	Illegal sprite number (set/get) 			      |
|	ITNF	there are no system sprites !				      |
|									      |

This gets or sets a system sprite or returns the max nbr of system sprites
  * if d1 is a negative nbr (-1 is suggested), then on return d1 contains:
     max nbr of space in table for sys sprites | highest nbr of current system sprite
  else:
    * if a1 = 0, then one gets the address of the system sprite the number
       of which is passed in D1. The address is returned in a1.
       This address MAY be 0, in which case the system sprite requested does
       not exist. This will only happen if somebody fiddled with the table
       contrary to recommendations
    * if a1 <> then it contains the address of a sprite that will be a system
       sprite, d1 contains the number of that sprite. This sprite is not
       " copied to a safe place", it is the responsibility of the calling
       job to make sure that the sprite doesn't just disappear

For a list of the system sprites defined thus far see keys_sysspr.


The sprite table has the following format:

       -2      max nbr of sprites possible in table
       0       nbr of sprites currently in table
       2+      long word absolute pointers (i.e real addresses of sprites)
			 ========


|  Vector $12				pv_size 			      |
|									      |
|  Get shift sizes							      |
|									      |
|  Call parameters			Return parameters		      |
|  D0					D0   pt.spxlw | pt.rpxlw	      |
|  D1					D1   preserved			      |
|  D2					D2   preserved			      |
|  D3					D3   preserved			      |
|									      |
|  A0					A0   preserved			      |
|  A1					A1   preserved			      |
|  A2					A2   preserved			      |
|  A3	pointer to CON linkage block	A3   preserved			      |
|									      |
|  D0 returns : 							      |
|	pt.spxlw : shift pixels to long word				      |
|	pt.rpxlw : round up pixels to long word 			      |
|									      |
|  Error returns:							      |
|	None, this vector always succeeds.				      |
|	The value in D0 is not an error return				      | 						|





|  Vector $18			       pv_mblk				      |
|									      |
|  Moves a block of screen memory about 				      |
|									      |
|									      |
|  Call parameters			Return parameters		      |
|  D0					D0   smashed (undefined)	      |
|  D1  size of section to move		D1   smashed			      |
|  D2  old origin in source area	D2   smashed			      |
|  D3  new origin in destination area	D3   smashed			      |
|  D4					D4   smashed			      |
|  D5					D5   smashed			      |
|									      |
|  A2  row increment of source area	A2   smashed			      |
|  A3  row increment of dest. area	A3   smashed			      |
|  A4  base address of source area	A4   smashed			      |
|  A5  base address of destination area A5   smashed			      |
| All other registers are preserved					      |
|									      |
|									      |
|  Error returns:							      |
|	None, this vector always succeeds.				      |
|	The value in D0 is not an error return				      | 						|

This moves a block of screen memory about, from source to destination.
The x|y size of the block, in pixels, is contained in D1 on entry.

Note : do not (mis)use this vector to move general memory about. The size of
the memory actually moved depends on the screen driver that is being used.
Thus, if you move a block of 10x20 pixels (x|y size), in modes 16 and 31,
then 200 bytes will be moved (1 pixel = 1 byte). In modes 32 and 33, 400 bytes
will be moved (1 pixel = 2 bytes) and in the Ql modes, less bytes will be moved.




|  Vector $1E				pv_cursp
|									      |
|  Sets the per job cursor						      |
|									      |
|  Call parameters			Return parameters		      |
|  D0					D0   error			      |
|  D1	jobID				D1   smashed			      |
|  D2	status wished (0|1)		D2   preserved			      |
|  D3					D3   preserved			      |
|									      |
|  A0					A0   preserved			      |
|  A1					A1   preserved			      |
|  A2					A2   preserved			      |
|  A3	pointer to CON linkage block	A3   preserved			      |
|									      |
| Error returns:							      |
|	IJOB	wrong job ID						      |
|	NIMP	something went horribly wrong : no job table!		      |
|									      |
									      |
Please see the cursor_txt file for further explanations on this vector.       |




|  Vector $24				pv_bgctl			      |
|									      |
|  Gets/sets the background I/O status					      |
|									      |
|  Call parameters			Return parameters		      |
|  D0					D0   standard error code	      |
|  D1	-1 read, 0 disable, 1 enable	D1   0 disabled, >0 enabled	      |
|  D2	0				D2   preserved			      |
|  D3					D3   preserved			      |
|									      |
|  A0					A0   preserved			      |
|  A1					A1   preserved			      |
|  A2					A2   preserved			      |
|  A3	pointer to CON linkage block	A3   preserved			      |
|									      |
| Error returns:							      |
|	IPAR	D2 is not 0						      |
|	NIMP	OS is not background I/O compatible			      |
|									      |

This sets or gets the background I/O status. If D1 is negative on entry, the
current background I/O status is returned, else the current background I/O
status is set according to the value of D1 (any value other than 0 enables
background I/O).





|  Vector $2A							pv_cmbblk     |
|									      |
|  Combines two blocks of (screen) memory with alpha blending and puts the    |
|  result into the destination block					      |
|									      |
|									      |
|  Call parameters			Return parameters		      |
|  D0					D0   smashed (undefined)	      |
|  D1  size of block to combine 	D1   smashed			      |
|  D2  origin in source area 1		D2   smashed			      |
|  D3  new origin in destination area	D3   smashed			      |
|  D4  origin in source area 2		D4   smashed			      |
|  D5					D5   smashed			      |
|  D6  alpha value			D6   preserved			      |
|  D7  row increment of source area 2	D7   smashed			      |
|									      |
|  A1  base address of source area 2	A1   smashed			      |
|  A2  row increment of source area 1	A2   smashed			      |
|  A3  row increment of dest. area	A3   smashed			      |
|  A4  base address of source area 1	A4   smashed			      |
|  A5  base address of destination area A5   smashed			      |
| All other registers are preserved					      |
|									      |
|									      |
|  Error returns:							      |
|	None, this vector always succeeds.				      |
|	The value in D0 is not an error return				      | 						|


This will combine the pixels of two blocks of screen memory with an alpha blending
operation and put the resulting block into the destination.
The x|y size of the block, in pixels, is contained in D1 on entry.
D6 contains the alpha value, from 1 (nearly transparent) to 255 (totally opaque),
in the LSB.

NOTE 1 : This vector is only implemented for screen modes where alpha blending
actually makes sense, i.e. modes 16, 32 and 33. In other screen modes, such
as the QL screen modes, or atari mono modes, this vector is redirected to
vector pv_mblk.

NOTE 2 : Do not (mis)use this vector to combine general memory. The size of
the memory actually combined depends on the screen driver that is being used.
Thus, if you combine a block of 10x20 pixels (x|y size), in mode 16,
then 200 bytes will be combined (1 pixel = 1 byte). But in modes 32 and 33,
200 words (400 bytes) will be combined (1 pixel = 2 bytes).






-------------------------------------------------------------------------------
-------------------------------------------------------------------------------



II - New WMAN vectors
=-=-=-=-=-=-=-=-=-=-=

|									      |
|  Vector $7C							WM.SETSP      |
|									      |
|	Set system palette entries					      |
|									      |
|  Call parameters			Return parameters		      |
|									      |
|  D1.w start index			D1   preserved			      |
|  D2.w number of elements		D2   preserved			      |
|  D3.w number of palette (0-3) 	D3+  all preserved		      |
|									      |
|  A0					A0   preserved			      |
|  A1	pointer to palette entries / 0	A1   preserved			      |
|  A2					A2   preserved			      |
|  A3					A3   preserved			      |
|  A4					A4   preserved			      |
|  A5	not used by any routine 					      |
|  A6	not used by any routine 					      |
|									      |
|  Error returns:							      |
|	IPAR	Illegal index number / invalid number of elements	      |
|									      |

Set the entries of the system palette indexed in D3 (from 0 to 3) to the
values in the buffer, beginning with the index in D1 (counting from 0)
and ending with the index D1 + D2 - 1.

If A1 = 0 then the entries are taken out of the default table. Otherwise
the buffer must hold an array of words with the colour values of the
different items. The colour format is the standard WMAN colour format as
described elsewhere.


|									      |
|  Vector $80							WM.GETSP      |
|									      |
|	Read system palette entries					      |
|									      |
|  Call parameters			Return parameters		      |
|									      |
|  D1.w start index			D1   preserved			      |
|  D2.w number of elements / -1 	D2.w preserved / item count	      |
|  D3.w number of palette (0-3) 	D3+  all preserved		      |
|									      |
|  A0					A0   preserved			      |
|  A1	pointer to entry buffer 	A1   preserved			      |
|  A2					A2   preserved			      |
|  A3					A3   preserved			      |
|  A4					A4   preserved			      |
|  A5	not used by any routine 					      |
|  A6	not used by any routine 					      |
|									      |
|  Error returns:							      |
|	IPAR	Illegal index number / invalid number of elements	      |
|									      |

Copies entries of the system palette indexed in D3 (from 0 to 3) into the given
buffer, beginning with the index in D1 (counting from 0) and ending with the
index D1 + D2 - 1. The buffer must be big enough to hold all requested entries.

If D1 is given as -1 the function just returns the number of items held in
the system palette. This can increase when more items get defined in new
WMAN version. This is guaranteed to be below 256.


|									      |
|  Vector $84							WM.TRAP3      |
|									      |
|	Trap #3 replacement that handles WMAN colour codes		      |
|									      |
|  Call parameters			Return parameters		      |
|									      |
|  D0.l function code			D0   error code 		      |
|  D1.w colour code			D1   preserved			      |
|  D2+	parameter			D2+  result according to trap	      |
|									      |
|  A0.l channel id			A0   preserved			      |
|  A1+	parameter			A1+  result according to trap	      |
|									      |
|  Error returns:							      |
|	same as original traps						      |
|									      |

This is a drop-in replacement for a "trap #3" call.
D0 reacts to any of the codes iow.defb, iow.defw, iow.spap, iow.sstr, iow.sink
and iow.blok. Those routines are exchanged by some that can handle the extended
WMAN colour codes. Other function codes are directly passed to an ordinary
"trap #3" call.
The condiditon codes are guaranteed to be set properly according to D0, for
all traps.


|									      |
|  Vector $88							WM.OPW	      |
|									      |
|	Emulate OPW.WIND, OPW.CON and OPW.SCR vectored routines 	      |
|									      |
|  Call parameters			Return parameters		      |
|									      |
|  D0.l OPW.WIND, OPW.CON or OPW.SCR	D0    error code		      |
|  D1					D1    smashed			      |
|  D2					D2    smashed			      |
|  D3					D3    smashed			      |
|									      |
|  A0.l ptr to name (OPW.WIND only)	A0.l  channel ID		      |
|  A1.l ptr to parameter block		A1    smashed			      |
|  A2					A2    smashed			      |
|  A3					A3    smashed			      |
|									      |
|  Error returns:							      |
|	same as original functions					      |
|									      |

This is a replacement for the OPW.WIND, OPW.CON and OPW.SCR vectored routines.
In contrast to the originals the paramater block pointed to by A1 is in
words instead of bytes:

$00  border colour (word)
$02  border width (word)
$04  paper/strip colour (word)
$06  ink colour (word)

OPW.CON and OPW.SCR define the window using an additional block of four words:

$08  width (word)
$0A  height (word)
$0C  X-origin (word)
$0E  Y-origin (word)


|									      |
|  Vector $8C							WM.SSCLR      |
|									      |
|	Set single colour pattern					      |
|									      |
|  Call parameters			Return parameters		      |
|									      |
|  D0					D0   0				      |
|  D1.w colour number			D1   preserved			      |
|					D2+  all preserved		      |
|									      |
|  A1.l ptr to window status area	A1   preserved			      |
|  A2.l ptr to pattern space		A2   preserved			      |
|  A3					A3   preserved			      |
|  A4					A4   preserved			      |
|  A5	not used by any routine 					      |
|  A6	not used by any routine 					      |
|									      |

Returns a pattern that is filled with the given colour. The space pointed to
by A1 must hold at least $60 bytes. Does not work for stippled colours.


|									      |
|  Vector $90							WM.JBPAL      |
|									      |
|	Set system palette number of job				      |
|									      |
|  Call parameters			Return parameters		      |
|									      |
|  D1.l job ID / -1			D1   preserved			      |
|  D2					D2   preserved			      |
|  D3.w palette number / -1		D3+  all preserved		      |
|									      |
|  A0					A0   preserved			      |
|  A1	ptr to job palette or 0 (D3=-1) A1   preserved			      |
|  A2					A2   preserved			      |
|  A3					A3   preserved			      |
|  A4					A4   preserved			      |
|  A5	not used by any routine 					      |
|  A6	not used by any routine 					      |
|									      |
|  Error returns:							      |
|	IJOB	Invalid job ID						      |
|									      |

Sets the active system palette for the given job. If D1 is -1 then the
current job will be used.
D3 can be supplied as -1 which can be used to give the job its very own
palette. In this case a pointer to the palette can be supplied in A1.
Attention: the contents of this area is not copied, it is used directly
and must remain there as long as the job uses this palette!
If A1 is supplied as 0 the palette pointer will not be touched.


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------


III - New sprite definition
=-=-=-=-=-=-=-=-=-=-=-=-=-=

	A - Sprite Mode byte
	B - Sprite control byte
	C - Alpha channel
	D - Sprite compression
	E - Sprite block
	F - Options pointer


The sprite definition has been extensively modified, but in such a way
that it should continue to be compatible with older sprites.

The sprite header is now as follows:

pto_form $00  byte  sprite mode
	 $01  byte  colour mode / system sprite number
pto_vers $02  byte  dynamic sprite version number
pto_ctrl $03  byte  sprite control
pto_xsiz $04  word  X size
pto_ysiz $06  word  Y size
pto_xorg $08  word  X offset
pto_yorg $0a  word  Y offset
pto_cpat $0c  long  relative pointer to colour pattern
pto_mask $10  long  relative pointer to mask/alpha channel
pto_nobj $14  long  relative pointer to next object

pto_opts $18  long  OPTIONAL (relative pointer to) options
pto_blk  $1c  long  OPTIONAL relative pointer to sprite block


(the keys can be found in DEV8_keys_qdos_pt)


A - Sprite MODE byte
--------------------

Sprite mode can be any of the following:
	0	system sprite
	1	traditional QL colour sprite (as before)
	2	GD2 colour sprite


System sprite:
	When the sprite mode is 0 for system sprites then the second byte
	is the number of the sprite. ALL other values are ignored in that
	case, i.e. a system sprite reference is only 2 bytes long.

QL colour sprite:
If this is a traditional Ql colour sprite, then the colour mode byte has one
of the following values (as before)

	0	mode 4
	1	mode 8

GD2 colour sprite:
	0	1 bit black&white
	3	1 bit palette mapped
	4	2 bit fixed gr palette
	7	2 bit palette mapped
	8	4 bit fixed irgb palette
	15	4 bit palette mapped
	16	8 bit fixed palette (equals Aurora palette)
	31	8 bit palette mapped
	32	16 bit QPC/QXL %gggbbbbbrrrrrggg format
	33	16 bit Q40 %gggggrrrrrbbbbbw format
	64	32 bit $RRGGBB00 format



B - Sprite control byte:
------------------------
The sprite control bit is formatted as follows
	 16368421
	%mpao0xcc

	cc
	stands for a chache version number. Programs can increment this
	value to signal the cache that the sprite has changed. A special
	value is pto.fupd (force update, %11), which causes the system to
	never use the cached version.
	key: pto.cver

	a
	flags whether the sprite uses an alpha channel instead of a mask
	(see below)
	key: pto.alph

	m and p
	signal whether the pattern (p) or the mask (m) is compressed (see below)
	key: pto.pcmp and pto.mcmp

	x
	signals that the optional pointer to a sprite block is present (bit x=1)
	or is not present (bit x=0) (see below)
	key pto..blk

	o signals that options are present (=1) or not (=0)(see below)
	key pto..opt
	currently unused

C - Alpha channel:
------------------
	When the pto.alph flag is set in the sprite control byte, the mask
	is considered to be an alpha channel. An alpha channel allows gradual
	mixes between the background and the sprite pattern. Every pixel is
	represented by exactly one byte. 0 means the pixel is completely
	transparent, 255 means the pixel is completely opaque. Values in
	between determine the degree of mixing of background and foreground.
	Alpha channel information is not padded at the end of each line.
	There's one byte for every pixel and nothing more.


D - RLE compression:
--------------------
	Both pattern and mask/alpha channel can be compressed using a simple
	RLE (run length encoding) algorithm. This is usefull with data that
	is largely homogene, which is often the case with masks.
	Compressed data must be signaled in the sprite control byte
	(pto.pcmp, pto.mcmp) and starts with the bytes 'RLEx', with 'x' being
	either 1, 2 or 4. This is the item size the algorithm is working with.
	8 bit RLE compression of 32 bit data wouldn't yield in good results,
	therefore the algoritm can also work on 16 bit or 32 bit data.
	After the ID there's one long word containing the size of the data in
	uncompressed form. After that the compressed data itself is following.

	The compressed data always consists of one byte and one or more items.
	If the leading byte is in the range of 0<=x<128 then x+1 uncompressed
	items are following. Otherwise only one item is following, which
	represents 257-x times the same item in the uncompressed data.

Examples:

A small blue circle, with hard transparency mask in 8 bit mode:

sp_circle
	dc.w	$0210,0 		; 8 bit mode
	dc.w	5,5,0,0 		; size 5x5 pixels with origin at 0x0
	dc.l	s8p_circle-*
	dc.l	s8m_circle-*
	dc.l	0

s8p_circle
	dc.b	$00,$27,$27,$27,$00,0,0,0	; Note the padding
	dc.b	$27,$27,$27,$27,$27,0,0,0
	dc.b	$27,$27,$27,$27,$27,0,0,0
	dc.b	$27,$27,$27,$27,$27,0,0,0
	dc.b	$00,$27,$27,$27,$00,0,0,0

x	equ	-1
s8m_circle
	dc.b	0,x,x,x,0,0,0,0 	; Same padding as pattern
	dc.b	x,x,x,x,x,0,0,0
	dc.b	x,x,x,x,x,0,0,0
	dc.b	x,x,x,x,x,0,0,0
	dc.b	0,x,x,x,0,0,0,0


Now the same circle with some soft alpha shading

sp_circle
	dc.w	$0210,pto.alph		; 8 bit mode, alpha blending
	dc.w	5,5,0,0 		; size 5x5 pixels with origin at 0x0
	dc.l	s8p_circle-*
	dc.l	s8a_circle-*
	dc.l	0

s8p_circle
	dc.b	$00,$27,$27,$27,$00,0,0,0	; Note the padding
	dc.b	$27,$27,$27,$27,$27,0,0,0
	dc.b	$27,$27,$27,$27,$27,0,0,0
	dc.b	$27,$27,$27,$27,$27,0,0,0
	dc.b	$00,$27,$27,$27,$00,0,0,0

s8a_circle
	dc.b	$00,$40,$40,$40,$00	; Note: no padding!
	dc.b	$40,$80,$80,$80,$40
	dc.b	$40,$80,$FF,$80,$40
	dc.b	$40,$80,$80,$80,$40
	dc.b	$00,$40,$40,$40,$00


Finally the same circle with alpha blending and compression

sp_circle
	dc.w	$0210,pto.alph+pto.pcmp+pto.mcmp ; 8 bit mode
	dc.w	5,5,0,0 		; size 5x5 pixels with origin at 0x0
	dc.l	s8p_circle-*
	dc.l	s8a_circle-*
	dc.l	0

s8p_circle
	dc.b	'RLE1'			; bytes sized RLE algorithm
	dc.l	8*5			; uncompressed data size
	dc.b	$00,$00,$FE,$27,$FD,$00 	; 1st line
	dc.b	$FC,$27,$FE,$00 		; 2nd line
	dc.b	$FC,$27,$FE,$00 		; ...
	dc.b	$FC,$27,$FE,$00
	dc.b	$00,$00,$FE,$27,$FD,$00 	; saved 8 bytes in total. Yeah

s8a_circle
	dc.b	'RLE1'
	dc.l	5*5
	dc.b	$00,$00,$FE,$40,$01,$00 	; 1st line
	dc.b	$40,$FE,$80,$FF,$40		; 2nd line
	dc.b	$02,$80,$FF,$80,$FF,$40 	; begins at 2nd byte of 3rd line
	dc.b	$FE,$80,$01,$40 		; begins at 2nd byte of 4th line
	dc.b	$00,$FE,$40,$00,$00		; 5th line

Of course RLE compression doesn't make much sense here, it's just for the sake
of the example. Note also that the compression of pattern and mask are
independant, in this case one could have left the alpha channel alone and only
compress the pattern. If the 8 bytes are worth it...


E - Sprite block
--------------------------------

The object drawing routines have been amended so as to allow different sprites
to be drawn in loose menu items, depending on the status of that item.

In such a case, it behooves the application to supply the different sprites and
to set up a "sprite block" which is just a block of 5 longword pointers, as
defined just below.

To keep things compatible with older versions of WMAN, this has been handled
by setting a bit (pto..blk) in the sprite control byte. If this bit is set to 1,
then there must be a pointer pointer to a sprite block. Please note that this
pointer MUST be preceeded by the (pointer to) additional options (see section F
below) which, currently is just a longword 0.

IF pto..blk IS SET, THEN pto_opts MUST EXIST (AS A LONG WORD 0) AND pto_blk
MUST POINT TO A VALID BLOCK.

The sprite pointer block is just a block of 5 longword pointers:

pointer to sprite if item is available
pointer to sprite if item is available AND is the current item
pointer to sprite if item is selected
pointer to sprite if item is selected AND is the current item
pointer to sprite if item is unavailable

In all cases, these are long word relative pointers.

All but the first pointer may be 0. The first pointer (item available) MUST
exist and point to a real sprite.


0 pointers are handled as follows

- For available items:
  * The pointer to the available item sprite MUST exist.

  * If no pointer to an available AND current item sprite exists, then the
    available item sprite is taken instead
     
- For selected items:
  * If no pointer to a selected item exists, then the pointer to the selected
    item AND current item is ALSO ignored. The avilable item sprite is taken
    instead for both.

  * If no pointer to a selected AND current item sprite exists, then the
    selected item sprite is taken instead.

- For unavailavle items, the available item sprite is used.


It is allowed, but not necessary, for any of these pointers including the first
pointer (available item) to point back to the original sprite, which will then
be drawn as a normal sprite!

This allows three cases:

1 - The original sprite can be an ordinary QL mode sprite, which will be
drawn normally by older versions of WMAN. The newer versions of WMAN will
use the extended format.

2 - The original sprite could be a simple empty shell, with just the relevant
data (bit pro..blk) and the pointer to a sprite block set.

3 - The original sprite could be a normal QL or 24 bit mode sprite which
will be used by an item in any of its statusses.


Alternative 1 above will ensure that your software remains compatible with
older versions of WMAN.

F - Options

To provide for future expandability of the sprite format, a special bit in
the sprite control byte indicates whether the sprite definition is followed
by an options long word or pointer. If bit pto..opt is set, then this options
long word or pointer must exist.

At present, the options longword is unused. It has not been decided yet whether
this will be a pointer to further options, or a bit map of further options.

Thus, for the time being, this longword can be ignored and even omitted
UNLESS the sprite also contains a pointer to a sprite block (see above), in
which case the options longword MUST EXIST (and, for the time being should be
set to 0).




IV - New WMAN colour format
=-=-=-=-=-=-=-=-=-=-=-=-=-=

Colours for the new WMAN are always given as one word. The word may
have any of the following formats:


	%00000000cccccccc	exactly as before
	%00000001pppppppp	palette
	%00000010pppppppp	system palette
	%00000011gggggggg	gray scale
	%00000100cc00tttd	3d border (border calls only!). see below
	%01ssxxxxxxyyyyyy	palette stipple. see below
	%1rrrrrgggggbbbbb	15 bit RGB


Stipple format
--------------
   s = stipple code (0 = dot, 1 = horizontal, 2 = vertical, 3 = checkers)
   x = stipple colour
   y = main colour

As x and y can only hold 6 bit only the first 64 entries of the palette can
be used for stippling.	Due to the design of the palette those entries
alone still cover the whole colour range quite well.

3d border format
----------------
   d = direction (0 = raised, 1 = lowered)
   t = type
   c = compatibility mode

To see what types are available have a look at the qlborders.gif file.

The compatibility modes are avaiable on some border types and they tell how
to sqeeze a non-standard border size into a QL border. Some modes paint areas
with the current paper colour, therefore it is a wise idea to always set the
paper colour before the border. The WMAN routines have already been changed
to take this into account.

In case of a non-standard border width another border call on this window
MUST be made through the WMAN routines instead of the standard border calls
(e.g. by calling wm.trap3). Otherwise the overall window size will be altered.

The colours to paint the border are defined in the system palette (sp.3ddark
and sp.3dlight). Future versions may shade the paper colour, therefore
it's again a good idea to set the paper colour before the border call.


V - System palette entries
=-=-=-=-=-=-=-=-=-=-=-=-=-


The keys for this are defined in the file dev8_keys_syspal.

Please note that you can configure SMSQ/E to set the palette(s) to your taste.

Name		Number	 Meaning
------------------------------------------------------------------------------
sp.winbd	$0200	 Window border
sp.winbg	$0201	 Window background
sp.winfg	$0202	 Window foreground
sp.winmg	$0203	 Window middleground
sp.titlebg	$0204	 Title background
sp.titletextbg	$0205	 Title text background
sp.titlefg	$0206	 Title foreground
sp.litemhigh	$0207	 Loose item highlight
sp.litemavabg	$0208	 Loose item available background
sp.litemavafg	$0209	 Loose item available foreground
sp.litemselbg	$020a	 Loose item selected background
sp.litemselfg	$020b	 Loose item selected foreground
sp.litemunabg	$020c	 Loose item unavailable background
sp.litemunafg	$020d	 Loose item unavailable foreground
sp.infwinbd	$020e	 Information window border
sp.infwinbg	$020f	 Information window background
sp.infwinfg	$0210	 Information window foreground
sp.infwinmg	$0211	 Information window middleground
sp.subinfbd	$0212	 Subsidiary information window border
sp.subinfbg	$0213	 Subsidiary information window background
sp.subinffg	$0214	 Subsidiary information window foreground
sp.subinfmg	$0215	 Subsidiary information window middleground
sp.appbd	$0216	 Application window border
sp.appbg	$0217	 Application window background
sp.appfg	$0218	 Application window foreground
sp.appmg	$0219	 Application window middleground
sp.appihigh	$021a	 Application window item highlight
sp.appiavabg	$021b	 Application window item available background
sp.appiavafg	$021c	 Application window item available foreground
sp.appiselbg	$021d	 Application window item selected background
sp.appiselfg	$021e	 Application window item selected foreground
sp.appiunabg	$021f	 Application window item unavailable background
sp.appiunafg	$0220	 Application window item unavailable foreground
sp.scrbar	$0221	 Pan/scroll bar
sp.scrbarsec	$0222	 Pan/scroll bar section (the section not coverd by the bar)
sp.scrbararr	$0223	 Pan/scroll bar arrow
sp.buthigh	$0224	 Button highlight
sp.butbd	$0225	 Button border
sp.butbg	$0226	 Button background
sp.butfg	$0227	 Button foreground
sp.hintbd	$0228	 Hint border
sp.hintbg	$0229	 Hint background
sp.hintfg	$022a	 Hint foreground
sp.hintmg	$022b	 Hint middleground
sp.errbg	$022c	 Error message background
sp.errfg	$022d	 Error message foreground
sp.errmg	$022e	 Error message middleground
sp.shaded	$022f	 Shaded area
sp.3ddark	$0230	 Dark 3D border shade
sp.3dlight	$0231	 Light 3D border shade
sp.vertfill	$0232	 Vertical area fill
sp.subtitbg	$0233	 Subtitle background
sp.subtittxtbg	$0234	 Subtitle text background
sp.subtitfg	$0235	 Subtitle foreground
sp.mindexbg	$0236	 Menu index background
sp.mindexfg	$0237	 Menu index foreground
sp.separator	$0238	 Seperator lines etc.

Some sort of design guide to help deciding what colour to use (or what some
colour is supposed to mean anyway) will hopefully be written at a later stage.



VI - New Basic Keywords
=-=-=-=-=-=-=-=-=-=-=-=

The Basic programmer has not been forgotten and there are a number of
keywords for palette and colour handling:

1 - Colours
-----------


The first of these are useful for colour handling. Their parameters are
excactly the same as for the "normal" commands. The same is true with their
names, except for the 'WM_" prefix:


WM_PAPER [#channel],colour

Sets the colour which is a word as described above. It also sets the strip
as is the case with the normal PAPER command. But there is also the
WM_STRIP [#channel],colour command to set the strip only.

Further commands are:


WM_INK [#channel],colour
WM_BORDER[#channel],width,colour
WM_BLOCK [#channel],xs,ys,xo,yo,colour


2 - Palette handling
--------------------

There are commands to set/get the system palette and commands to set/get
the per job palettes.


a - System palette keywords:


SP_RESET [#channel] [,number]

This resets the colour palette given in number to the original values (as
configured). Default is number 0.


result% = SP_GETCOUNT

Gets the number of elements contained in a system palette. Each system
palette, of course, has the same number of elements.


SP_GET [number,] address, first, count

This gets the colours from a system palette and puts them somewhere. The
optional "number" parameter tells us which system palette we want (0 to 3,
default = 0). "address" is the address of the space for the information,
"first" is the number of the first systemm palette colour to get (starting
from 0) and "count" is the number of colours to get.

The space pointed to by "address" MUST have enough space for the number of
colours! This is NOT checked by the keyword and it is the programmer's
responsibility to make sure that this is so.

As an example, you could use the following code to get ALL of the colours
of a system palette:

totcol%= SP_GETCOUNT	     : rem get nbr of colours in system palette
address= ALCHP(totcol%*2)+4  : rem enough space for colours + security
first=0
SP_GET #1,0,address,first,totcol%


SP_SET [#channel,] [number,] address, first, count

Sets the system palette entries, the addres pointing to a space contianing
the colours. The parameters are similar to those for SP_GET.



b - Job palette keywords

SP_JOBPAL [#channel], jobID/Job_name, number

Set the system palette for the job given to the number. The jobis given
either as a string (e.g. "FiFi") or as a standard Job ID number.


SP_JOBOWNPAL [#channel],jobID/Job_name, pal_pointer

Set the job palette to the palette given in pal_pointer. Of course, the
palette must have the format of a standard system palette.




VII - New Move modes
=-=-=-=-=-=-=-=-=-=-


As of version 3.01 of SMSQ/E, new ways of moving a window about the screen
have been added.

a - The move modes
------------------


There are now four ways for a window be moved:


0 - the old way: the pointer changes to the "move window" sprite which is
moved about the screen.

1 - "Outline": click on the move icon with the MOUSE - KEEP HOLDING THE BUTTON
DOWN, an outline of the window appears which you can move around and position
where you want it. Release the mouse button and the window positions itself
correctly.

Please note that you cannot use this move mode with anything but the mouse - the
keyboard (cursor keys) will not work.


2 - "Full window". This is the same as 1 above, but instead of an outline, the
entire window is moved. For Q40/Q60 users, switching onthe Cache is advisable...

Please note that you cannot use this move mode with anything but the mouse - the
keyboard (cursor keys) will not work.

  
3 - "Full window with tranparency" (implemented in SMSQ/E v. 3.16). This is the
same as 2 above, but the window to be moved is made "transparent" : one can
"see through" it.  This is done via "alpha blending". Alpha blending requires
A LOT of computing power. So, even if your machine can theoretically handle this
type of move, in practice it might not be feasible.
For Q40/Q60 users, switching on the Cache is advisable...

This type of move is only implemented for display modes where alpha blending
actually makes sense, i.e. modes 16, 32 and 33. In other display modes, such
as the QL screen modes, or Atari mono modes, this will be redirected to move
mode 2.

Please note that you cannot use this move mode with anything but the mouse - the
keyboard (cursor keys) will not work.

  
b - Configuring/setting the move mode
-------------------------------------

The move modes are configured on a system-wide basis - you cannot have one
job moving in mode 0 and the other in mode 1.

Thus, all jobs are affected by the move mode, even those written a long time
ago (unless, such as Qlib, the job doesn't use the WMAN move routine).

The move mode can be changed in two ways:

1 - Configure SMSQ/E  (WMAN) to a mode of your liking.

2 - Use the new WM_MOVEMODE keyword

This takes one parameter, an integer from 0 to 3:

WM_MOVEMODE 0 : the old way

WM_MOVEMODE 1 : the "outline" move

WM_MOVEMODE 2 : the "full window" move

WM_MOVEMODE 3 : the "full window with transparency" move


c - Configuring/setting the degree of transparency : WM_MOVEALPHA
------------------------------------------------------------------
You can set how transparent the window is supposed to be when being moved,
from nearly totally transparent to totally opaque. This is done by setting
the "alpha value", from 1 (nearly transparent) to 255 (totally opaque).

The alpha value is configured on a system-wide basis - you cannot have one
job moving with an alpha value of 100 and the other with 200.

Thus, all jobs are affected by this, even those written a long time
ago (unless, such as Qlib, the job doesn't use the WMAN move routine).

The alpha value can be changed in two ways:

1 - Configure SMSQ/E  (WMAN) to a value of your liking.

2 - Use the new WM_MOVEALPHA keyword
			   
WM_MOVEALPHA : this new keyword defines the amount of transparency the window
should have when moved about, from 1 (nearly transparent) to 255 (totally
opaque).

Please note that
1) no check is made on the value passed to this keyword, but only the lower
byte is used.
2) a value of 255 is actually equivalent to move mode 2.
3) a value of 0 is allowed but, since this would make the window to be moved
totally transparent when it is moved (i.e. you would only ever see the
background) this is considered to be an error and a value of 255 will be used!
4) alpha blending requires a lot of computing power - it may be too slow
on your machine.



VIII - Csizes for text objects in menu application sub-windows
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Application subwindow text objects may now have character sizes other than 0,0.
Of course, this only applies to programs specially written to take
advantage of these csizes.

The values for the csizes are stored in the working definition at previously
unused locations ($26 and $27).
The values are the same as those for the CSIZE command i.e. 0 to 3 for the
x csize and 0 or 1 for the y csize. Behaviour if other values are given is
undefined.

Note that the csizes are, of course, the same for all objects of a menu
application sub-window (but different appsubwdw may have different csizes).

How to use these:

1 - For the machine code programmer :

The values are stored at offsets

wwa_xcsz equ	$26
wwa_ycsz equ	$27

in the working definition, as byte-sized values.
The key files have been amended to suit.

You may also set these sizes in a menu appsub definition which will
be converted to a working definition by the standard setup vector. In that
case set the values BELOW the start of the normal defintion : at -4 of the
start, set a flag, i.e. a long word 'XTND' and at -6 set a word with the
x (-6) and y (-5) csizes values as bytes.
	  
DO NOT FORGET TO ADJUST THE SIZES OF YOUR OBJECTS' HITSIZE AND SPACING IF
YOU USE BIGGER CHARACTERS.
	  

2 - For the basic programmer.

Two procedures have been created for the two common toolkits, qptr and easyotr.

For qptr :
----------

def proc set_csizes_QPTR (appsub_list,num%,x_csize%,y_csize%)
rem set the csizes for menu appsub windows
rem params:
rem   appsub_list
rem	the appsub list as returned by the RD_AWTA basic function  and/or
rem	the MK_AWL extension
rem   num%
rem	the appsub number, starting at 1 for the first appsub wdw
rem   x_csize%
rem	 the x csize (0 ... 3), same as for the CSIZE command
rem   y_csize%
rem	 the y csize (0 or 1), same as for the CSIZE command
rem
rem   If there is any error in the parameters, this jusy gives up silently
rem   without generating an error
rem
local appsub_nbr%,appsub
  appsub_nbr%=peek_w(appsub_list)		: rem nbr of appsub wdws
  if appsub_nbr% < num% or num% < 1: return	: rem wrong appsub number
  appsub=peek_l(appsub_list+2+4*(num%-1))	: rem get poiner to appsub wdw
  if x_csize% > -1 and x_csize% < 4
      poke appsub+38,x_csize%			: rem set size
  endif
  if y_csize% > -1 and y_csize% < 2
      poke appsub+39,y_csize%			: rem set size
  endif
end def set_csizes_QPTR


Call this procedure once you have created the appsub list.

For easyptr:
------------

def proc set_csizes_EASYPTR (channel%,num%,x_csize%,y_csize%)
rem set the csizes for menu appsub windows
rem params:
rem   channel%
rem	the channel number, which must be the same one as used for MAWDRAW
rem	or MAWSETUP. THIS DOES NOT DEFAULT TO ANYTHING, you MUST
rem	supply this parameter correctly.
rem   num%
rem	the appsub number, starting at 1 for the first appsub wdw
rem   x_csize%
rem	 the x csize (0 ... 3), same as for the CSIZE command
rem   y_csize%
rem	 the y csize (0 or 1), same as for the CSIZE command
rem
rem   If there is any error in the parameters, this just gives up silently
rem   without generating an error
rem
local appsub_nbr%,appsub
  appsub= MWDEF(#channel%)			: rem the working definition
  appsub_nbr%=peek_w(appsub+110)		: rem nbr of appsub wdws
  if appsub_nbr% < num% or num% < 1: return	: rem wrong appsub number
  appsub=peek_l(appsub+112)			: rem point to appsub list
  appsub=peek_l(appsub+4*(num%-1))		: rem get poiner to appsub wdw
  if x_csize% > -1 and x_csize% < 4
      poke appsub+38,x_csize%			: rem set size
  endif
  if y_csize% > -1 and y_csize% < 2
      poke appsub+39,y_csize%			: rem set size
  endif
end def set_csizes_EASYPTR
:

For this to work, create your menu with the MAWSETUP command and
call this procedure afterwords.


You will find both procedures in a common file	:
dev8_extras_source_setcsizes_bas.


DO NOT FORGET TO ADJUST THE SIZES OF YOUR OBJECTS' HITSIZE AND SPACING IF
YOU USE BIGGER CHARACTERS.





IX - Using alpha blending
=-=-=-=-=-=-=-=-=-=-=-=-=

(introduced in version 3.26)

All graphics operations to the screen, including printing text, can be done
with alpha blending, where the object to be drawn, including a single pixel
or a text, will be blended in with the background.

To achieve this, set the alpha weight of a channel.  This determines how much
the object to be displayed is blended into the existing background.
An alpha weight of 0 means that the object to be drawn will be practically
totally translucent, i.e. it can't be seen since it lets the background shine
through entirely. An alpha weight of 255 means that the object to be displayed
is totally opaque, i.e. it covers the existing background.


There is a program called "dev8_extras_alpha_test_bas" which can show you how
this works (in SBasic).

IMPORTANT NOTE:

This call only really makes sense for 16 bit modes. In 8 bit Aurora mode, the
trap tries as well as it can, but don't expect miracles, there just aren't
enough colours.  When in QL modes 4 or 8, or in Atari monochrome mode, there
simply is no alpha blending (note that being in QL modes 4 or 8 is not the same
as having used COLOUR_QL in 16 or 8 bit mode).


	
A - Machine code:
-----------------


|									      |
|  Trap #3    D0=$62						   IOW.SALP   |
|									      |
|	Set the alpha blending weight for window			      |
|									      |
|  Call parameters			Return parameters		      |
|									      |
|  D1.B alpha weight (0..255)		D1   preserved			      |
|  D2					D2   preserved			      |
|  D3.W timeout 			D3   preserved			      |
|					D4+  all preserved		      |
|									      |
|  A0	channel ID			A0   preserved			      |
|  A1					A1   preserved			      |
|  A2					A2   preserved			      |
|  A3					A3   preserved			      |
|					A4+  all preserved		      |
|									      |
|  Error returns:							      |
|	 ICHN  channel not open 					      |

This call affects all following text and graphics output functions. To disable
alpha blending set the weight to 255.
			

B - For the SBasic programmer
-----------------------------

Use the ALPHA_BLEND command.

ALPHA_BLEND [#channel,] weight.

Sets the alpha weight for this channel. All further output to this channel will
use this. To switch it off, set weight to 255.

- channel s the channel to xhich thi applies, ss usual, it defaults to 1.

- weight is the alpha weight of future display operations: from 0 (translucent)
to 255 (opaque).
