10 REMark $$asmb=dev8_extras_source_outptr_bin,0,10
20 REMark $$asmb=dev1_booty_qptr_bin,50,172
30 REMark $$asmb=dev8_extras_source_SMSQEMake_bin,0,10
40 REMark $$stak=20000
50 rem compiled with the basic_linker
60 :
70 compiled=not is_open(#0)
80 if not compiled
90   check_for_PE
100   clear:clchp
110   scr_size#0,maxx%,maxy%
120   maxy%=maxy%-28
130   outln#0,maxx%,maxy%,0,28
140   wset -1
150 else
160   open#1,"con"
170   check_for_PE
180   scr_size#1,maxx%,maxy%
190 end if
200 :
210 init
220 main
230 stop
240 :
250 def proc check_for_PE
260   if p_env(#1)<>2
270     cls#1:ink#1,2:print#1,"This software works only in the pointer environment"
280     a$=inkey$(#1,-1)
290     stop
300   end if
310 end def check_for_PE
320 :
330 DEFine PROCedure init
340 LOCal temp%,targets%,start%,lp%,v$
350   text=0:sprite=2:blob=4:pattern=6
360   retr=256:retn=-256:sous1=254:sous2=252:sous3=250
370   rem normal: hit = selects/deselects, do = returns & leaves selected
380   rem retr = return even on hit, reset item to available after,
390   rem retn = return even on hit, hit selects/deselects, do selects
400 :
410   hit$=CHR$(1):do$=CHR$(2):cancel$=CHR$(3):sleep$=CHR$(7):wake$=CHR$(8)
420   help$=CHR$(4):move$=CHR$(5):size$=CHR$(6):cr$=CHR$(10)
430 :
440   make_standard_sprites
450   colourway%=SMSCFG(2)                  : rem use first syspals
460   if colourway%>3 or colourway%<0:colourway%=0
470   temp%=set_colours% (2)      : rem always try to set highest colours
480   make_my_palette colourway%  : rem set colours according to system palette
490 :
500 restore 500
510 :
520 : rem make loose item attributes
530 :
540   DIM std_iattr(3,3)
550   RD_IATT std_iattr
560     DATA 1,sp.litemhigh : rem current item border size & colour
570     DATA sp.litemunabg,sp.litemunafg,0,0 : rem unavailable item paper & ink
580     DATA sp.litemavabg,sp.litemavafg,0,0 : rem available     "    "       "
590     DATA sp.litemselbg,sp.litemselfg,0,0 : rem selected
600 :
610   targets%=0
620   rem IF NOT compiled:cmd$="-tj-tg-st-mk-as"
630   quit_always%=0
640   quit_no_errors%=0
650   autostart%=0
660   do_make_it%=0
670   force_assembly$=""
680   delete_first%=0
690   select_all%=0
700   autochangesize%=(SMSCFG(3)=="Yes")
710   IF cmd$<>''
720       IF '-qa' INSTR cmd$:quit_always%=1
730       IF '-q0' INSTR cmd$:quit_no_errors%=1
740       IF '-as' INSTR cmd$:autostart%=1
750       IF '-mk' INSTR cmd$:do_make_it%=1
760       IF '-de' INSTR cmd$:delete_first%=1
770       IF '-sa' INSTR cmd$:select_all%=1
780       IF '-tg' INSTR cmd$:targets%=targets%+1 : rem Generic
790       IF '-ti' INSTR cmd$:targets%=targets%+2 : rem Atari
800       IF '-to' INSTR cmd$:targets%=targets%+4 : rem gOld
810       IF '-tq' INSTR cmd$:targets%=targets%+8 : rem Q40
820       IF '-tx' INSTR cmd$:targets%=targets%+16 : rem qXl
830       IF '-tu' INSTR cmd$:targets%=targets%+32 : rem aUrora
840       IF '-tj' INSTR cmd$:targets%=targets%+64 : rem Java
850       IF '-tr' INSTR cmd$:targets%=targets%+128 : rem ptRgen
860       IF '-tc' INSTR cmd$:targets%=targets%+256 : rem qpC
870       IF '-t8' INSTR cmd$:targets%=targets%+512 : REMark q68
880       IF '-ta' INSTR cmd$:targets%=255+256+512    : rem all targets
890       IF '-fa' INSTR cmd$:force_assembly$=" -f": rem force assembly of all files
900   ELSE
910     targets%=1
920   END IF
930   make_my_data targets%
940   xsize%=500                                      : rem window x size divisible by 4!
950   ysize%=200                                      : rem provisional y size%
960   rows%=-1                                        : rem make rows dependent on wdw size
970   rep$=SMSCFG(1)                        : rem dir with files
980   make_main_wdw
990   IF (select_all%):main_lfl%(all_it%)=129:set_statusses
1000   start%=1
1010   FOR lp%=target_its% TO target_its%+9
1020     IF targets% && start%: main_lfl%(lp%)=129
1030     start%=start%*2
1040   END FOR lp%
1050   IF do_make_it%:main_lfl%(make_it%)=129
1060   IF delete_first%:main_lfl%(del_it%)=129
1070 :
1080   warn_make
1090   v$=smscfg(0)
1100   about_make "SMSQEMake",v$
1110 :
1120 END DEFine init
1130 :
1140 define procedure main
1150 local lp%,item%,event%,swnum%,xrel%,yrel%,item%,lp2%,tot%,errors%
1160   if compiled
1170      dr_ppos main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
1180   else
1190      dr_puld main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
1200   end if
1210   pos_ptr main_defn,40*65536+20,1
1220   if autostart%
1230      errors%=do_the_work%
1240      if quit_always%:stop
1250      if quit_no_errors% and not errors%:stop
1260      if errors%
1270           errors%=warning%("There were errors"&chr$(10)&"check the highlit items",0,"errors!")
1280      endif
1290   endif
1300   repeat lp%
1310     rd_ptr main_defn,item%,swnum%,event%,xrel%,yrel%,main_lfl%,main_mfl%,main_cty%
1320     if swnum%= -1
1330       select on item%
1340             =esc%     : exit lp%                            : remark quit prog
1350             =move_it% : ch_win main_defn                    : remark move
1360             =size_it% : change_size xrel%,yrel%   : remark change size
1370             =sleep_it%: button main_defn,main_lfl%,main_mfl%,main_cty%,"SMSQ/E Make"
1380             =all_it%  : set_statusses             : remark set all appsub item statusses
1390                           main_cty%(0,1)=1                  : remark and redraw
1400             =go_it%   : errors%=do_the_work%
1410                           if errors%
1420                                errors%=warning%("There were errors"&chr$(10)&"check the highlit items",0,"errors!")
1430                           endif
1440                           main_lfl%(del_it%)=1
1450             =dir_it%  : make_new_dir item%
1460             =target_its% to make_it%-1,alltargets_it%
1470                           if item%=alltargets_it%
1480                                machines%=-1
1490                                for lp2%= target_its% to make_it%-1
1500                                   main_lfl%(lp2%)=129
1510                                end for lp2%
1520                            else
1530                               start%=1:machines%=0
1540                               for lp2%=target_its% to make_it%-1
1550                                   if main_lfl%(lp2%):machines%=machines%+start%
1560                                   start%=start%*2
1570                               end for lp2%
1580                           endif
1590                           make_my_data machines%  : remark make data arrays
1600                           if autochangesize%
1610                               autochange_size xrel%,yrel%
1620                           else
1630                               app_addr=mk_main_app(app_addr,mdata$,0,0,1,0,0,0) : rem make apsub wdw
1640                               main_app_list=app_addr+180
1650                               ap_in main_defn,main_app_list : remark put it in
1660                               dr_wdrw main_defn:main_cty%(0,1)=1 : remark and redraw entire wdw
1670                           end if
1680             =info_it% : about "2013-2017"
1690       end select
1700     end if
1710   end repeat lp%
1720   dr_unst main_defn
1730   if compiled:close#1
1740   rechp espace_vide
1750 end define main
1760 :
1770 DEFine FuNction do_the_work%
1780 REMark this tries to compile all of the selected files
1790 REMark if the file was compiled OK, status (of the link file) set to available
1800 REMark if the file was not compiled ok, status left selected
1810 LOCal lp%,bound%,a$,my_error%,tot_err%
1820   bound%=DIMN(main_mfl%,1)              : REMark number of items to check
1830   tot_err%=0
1840   IF main_lfl%(del_it%)<>0
1850      EW "dev8_extras_del_all_bas";"auto stop"
1860   END IF
1870   FOR lp%=0 TO bound%
1880     a$=mdata$(lp%+1)                              : REMark potential file to compile
1890     IF a$(1)<>"*" AND main_mfl%(lp%,0)
1900        a$=rep$&a$                       : REMark add dir
1910        my_error%=compile_and_check% (a$): REMark try to compile
1920        IF NOT my_error%
1930              main_mfl%(lp%,0)=1
1940              DR_ADRW main_defn,0,main_mfl%,main_cty%
1950        END IF
1960        tot_err%=tot_err%+my_error%
1970     END IF
1980   END FOR lp%
1990   main_cty%(0,1)=1
2000   main_lfl%(go_it%)=1
2010   IF main_lfl%(make_it%)=128 AND NOT tot_err%:make_targets
2020   RETurn tot_err%
2030 END DEFine do_the_work%
2040 :
2050 DEFine FuNction compile_and_check% (a$)
2060 REMark this tries to compile a file, using the "make" prog
2070 REMark this returns 1 if errors, else 0
2080 LOCal chan%,is_ok$,ch_len
2090   ch_len=EXEPF_W ("make";a$&" -w -l"&force_assembly$)                   : REMark exec make & wait
2100   IF ch_len<>0
2110      EXEC_W "make";a$&" -w -l"&force_assembly$                 : REMark exec make & wait
2120   END IF
2130   is_ok$=a$(1 TO LEN(a$)-4)             : REMark file name w/o extension
2140   chan%=FOP_IN(is_ok$&'log')            : REMark open log file
2150   IF chan%<0:RETurn 1                             : REMark can't even open it!
2160   ch_len=FLEN(#chan%)                             : REMark file length
2170   GET#chan%\ch_len-10                             : REMark this is where error report is
2180   INPUT#chan%,is_ok$                              : REMark get it
2190   CLOSE#chan%
2200   IF NOT is_ok$=="No errors"
2210     RETurn 1                                      : REMark anything other than "no errors" signals errors
2220   ELSE
2230     RETurn 0
2240   END IF
2250 END DEFine compile_and_check%
2260 :
2270 DEFine PROCedure make_new_dir (poste%)
2280 REMark get athe new dir where the files are located
2290 LOCal quel_rep$
2300   IF MENU_OK
2310     quel_rep$= DIR_SELECT$("The Files are where?",,10,10,main_coul%,app_coul%)
2320   ELSE
2330     quel_rep$=getstr$(poste%,0,main_defn,a_lire$)           : REMark use menu extns if possible
2340   END IF
2350   IF LEN (quel_rep$) >= 5
2360      rep$=quel_rep$(1 TO 5)
2370   END IF
2380   CH_ITEM main_defn,-1,poste%,-1,"",rep$
2390   main_lfl%(poste%)=main_lfl%(poste%)+1
2400 END DEFine make_new_dir
2410 :
2420 DEFine PROCedure make_my_data (what_machine%)
2430 REMark what_machine% = 1 -> generic
2440 REMark what_machine% = 2 -> atari
2450 REMark what_machine% = 4 -> Gold Card
2460 REMark what_machine% = 8 -> Qx0
2470 REMark what_machine% = 16 -> QXL
2480 REMark what_machine% = 32 -> aurora
2490 REMark what_machine% = 64 -> java
2500 REMark what_machine% = 128 -> ptrgen
2510 REMark what_machine% = 256 -> qpc
2520 REMark what_machine% = 512 -> q68
2530 REMark these may be combined
2540   DIM mdata$(250,50)
2550   REMark first make generic data
2560   data_count%=1                         : REMark general data count (global var)
2570   IF what_machine%&&1
2580     generic_data                        : REMark set up generic data
2590     read_my_datas                       : REMark and read it
2600   END IF
2610   IF what_machine%&&2
2620      atari_data                         : REMark set up machine specific data....
2630      read_my_datas                      : REMark and read it
2640   END IF
2650   IF what_machine%&&4
2660      gc_data                                      : REMark set up machine specific data....
2670      read_my_datas                      : REMark and read it
2680   END IF
2690   IF what_machine%&&8
2700      q40_data                                     : REMark set up machine specific data....
2710      read_my_datas                      : REMark and read it
2720   END IF
2730   IF what_machine%&&16
2740      qxl_data                                     : REMark set up machine specific data....
2750      read_my_datas                      : REMark and read it
2760   END IF
2770   IF what_machine%&&32
2780      aurora_data                        : REMark set up machine specific data....
2790      read_my_datas                      : REMark and read it
2800   END IF
2810   IF what_machine%&&64
2820      java_data                                    : REMark set up machine specific data....
2830      read_my_datas                      : REMark and read it
2840   END IF
2850   IF what_machine%&&128
2860      ptrgen_data                        : REMark set up machine specific data....
2870      read_my_datas                      : REMark and read it
2880   END IF
2890   IF what_machine%&&256
2900      qpc_data                                     : REMark set up machine specific data....
2910      read_my_datas                      : REMark and read it
2920   END IF
2930   IF what_machine%&&512
2940      q68_data                                     : REMark set up machine specific data....
2950      read_my_datas                      : REMark and read it
2960   END IF
2970 END DEFine make_my_data
2980 :
2990 DEFine PROCedure read_my_datas
3000 REMark reads datas into the global var mdata$
3010 REMark uses data_count% from make_my_data
3020 LOCal lp%
3030   REPeat lp%
3040     READ mdata$(data_count%)
3050     IF mdata$(data_count%)="":EXIT lp%
3060     data_count%=data_count%+1
3070   END REPeat lp%
3080 END DEFine read_my_datas
3090 :
3100 DEFine PROCedure generic_data
3110 restore 3110
3120   DATA '**** -- SMSQ Generic -- ****'
3130   DATA 'smsq_smsq_loader_link'
3140   DATA 'smsq_smsq_fh_link'
3150   DATA 'smsq_smsq_link'
3160   DATA 'smsq_smsq_cache_link'
3170   DATA 'smsq_sbas_link'
3180   DATA 'smsq_smsq_lang_link'
3190   DATA 'smsq_sbas_lang_link'
3200   DATA 'smsq_sbas_procs_link'
3210   DATA 'smsq_smsq_wman_link'
3220   DATA 'smsq_smsq_hotkey_link'
3230   DATA 'smsq_smsq_vers_link'
3240   DATA 'smsq_home_link'
3250   DATA 'smsq_recent_link'
3260   DATA 'smsq_smsq_1mb_link',''
3270 END DEFine generic_data
3280 :
3290 DEFine PROCedure q40_data
3300 restore 3300
3310   DATA '**** -- Q40/Q60 -- ****'
3320   DATA 'smsq_q40_hwinit_link'
3330   DATA 'smsq_q40_nasty_link'
3340   DATA 'smsq_q40_cache_link'
3350   DATA 'smsq_q40_cachemode_link'
3360   DATA 'smsq_smsq_cache40c_link'
3370   DATA 'smsq_q40_driver_ser_link'
3380   DATA 'smsq_q40_driver_dv3_link'
3390   DATA 'smsq_q40_driver_ql_link'
3400   DATA 'smsq_q40_driver_16_link'
3410   DATA 'smsq_q40_kbd_lang_link'
3420   DATA 'smsq_q40_sysspr_link',''
3430 END DEFine q40_data
3440 :
3450 DEFine PROCedure atari_data
3460 restore 3460
3470   DATA '**** -- Atari -- ****'
3480   DATA 'smsq_atari_hwinit_link'
3490   DATA 'smsq_atari_nasty_link'
3500   DATA 'smsq_atari_driver_ql_link'
3510   DATA 'smsq_atari_driver_mo_link'
3520   DATA 'smsq_atari_driver_ser_link'
3530   DATA 'smsq_atari_driver_dv3_link'
3540   DATA 'smsq_atari_kbd_lang_link'
3550   DATA 'smsq_atari_sysspr_link'
3560   DATA 'sys_boot_st_host_link',''
3570 END DEFine atari_data
3580 :
3590 DEFine PROCedure gc_data
3600 restore 3600
3610   DATA '**** -- (Super)GoldCard -- ****'
3620   DATA 'smsq_gold_host_link'
3630   DATA 'smsq_gold_hwinit_link'
3640   DATA 'smsq_gold_nasty_link'
3650   DATA 'smsq_gold_nasty_s_link'
3660   DATA 'smsq_gold_driver_ql_link'
3670   DATA 'smsq_gold_driver_8_link'
3680   DATA 'smsq_gold_driver_most_link'
3690   DATA 'smsq_gold_driver_nd_link'
3700   DATA 'smsq_gold_driver_nds_link'
3710   DATA 'smsq_gold_driver_dv3_link'
3720   DATA 'smsq_gold_kbd_lang_link'
3730   DATA 'smsq_gold_kbd_abc_lng_link'
3740   DATA 'smsq_gold_kbd_abc_link'
3750   DATA 'smsq_gold_roms_link'
3760   DATA 'smsq_gold_qimi_link'
3770   DATA 'smsq_gold_sysspr_link',''
3780 END DEFine gc_data
3790 :
3800 DEFine PROCedure aurora_data
3810 restore 3810
3820   DATA '**** -- Aurora -- ****'
3830   DATA 'smsq_gold_host_link'
3840   DATA 'smsq_gold_hwinit_link'
3850   DATA 'smsq_gold_nasty_link'
3860   DATA 'smsq_gold_nasty_s_link'
3870   DATA 'smsq_aurora_driver_8_link'
3880   DATA 'smsq_gold_driver_ql_link'
3890   DATA 'smsq_gold_driver_most_link'
3900   DATA 'smsq_gold_driver_nd_link'
3910   DATA 'smsq_gold_driver_nds_link'
3920   DATA 'smsq_gold_driver_dv3_link'
3930   DATA 'smsq_gold_kbd_lang_link'
3940   DATA 'smsq_gold_kbd_abc_lng_link'
3950   DATA 'smsq_gold_kbd_abc_link'
3960   DATA 'smsq_gold_roms_link'
3970   DATA 'smsq_gold_qimi_link'
3980   DATA 'smsq_aurora_sysspr_link'
3990   DATA 'smsq_gold_sysspr_link',''
4000 END DEFine aurora_data
4010 :
4020 DEFine PROCedure qxl_data
4030 restore 4030
4040   DATA '**** -- QXL -- ****'
4050   DATA 'smsq_qxl_host_link'
4060   DATA 'smsq_qxl_hwinit_link'
4070   DATA 'smsq_qxl_nasty_e_link'
4080   DATA 'smsq_qxl_driver_ql_link'
4090   DATA 'smsq_qxl_driver_16_link'
4100   DATA 'smsq_qxl_driver_most_link'
4110   DATA 'smsq_qxl_driver_nd_link'
4120   DATA 'smsq_qxl_procs_link'
4130   DATA 'smsq_qxl_driver_dv3e_link'
4140   DATA 'smsq_qxl_kbd_lang_link'
4150   DATA 'smsq_qxl_ecache_link'
4160   DATA 'smsq_qxl_sysspr_link',''
4170 END DEFine qxl_data
4180 :
4190 DEFine PROCedure java_data
4200 restore 4200
4210   DATA '**** -- Java -- ****'
4220   DATA 'smsq_java_host_link'
4230   DATA 'smsq_java_smsq_link'
4240   DATA 'smsq_java_smsq_1mb_link'
4250   DATA 'smsq_java_hwinit_link'
4260   DATA 'smsq_java_driver_ql_link'
4270   DATA 'smsq_java_driver_8_link'
4280   DATA 'smsq_java_driver_16_link'
4290   DATA 'smsq_java_driver_most_link'
4300   DATA 'smsq_java_driver_dv3e_link'
4310   DATA 'smsq_java_ip_link'
4320   DATA 'smsq_gold_kbd_lang_link'
4330   DATA 'smsq_java_sysspr_link',''
4340 END DEFine java_data
4350 :
4360 DEFine PROCedure qpc_data
4370 restore 4370
4380   DATA "**** -- QPC -- ****"
4390   DATA 'smsq_qpc_host_link'
4400   DATA 'smsq_qpc_hwinit_link'
4410   DATA 'smsq_qpc_nasty_e_link'
4420   DATA 'smsq_qpc_driver_ql_link'
4430   DATA 'smsq_qpc_driver_16_link'
4440   DATA 'smsq_qpc_driver_8_link'
4450   DATA 'smsq_qpc_driver_ql_link'
4460   DATA 'smsq_qpc_driver_most_link'
4470   DATA 'smsq_qpc_procs_link'
4480   DATA 'smsq_qpc_driver_dv3e_link'
4490   DATA 'smsq_qpc_kbd_lang_link'
4500   DATA 'smsq_qpc_dos_link'
4510   DATA 'smsq_qpc_ip_link'
4520   DATA 'smsq_qpc_cdaudio_link'
4530   DATA 'smsq_smsq_qpc_link'
4540   DATA 'smsq_qpc_sysspr_link',''
4550 END DEFine qpc_data
4560 :
4570 DEFine PROCedure ptrgen_data
4580 restore 4580
4590   DATA "**** -- PtrGen -- ****"
4600   DATA "ee_wman_link","ee_ptr_link","ee_hot_german_link","ee_hot_french_link"
4610   DATA "ee_hot_english_link",""
4620 END DEFine ptrgen_data
4630 :
4640 DEFine PROCedure q68_data
4650 restore 4650
4660   DATA '**** -- Q68 -- ****'
4670   DATA 'smsq_q68_sbas_procs_link'
4680   DATA 'smsq_q68_hwinit_link'
4690   DATA 'smsq_q68_nasty_link'
4700   DATA 'smsq_q68_driver_dv3_link'
4710   DATA 'smsq_q68_driver_most_link'
4720   DATA 'smsq_q68_driver_ql_link'
4730   DATA 'smsq_q68_driver_16_link'
4740   DATA 'smsq_q68_driver_8_link'
4750   DATA 'smsq_q68_driver_nd_link'
4760   DATA 'smsq_q68_kbd_lang_link'
4770   DATA 'smsq_smsq_q68_link'
4780   DATA 'smsq_q40_sysspr_link',''
4790 END DEFine q68_data
4800 :
4810 DEFine PROCedure make_targets
4820 REMark targets are only made if there was no error during compilation
4830 REMark to achieve this, a primitive approach is used:
4840 REMark a check is made whether an appsub menu item status is still selected
4850 REMark if it is, then the
4860   LOCal lp%,current_target%,tot_targets%
4870   tot_targets%=0                        : REMark no targets to make yet
4880   current_target%=0                               : REMark and no target yet
4890   FOR lp%=0 TO data_count%-2
4900     IF main_mfl%(lp%,0)=16
4910       REMark we're covering a new target
4920       tot_targets%=tot_targets%+current_target% : REMark show old target
4930       current_target%=find_target%(lp%+1) : REMark get new target we're covering
4940     ELSE
4950       IF main_mfl%(lp%,0)<>0:current_target%=0
4960     END IF
4970   END FOR lp%
4980   tot_targets%=tot_targets%+current_target%
4990   REMark at the end, here, tot_targets holds a bitmap
5000   REMark of targets for which compilation was ok
5010   IF (machines%&&1) AND NOT (tot_targets% && 1):RETurn : REMark generic was asked for but not compiled correctly!
5020   IF tot_targets%&&2:atari_target
5030   IF tot_targets%&&4:gc_target
5040   IF tot_targets%&&8:qx0_target
5050   IF tot_targets%&&16:qxl_target
5060   IF tot_targets%&&32:aurora_target
5070   IF tot_targets%&&64:java_target
5080   REMark IF tot_targets%&&128:ptr_gen_target  : rem no need for this
5090   IF tot_targets%&&256:qpc_target
5100   IF tot_targets%&&512:q68_target
5110 END DEFine make_targets
5120 :
5130 DEFine PROCedure atari_target
5140   cmdl$='m'
5150   p$=rep$&'sys_boot_st_flp'
5160   f$=rep$&'sys_boot_file'
5170   ah$=rep$&'sys_boot_st_host'
5180   ld$=rep$&'smsq_smsq_loader'
5190   hi$=rep$&'smsq_atari_hwinit'
5200   os1f$=rep$&'smsq_smsq_fh_os'
5210   os1$=rep$&'smsq_smsq_os'
5220   ca$=rep$&'smsq_smsq_cache'
5230   os2$=rep$&'smsq_sbas_control'
5240   ns1$=rep$&'smsq_atari_nasty'
5250   ln1$=rep$&'smsq_smsq_lang'
5260   ln2$=rep$&'smsq_atari_kbd_lang'
5270   ln3$=rep$&'smsq_sbas_lang'
5280   ex1$=rep$&'smsq_sbas_procs_x'
5290   ex2$=rep$&'smsq_atari_driver_dv3'
5300   ex3$=rep$&'smsq_atari_driver_ser'
5310   ex4$=rep$&'smsq_atari_driver_mono'
5320   ex5$=rep$&'smsq_atari_driver_ql'
5330   ex6$=rep$&'smsq_smsq_wman'
5340   ex7$=rep$&'smsq_smsq_hotkey'
5350   ex8$=rep$&'smsq_atari_sysspr'
5360   ex9$=rep$&'smsq_home_home'
5370   ex10$=rep$&'smsq_recent_recent'
5380   nl$=rep$&'sys_boot_null'
5390   IF 'm' INSTR cmdl$ = 0: ex4$ = nl$
5400   EW f$, ah$,ld$,hi$,os1f$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$, ex10$,rep$&'smsq_atari_SMSQ.PRG'
5410 END DEFine atari_target
5420 :
5430 DEFine PROCedure gc_target
5440 REMark there are  2 targets for the Goldcard!
5450   f$=rep$&'sys_boot_file'
5460   v$=rep$&'smsq_smsq_vers'
5470   h$=rep$&'smsq_gold_host'
5480   ld$=rep$&'smsq_smsq_loader'
5490   hi$=rep$&'smsq_gold_hwinit'
5500   os1$=rep$&'smsq_smsq_os'
5510   ca$=rep$&'smsq_smsq_cache'
5520   os2$=rep$&'smsq_sbas_control'
5530   ns1$=rep$&'smsq_gold_nasty'
5540   ns2$=rep$&'smsq_gold_nasty_s'
5550   ln1$=rep$&'smsq_smsq_lang'
5560   ln2$=rep$&'smsq_gold_kbd_lang'
5570   ln2a$=rep$&'smsq_gold_kbd_abc_lang'
5580   ln3$=rep$&'smsq_sbas_lang'
5590   ex1$=rep$&'smsq_sbas_procs_x'   : REMark this must be after "roms"
5600   ex2a$=rep$&'smsq_gold_kbd_abc'
5610   ex2$=rep$&'smsq_gold_driver_most'
5620   ex3a$=rep$&'smsq_gold_driver_ql'
5630   ex38$=rep$&'smsq_gold_driver_8'
5640   ex3q$=rep$&'smsq_gold_qimi'
5650   ex3w$=rep$&'smsq_smsq_wman'
5660   ex4$=rep$&'smsq_gold_driver_dv3'
5670   ex5$=rep$&'smsq_gold_driver_nd'
5680   ex6$=rep$&'smsq_gold_driver_nds'
5690   ex7$=rep$&'smsq_smsq_hotkey'
5700   ex8$=rep$&'smsq_gold_sysspr'
5710   ex9$=rep$&'smsq_home_home'
5720   ex10$=rep$&'smsq_gold_roms'
5730   ex11$=rep$&'smsq_recent_recent'
5740   nl$=rep$&'sys_boot_null'
5750   EW f$, v$,h$,ld$,hi$,os1$,ca$,os2$,ns1$,ns2$,ln1$,ln2$,ln2a$,ln3$,ex2a$,ex2$,ex3a$,ex3q$,ex3w$,ex4$,ex5$,ex6$,ex7$,ex8$,ex1$,ex9$,ex10$, ex11$,rep$&'SMSQ_GOLD_gold'
5760   EW f$, v$,h$,ld$,hi$,os1$,ca$,os2$,ns1$,ns2$,ln1$,ln2$,ln2a$,ln3$,ex2a$,ex2$,ex38$,ex3q$,ex3w$,ex4$,ex5$,ex6$,ex7$,ex8$,ex1$,ex9$,ex10$, ex11$,rep$&'SMSQ_GOLD_gold8'
5770 END DEFine gc_target
5780 :
5790 DEFine PROCedure aurora_target
5800   f$=rep$&'sys_boot_file'
5810   v$=rep$&'smsq_smsq_vers'
5820   h$=rep$&'smsq_gold_host'
5830   ld$=rep$&'smsq_smsq_loader'
5840   hi$=rep$&'smsq_gold_hwinit'
5850   os1$=rep$&'smsq_smsq_os'
5860   ca$=rep$&'smsq_smsq_cache'
5870   os2$=rep$&'smsq_sbas_control'
5880   ns1$=rep$&'smsq_gold_nasty'
5890   ns2$=rep$&'smsq_gold_nasty_s'
5900   ln1$=rep$&'smsq_smsq_lang'
5910   ln2$=rep$&'smsq_gold_kbd_lang'
5920   ln2a$=rep$&'smsq_gold_kbd_abc_lang'
5930   ln3$=rep$&'smsq_sbas_lang'
5940   ex1$=rep$&'smsq_sbas_procs_x'   : REMark this must be after "roms"
5950   ex2a$=rep$&'smsq_gold_kbd_abc'
5960   ex2$=rep$&'smsq_gold_driver_most'
5970   ex3a$=rep$&'smsq_gold_driver_ql'
5980   ex3b$=rep$&'smsq_aurora_driver_8'
5990   ex3q$=rep$&'smsq_gold_qimi'
6000   ex3w$=rep$&'smsq_smsq_wman'
6010   ex3sq$=rep$&'smsq_aurora_sysspr'
6020   ex3sh$=rep$&'smsq_gold_sysspr'
6030   ex4$=rep$&'smsq_gold_driver_dv3'
6040   ex5$=rep$&'smsq_gold_driver_nd'
6050   ex6$=rep$&'smsq_gold_driver_nds'
6060   ex8$=rep$&"smsq_home_home"
6070   ex9$=rep$&'smsq_smsq_hotkey'
6080   ex10$=rep$&'smsq_gold_roms'
6090   ex11$=rep$&'smsq_recent_recent'
6100   nl$=rep$&'sys_boot_null'
6110   EW f$, v$,h$,ld$,hi$,os1$,ca$,os2$,ns1$,ns2$,ln1$,ln2$,ln2a$,ln3$,ex2a$,ex2$,ex3a$,ex3b$,ex3q$,ex3w$,ex3sh$,ex4$,ex5$,ex6$,ex9$,ex10$,ex8$,ex1$,ex11$, rep$&'SMSQ_Aurora_SMSQE'
6120 END DEFine aurora_target
6130 :
6140 DEFine PROCedure qx0_target
6150   nl$=rep$&'sys_boot_null'
6160   f$=rep$&'sys_boot_file'
6170   qr$=rep$&'sys_boot_q40_rom'
6180   ld$=rep$&'smsq_smsq_loader'
6190   hi$=rep$&'smsq_q40_hwinit'
6200   os1$=rep$&'smsq_smsq_1mb_os' : REMark change for fast memory
6210   ca$=rep$&'smsq_smsq_cache40c'
6220   caq$=rep$&'smsq_q40_cache'
6230   caq4$=rep$&'smsq_q40_cachemode'
6240   os2$=rep$&'smsq_sbas_control'
6250   ns2$=rep$&'smsq_q40_nasty'
6260   ln1$=rep$&'smsq_smsq_lang'
6270   ln2$=rep$&'smsq_q40_kbd_lang'
6280   ln3$=rep$&'smsq_sbas_lang'
6290   ex1$=rep$&'smsq_sbas_procs_x'
6300   ex2$=rep$&'smsq_q40_driver_dv3'
6310   ex3$=rep$&'smsq_q40_driver_ser'
6320   ex4a$=rep$&'smsq_q40_driver_ql'
6330   ex4b$=rep$&'smsq_q40_driver_16'
6340   ex4w$=rep$&'smsq_smsq_wman'
6350   ex5$=rep$&'smsq_q40_sysspr'
6360   ex9$=rep$&'smsq_smsq_hotkey'
6370   ex10$=rep$&'smsq_home_home'
6380   ex11$=rep$&'smsq_recent_recent'
6390   EW f$, qr$,ld$,hi$,os1$,ca$,caq$,os2$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex4a$,ex4b$,ex4w$,ex5$,ex9$,ex10$,ex11$,ns2$,caq4$, rep$&'smsq_q40_rom'
6400 END DEFine qx0_target
6410 :
6420 DEFine PROCedure qxl_target
6430   IF FOP_IN (rep$&'smsq_qxl_qxlh.exe') <> -7: PRINT 'QXLH.EXE exists'; cmd$: QUIT
6440   p$   = rep$&'sys_boot_file'
6450   bl$  = rep$&'smsq_qxl_qxl2_exe'
6460   hst$ = rep$&'smsq_qxl_host'
6470   hi$  = rep$&'smsq_qxl_hwinit'
6480   ld$  = rep$&'smsq_smsq_loader'
6490   os1$ = rep$&'smsq_smsq_os'
6500   ca$  = rep$&'smsq_smsq_cache'
6510   os2$ = rep$&'smsq_sbas_control'
6520   ns1$ = rep$&'smsq_qxl_nasty_e'
6530   ln1$ = rep$&'smsq_smsq_lang'
6540   ln2$ = rep$&'smsq_qxl_kbd_lang'
6550   ln3$ = rep$&'smsq_sbas_lang'
6560   ex1$ = rep$&'smsq_qxl_procs_x'
6570   ex2$ = rep$&'smsq_qxl_driver_most'  : REMark Keyboard before CON
6580   ex3$ = rep$&'smsq_qxl_driver_ql'
6590   ex3b$ = rep$&'smsq_qxl_driver_16'
6600   ex3w$ = rep$&'smsq_smsq_wman'
6610   ex4$ = rep$&'smsq_qxl_driver_nd'
6620   ex5$ = rep$&'smsq_qxl_driver_dv3e'
6630   ex6$ = rep$&'smsq_smsq_hotkey'
6640   ex7$ = rep$&'smsq_qxl_sysspr'
6650   ex8$ = rep$&'smsq_home_home'
6660   ex10$= rep$&'smsq_recent_recent'
6670   last$ = rep$&'smsq_qxl_ecache'
6680   dml$ = rep$&'smsq_qxl_dummy'
6690   qm$  = rep$&'qmon_qxl_bin'
6700   r$='ram1_smsqe.exe' : f$=rep$&'smsq_qxl_smsqe.exe'
6710   cct$=rep$&"extras_exe_cct"
6720   DELETE f$
6730   EW p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3w$,ex4$,ex5$,ex6$,ex7$,ex8$,ex11$,last$, r$
6740   EW cct$, bl$,r$, f$
6750   DELETE r$
6760   OPEN #4,f$
6770   lenf=FLEN(#4)
6780   lens% = INT ((lenf+511)/512)
6790   lenb% = lenf - lens% * 512
6800   IF lenb%: lenb% = lenb% + 512
6810   BPUT #4\2, lenb% MOD 256, lenb% DIV 256, lens% MOD 256, lens% DIV 256
6820   CLOSE #4
6830 END DEFine qxl_target
6840 :
6850 DEFine PROCedure java_target
6860   f$=rep$&'sys_boot_file'
6870   v$=rep$&'smsq_smsq_vers'
6880   h$=rep$&'smsq_java_host'
6890   ld$=rep$&'smsq_smsq_loader'
6900   hi$=rep$&'smsq_java_hwinit'
6910   os1$=rep$&'smsq_java_smsq_os'
6920   os3$=rep$&'smsq_java_smsq_1mb_os'     : REMark must be after os
6930   ca$=rep$&'smsq_smsq_cache'
6940   os2$=rep$&'smsq_sbas_control'
6950   ln1$=rep$&'smsq_smsq_lang'
6960   ln2$=rep$&'smsq_gold_kbd_lang'
6970   ln3$=rep$&'smsq_sbas_lang'
6980   sb$=rep$&'smsq_sbas_procs_x'                    : REMark this must be after "roms"
6990   dr1$=rep$&'smsq_java_driver_most'
7000   dr2$=rep$&'smsq_java_driver_ql'
7010   dr3$=rep$&'smsq_java_driver_8'
7020   dr4$=rep$&'smsq_java_driver_16'
7030   dr5$=rep$&'smsq_smsq_wman'
7040   dr6$=rep$&'smsq_java_driver_dv3e'
7050 rem  dr7$=rep$&'smsq_java_driver_qsd_qsd'
7060   hk$=rep$&'smsq_smsq_hotkey'
7070   sp$=rep$&'smsq_java_sysspr'
7080   hm$=rep$&'smsq_home_home'
7090   ip$=rep$&'smsq_java_ip_x'
7100   re$=rep$&'smsq_recent_recent'
7110   EW f$,h$,ld$,hi$,os1$,os3$,ca$,os2$,ln1$,ln2$,ln3$,sb$,dr1$,dr2$,dr3$,dr4$,dr5$,dr6$,hk$,sp$,hm$,ip$,re$, rep$&'SMSQ_java_java'
7120 END DEFine java_target
7130 :
7140 DEFine PROCedure qpc_target
7150   p$   = rep$&'sys_boot_file'
7160   hst$ = rep$&'smsq_qpc_host'
7170   hi$  = rep$&'smsq_qpc_hwinit'
7180   ld$  = rep$&'smsq_smsq_loader'
7190   os1$ = rep$&'smsq_smsq_qpc_os'
7200   ca$  = rep$&'smsq_smsq_cache'
7210   os2$ = rep$&'smsq_sbas_control'
7220   ns1$ = rep$&'smsq_qpc_nasty_e'
7230   ln1$ = rep$&'smsq_smsq_lang'
7240   ln2$ = rep$&'smsq_qpc_kbd_lang'
7250   ln3$ = rep$&'smsq_sbas_lang'
7260   ex1$ = rep$&'smsq_sbas_procs_x'
7270   ex2$ = rep$&'smsq_qpc_driver_most'  : REMark Keyboard before CON
7280   ex3$ = rep$&'smsq_qpc_driver_ql'
7290   ex3b$= rep$&'smsq_qpc_driver_16'
7300   ex3c$= rep$&'smsq_qpc_driver_8'
7310   ex3w$= rep$&'smsq_smsq_wman'
7320   ex3s$= rep$&'smsq_qpc_sysspr'
7330   ex4$ = rep$&'smsq_qpc_driver_dv3e'
7340   ex5$ = rep$&'smsq_smsq_hotkey'
7350   ex6$ = rep$&'smsq_qpc_procs_x'
7360   ex7$ = rep$&'smsq_qpc_cdaudio_x'
7370   ex8$ = rep$&'smsq_qpc_dos_x'
7380   ex9$ = rep$&'smsq_qpc_ip_x'
7390   exa$ = rep$&'smsq_home_home'
7400   exb$ = rep$&'smsq_recent_recent'
7410   qm$ =  rep$&"qmon_qpc_smsq"
7420   r$='ram1_smsqe.bin'
7430   EW p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3c$,ex3w$,ex3s$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$,exa$,exb$, r$
7440   COPY_O r$,rep$&'smsq_qpc_smsqe.bin'
7450   DELETE r$
7460   REMark rd$='ram1_smsqe.deb'
7470   REMark EW p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3c$,ex3w$,ex3s$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$,exa$,qm$, rd$
7480   REMark COPY_O r$,qpc$&'release_smsqe.bin'
7490   REMark COPY_O rd$,qpc$&'exe_smsqe.bin'
7500 END DEFine qpc_target
7510 :
7520 DEFine PROCedure q68_target
7530   local c%
7540   tgt$= rep$&'smsq_q68_QL_RAM.BIN'
7550   leng=350000
7560   nl$=rep$&'sys_boot_null'
7570   f$=rep$&'sys_boot_file'
7580   qr$=rep$&'sys_boot_q68_rom_bin'
7590   ld$=rep$&'smsq_smsq_loader'
7600   hi$=rep$&'smsq_q68_hwinit'
7610   os1$=rep$&'smsq_smsq_q68_os' : REMark change for fast memory
7620   ca$  = rep$&'smsq_smsq_cache'
7630   ns2$=rep$&'smsq_q68_nasty'
7640   os2$=rep$&'smsq_sbas_control'
7650   ln1$=rep$&'smsq_smsq_lang'
7660   ln2$=rep$&'smsq_q68_kbd_lang'
7670   ln3$=rep$&'smsq_sbas_lang'
7680   ex1$=rep$&'smsq_q68_sbas_procs_x'
7690   ex2$=rep$&'smsq_q68_driver_dv3'
7700   ex3$=rep$&'smsq_q68_driver_most'
7710   ex4a$=rep$&'smsq_q68_driver_ql'
7720   ex4b$=rep$&'smsq_q68_driver_16'
7730   ex4c$=rep$&'smsq_q68_driver_8'
7740   ex4w$=rep$&'smsq_smsq_wman'
7750   ex5$=rep$&'smsq_q40_sysspr'
7760 rem  ex6$=rep$&'smsq_q68_driver_nd'
7770   ex9$=rep$&'smsq_smsq_hotkey'
7780   ex10$=rep$&'smsq_home_home'
7790   ex11$=rep$&'smsq_recent_recent'
7800   EW f$, qr$,ld$,hi$,os1$,ca$,os2$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex4a$,ex4b$,ex4c$,ex4w$,ex5$,ex9$,ex10$,ex11$,ns2$,tgt$ : rem no net
7810   rem EW f$, qr$,ld$,hi$,os1$,ca$,os2$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex4a$,ex4b$,ex4w$,ex5$,ex6$,ex9$,ex10$,ex11$,ns2$,tgt$
7820   COPY_O tgt$,tgt$&"3"
7830   c%=fop_in (tgt$)
7840   fleng=flen(#c%)
7850   close#c%
7860   a=ALCHP (leng)
7870   LBYTES tgt$,a
7880   poke_l a+16,fleng                               : rem set length here
7890   SBYTES_O tgt$,a,leng
7900   RECHP a
7910 END DEFine q68_target
7920 :
7930 DEFine PROCedure findit
7940 LOCal lp%,a$
7950 restore 7950
7960   DATA p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3c$,ex3w$,ex3s$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$,exa$, r$,""
7970   REPeat lp%
7980     READ a$:IF a$="":EXIT lp%
7990     t%=FOP_IN(a$ )
8000     IF (t%<0)
8010        PRINT "not found "& a$
8020     END IF
8030  END REPeat lp%
8040 END DEFine findit
8050 :
8060 DEFine FuNction find_target% (current%)
8070   IF "SMSQ Generic" INSTR mdata$(current%):RETurn 1
8080   IF "Atari" INSTR mdata$(current%):RETurn 2
8090   IF "GoldCard" INSTR mdata$(current%):RETurn 4
8100   IF "Q40" INSTR mdata$(current%):RETurn 8
8110   IF "QXL" INSTR mdata$(current%):RETurn 16
8120   IF "Aurora" INSTR mdata$(current%):RETurn 32
8130   IF "Java" INSTR mdata$(current%):RETurn 64
8140   IF "Ptr_Gen" INSTR mdata$(current%):RETurn 128
8150   IF "QPC" INSTR mdata$(current%):RETurn 256
8160   IF "Q68" INSTR mdata$(current%):RETurn 512
8170   RETurn 0                                     : REMark huh???
8180 END DEFine find_target%
8190 :
8200 define procedure change_size (x%,y%)
8210 rem this uses the GLOBAL vars : maxx%,maxy%, xsize%,ysize%,main_xxx...
8220 local xrel%,yrel%,temp,a$,ttemp%(main_lit%),abs%,yabs%,t%,bt$,mtemp%(0,0)
8230   main_lfl%(size_it%)=1                 : remark reset to available
8240   dim mtemp%(dimn(main_mfl%,1),dimn(main_mfl%,2))
8250   arrcopy main_lfl%,ttemp%              : remark keep statusses
8260   arrcopy main_mfl%,mtemp%
8270   ch_win main_defn,xrel%,yrel%                    : remark get ptr displacement
8280   xsize%=xsize%-xrel%+3
8290   if xsize%<420:xsize%=420
8300   ysize%=ysize%-yrel%                             : remark new sizes
8310   t%=2^4+2^5                                      : rem return immediately from read ptr call
8320   rptr xabs%,yabs%,t%,t%,xrel%,yrel%,bt$: remark get absolute coords
8330   if xsize%>maxx%-16:xsize%=maxy%-16
8340   if ysize%>maxy%-16:ysize%=maxy%-16    : remark max values
8350   dr_unst main_defn                               : remark no more wdw defn...
8360   dr_remv main_defn                               : remark .... now!
8370   app_addr=0                                      : remark nor any appsub wdw
8380   rows%=-1
8390   make_main_wdw                         : remark make window anew
8400   arrcopy ttemp%,main_lfl%
8410   arrcopy mtemp%,main_mfl%
8420   t%=lxs%*3
8430   xabs%=xabs%-t%:if xabs%<0:xabs%=0     : remark position ptr nicely
8440   yabs%=yabs%-8:if yabs%<0:yabs%=0
8450   sptr xabs%,yabs%,0                              : remark now
8460   if compiled
8470      dr_ppos main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8480   else
8490      dr_puld main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8500   end if
8510   pos_ptr main_defn,x%*65536+y%,1      : remark position pointer in wdw
8520 end define change_size
8530 :
8540 def proc autochange_size (x%,y%)
8550 rem change size when items added/removed
8560 rem this tries to change the wdw position as little as possible
8570 local lp%,xrel%,yrel%,ttemp%(main_lit%),abs%,yabs%,t%,bt$
8580   t%=2^4+2^5                                      : rem return immediately from read ptr call
8590   rptr xabs%,yabs%,t%,t%,xrel%,yrel%,bt$: remark get absolute coords
8600   arrcopy main_lfl%,ttemp%              : remark keep statusses
8610   dr_unst main_defn                               : remark no more wdw defn...
8620   dr_remv main_defn                               : remark .... now!
8630   app_addr=0                                      : remark nor any appsub wdw
8640   rows%=data_count%-1
8650   make_main_wdw                         : remark make window anew
8660   for lp%=0 to dimn(main_lfl%,1)
8670      main_lfl%(lp%)=ttemp%(lp%)+1
8680   end for lp%
8690   set_statusses
8700   main_cty%(0,1)=1
8710   xabs%=xabs%-x%:if xabs%<0:xabs%=x%    : remark position ptr nicely
8720   yabs%=yabs%-y%:if yabs%<0:yabs%=y%
8730   sptr xabs%,yabs%,0                              : remark now
8740   if compiled
8750      dr_ppos main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8760   else
8770      dr_puld main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8780   end if
8790   pos_ptr main_defn,x%*65536+y%,1       : remark position pointer in wdw
8800 end define autochange_size
8810 :
8820 DEFine PROCedure set_statusses
8830 REMark set all statusses of menu appsub objects
8840 LOCal temp%,lp%,stat%
8850   temp%=DIMN(main_mfl%,1)               : REMark how many are there?
8860   stat%=main_lfl%(all_it%)              : REMark status of "all" item
8870   FOR lp%=0 TO temp%
8880     IF mdata$(lp%+1,1)='*'
8890       main_mfl%(lp%,0)=16               : REMark comments set to unavailable
8900     ELSE
8910       main_mfl%(lp%,0)=stat%            : REMark all other to status
8920     END IF
8930   END FOR lp%
8940 END DEFine set_statusses
8950 :
8960 define procedure make_main_wdw
8970 rem make the main window - a pretty standard window with 1 menu appsub wdw
8980 local main_lot,main_iwt,main_iot1,infy1%,lxs%,lys%,xesp%,nbr_post%,nbr_trgs%
8990 local title$,title_size%,title_x%,temp%,appwinoffset%,li_xorig%,li_xsize%
9000 :
9010   appwinoffset%=16                      : remark appsub win additional y offset
9020   lxs%=24:lys%=12                       : remark standard item x,y, sizes
9030   inf1y%=lys%+4                         : remark y orig of inner border
9040   xesp%=lxs%+2                                    : remark loose items x spacing
9050   nbr_post%=5                                     : remark nbr of item right & left in title bar
9060   li_xorig%=6
9070   li_xsize%=7*6 + 2
9080   nbr_trgs%=10                                     : rem number of targets
9090 :
9100   title$="dir: "&rep$&" "
9110   rem first make sure of the wdw sizes (we also come here from change_size!)
9120   temp%=(xsize%-li_xorig%) div nbr_trgs% : rem x size of 1 target loose item
9130   xsize%=temp%*nbr_trgs%+ li_xorig% +3
9140   xsize%=xsize%-(xsize% mod 4)                    : rem make into nbr divisible by 4
9150 :
9160   rem calculate the y size of the wdw so that it always looks nice, in that
9170   rem the rows in the appsub always fill the appsub entirely
9180   app_y_orig%=inf1y% + appwinoffset%    : rem y offset for appsub win within wdw
9190   calc_ysize 0                                    : rem set ysize% and rows% variables
9200 :
9210   rem first calc info obj size - this also influences one loose item, used
9220   rem in the title bar
9230   title_size%=len(title$)*6             : rem length in pixels
9240   title_x%=int((xsize%-title_size%)/2): rem x orig
9250 :
9260   rem first the loose items
9270 :
9280   esc%=0:move_it%=esc%+1:size_it%=move_it%+1
9290   sleep_it%=size_it%+1:all_it%=sleep_it%+1:go_it%=all_it%+1
9300   dir_it%=go_it%+1:target_its%=dir_it%+1:make_it%=target_its%+nbr_trgs%
9310   info_it%=make_it%+1:del_it%=info_it%+1:alltargets_it%=del_it%+1
9320 :
9330 restore 9330
9340 :
9350   main_lit%=20:dim main_lfl%(main_lit%)   : rem there are 21 items
9360   main_lot=rd_lot(std_iattr,main_lit%)
9370     data lxs%,lys%,4+xesp%*0,2,0,0,cancel$,text+retr,'ESC'
9380     data lxs%,lys%,4+xesp%*1,2,0,0,move$,sprite+retr,move_sprite
9390     data lxs%,lys%,4+xesp%*2,2,0,0,size$,sprite+retn,size_sprite
9400     data lxs%,lys%,xsize%-2-xesp%*1,2,0,0,sleep$,sprite+retr,sleep_sprite
9410     data lxs%,lys%,xsize%-2-xesp%*3,2,0,0,'A',sous1+retn,"All"
9420     data lxs%,lys%,xsize%-2-xesp%*4,2,0,0,'O',sous1+retn,"Ok"
9430     data 6*6,lys%-2,title_x%+30,3,0,0   ,'D',text+retn,rep$
9440     data li_xsize%,lys%,li_xorig%,inf1y%+2,0,0,        'G',sous1+retn,"Generic"
9450     data li_xsize%,lys%,li_xorig%+temp%,inf1y%+2,0,0,  'T',sous2+retn,"Atari"
9460     data li_xsize%,lys%,li_xorig%+temp%*2,inf1y%+2,0,0,'L',sous3+retn,"Goldcrd"
9470     data li_xsize%,lys%,li_xorig%+temp%*3,inf1y%+2,0,0,'Q',sous1+retn,"Q40/Q60"
9480     data li_xsize%,lys%,li_xorig%+temp%*4,inf1y%+2,0,0,'X',sous2+retn,"Qxl"
9490     data li_xsize%,lys%,li_xorig%+temp%*5,inf1y%+2,0,0,'U',sous2+retn,"Aurora"
9500     data li_xsize%,lys%,li_xorig%+temp%*6,inf1y%+2,0,0,'J',sous1+retn,"Java"
9510     data li_xsize%,lys%,li_xorig%+temp%*7,inf1y%+2,0,0,'P',sous1+retn,"PtrGen"
9520     data li_xsize%,lys%,li_xorig%+temp%*8,inf1y%+2,0,0,'C',sous3+retn,"QPC"
9530     data li_xsize%,lys%,li_yorig%+temp%*9,inf1y%+2,0,0,'8',sous3+retn,"Q68"
9540     data 4*6,lys%,xsize%-2-xesp%*2,2,0,0,'M',sous1+retn,"Make"
9550     data 4*6,lys%,xsize%-2-xesp%*5,2,0,0,'?',sous1+retn,"?"
9560     data lxs%,lys%,4+xesp%*3,2,0,0,"E",sous2+retn,"DEL"
9570     data lxs%,lys%,4+xesp%*4,2,0,0,"S",sous1+retn,"SaT"
9580 :
9590 rem now info wdw objects - here only one, the title
9600   rem make the title data: calculate size and x position of this object
9610   main_iot1=rd_iot(0)
9620     data title_size%,10,4,int((lys%-10)/2),sous1,sp.titlefg,0,0,title$
9630 :
9640 rem now the info wdws
9650   main_iwt=rd_iwt(2)                              : rem there are 3
9660   rem first the title bar
9670     data xsize%-8-(2*nbr_post%*xesp%),lys%+2,xesp%*nbr_post%+4,0       : rem x,y sizes & origs
9680     data 0,0,sp.infwinbd,sp.titlebg     : rem shadow, border size & col,paper col
9690     data 0                                        : rem object pointer (none)
9700 :
9710   rem now wdw containing title itself
9720     data title_size%+8,lys%,title_x%-4,2
9730     data 0,0,sp.infwindbd,sp.infwinbg
9740     data main_iot1                      : rem one object
9750 :
9760   rem inner border
9770     data xsize%-8,ysize%-inf1y%-2,4,inf1y%
9780     data 0,1,sp.infwinbd,sp.infwinbg
9790     data 0
9800 :
9810 rem now the appsub wdw - use the outptr functions for this
9820   main_app_list=0                       : rem appsub win list
9830   app_addr=0                                      : rem there is no appsub win yet
9840   menu_selkeys$=""                      : rem selkeys to exclude
9850   appw_sections%=1                      : rem display only one section
9860   app_addr=mk_main_app(app_addr,mdata$,0,0,1,0,0,0) : rem make apsub wdw
9870   main_app_list = app_addr+180                    : rem list built by outptr
9880   set_statusses                         : rem set statusses of menu items
9890 :
9900 rem the working defn
9910   main_defn=rd_wdef
9920     data 2,1,sp.winbd,sp.winbg                    : rem shad,border size & col,pap col
9930     data xsize%,ysize%,0,0              : rem x,y size & initial ptr pos
9940     data main_sprite,main_lot,main_iwt,main_app_list : rem sprite,loose items, info wins, appsubs
9950 end define make_main_wdw
9960 :
9970 def fn warning_pos% (mess$,channel%,title$,pos)
9980 rem warning wdw with pointer positioning
9990   pos_ptr main_defn,pos,-1
10000   return warning%(mess$,channel%,title$)
10010 end def warning_pos%
10020 :
10030 define function warning%(mess$,channel%,title$)
10040 rem shows a warning message (mess$) in a small window. hit esc or ok
10050 rem to return; returns 0 if esc, 1 if ok  hit
10060 local item%,lp%,chan%,y%,swnum%,infot%
10070   stop_info
10080   if channel%
10090     chan%=channel%
10100   else
10110     chan%=fopen("con")
10120   endif
10130   ch_item warn_defn,-3,0,-1,'','Attention'
10140   ch_item warn_defn,-1,0,-1,cancel$,'ESC'
10150   ch_item warn_defn,-1,1,-1,'O','OK'
10160   warn_lfl%(0)=1:warn_lfl%(1)=1
10170   poke_w warn_defn+44,sp.errmg                           : rem border colour of wdw
10180   poke_w warn_defn+46,sp.errbg                           : rem paper colour of wdw
10190   poke_w warn_wdw_addr+14,sp.errbg             : rem paper of title info wdw
10200   obj_addr=peek_l(warn_wdw_addr+16)            : rem ptr to object list
10210   poke_w obj_addr+10,sp.errfg                            : rem info object text  colour
10220   dr_puld warn_defn,-1,-1
10230   dr_iwdf #chan%,warn_defn,0
10240   wm_paper#chan%,sp.errbg
10250   wm_ink#chan%,sp.errfg
10260   cls#chan%
10270   if title$<>"":print#chan%,title$;" :"
10280   print #chan%,mess$
10290   pos_ptr warn_defn,160*65536+10,-1
10300   repeat lp%
10310     rd_ptr warn_defn,item%,swnum%,y%,y%,y%,warn_lfl%
10320     if swnum%=-1:exit lp%
10330   end repeat lp%
10340   if not channel%:close#chan%
10350   dr_unst warn_defn
10360   return item%
10370 end define warning%
10380 :
10390 def proc info_pos (mess$,channel%,pos)
10400 rem warning wdw with positioning
10410   pos_ptr main_defn,pos,-1
10420   info mess$,channel%
10430 end def info_pos
10440 :
10450 define procedure info(mess$,channel%)
10460 rem shows window containing mess$. channel% is a screen channel, if this is 0,
10470 rem a temp screen channel will be opened.
10480 local chan%,infot%,obj_addr
10490   if channel%
10500     chan%=channel%
10510   else
10520     chan%=fopen("con")
10530   endif
10540   ch_item warn_defn,-3,0,-1,"",'  Info.  '
10550   ch_item warn_defn,-1,0,-1,"",'Info'
10560   ch_item warn_defn,-1,1,-1,"",'Info'
10570   poke_w warn_defn+44,sp.infwinbg                 : rem paper colour of wdw
10580   poke_w warn_defn+46,sp.winbd                              : rem border around wdw
10590   poke_w warn_wdw_addr+14,sp.infwinbg             : rem paper of title info wdw
10600   obj_addr=peek_l(warn_wdw_addr+16)               : rem ptr to object list
10610   poke_w obj_addr+10,sp.infwinfg                  : rem info object text        colour
10620   dr_puld warn_defn,-1,-1
10630   pos_ptr warn_defn,90*65536+70,-1
10640   dr_iwdf #chan%,warn_defn,0
10650   wm_paper#chan%,sp.infwinbg
10660   wm_ink#chan%,sp.infwinfg
10670   cls#chan%
10680   print #chan%,mess$
10690   if not channel%:close#chan%
10700   info_is_pulled_down%=1
10710 end define info
10720 :
10730 def proc info_wait(mess$,channel%)
10740 rem shows info wdw, waits until user clicks, closed info wdw
10750   show_info mess$,channel%
10760   info_wait_to_close
10770 end def info_wait
10780 :
10790 def proc info_wait_to_close
10800 local item%,lp%,chan%,y%,swnum%,infot%
10810   repeat lp%
10820     rd_ptr warn_defn,item%,swnum%,y%,y%,y%,warn_lfl%
10830     if swnum%=-1:exit lp%
10840   end repeat lp%
10850   stop_info
10860 end def info_wait_to_close
10870 :
10880 def proc info_pos_wait (mess$,channel%,pos)
10890 rem positions & shows info wdw, waits until user clicks,closes info wdw
10900   info_pos mess$,channel%,pos
10910   info_wait_to_close
10920 end def info_pos_wait
10930 :
10940 def proc stop_info
10950   if info_is_pulled_down%
10960     dr_unst warn_defn
10970     info_is_pulled_down%=0
10980   endif
10990 end def stop_info
11000 :
11010 def proc show_info (mess$,channel%)
11020 rem either opens the info wdw and shows the message or shows the message in
11030 rem the existing info wdw
11040 local chan%
11050   if channel%
11060     chan%=channel%
11070   else
11080     chan%=fopen("con")
11090   endif
11100   if info_is_pulled_down%
11110     cls#chan%
11120     wm_paper#chan%,sp.infwinbg
11130     wm_ink#chan%,sp.infwinfg
11140     cls#chan%
11150     print #chan%,mess$
11160   else
11170     info mess$,chan%
11180   endif
11190   if not channel%:close#chan%
11200 end def show_info
11210 :
11220 DEFine PROCedure button (def_trav,menu_drap%,app_drap%,control%,chaine$,type_col%)
11230 REMark les parametres sont, dans l'ordre:
11240 REMark la dƒfinition de la fen‘tre, suivie des tableaux pour
11250 REMark les postes du menu dƒliƒ, les postes de la sous-fen‘tre d'appl.
11260 REMark et la dƒfinition de contr˜le, suivi du nom du bouton et
11270 REMark du type couleurs.
11280 REMark Il est supposƒ que vous avez ouvert une fen‘tre #1 si
11290 REMark le programme est compilƒ
11300   DR_UNST def_trav
11310   IF compiled: CLOSE#1
11320   button_wait chaine$
11330 rem  BTN chaine$,type_col%
11340   IF compiled
11350     OPEN#1,"CON_"
11360     DR_PPOS def_trav,-1,-1,menu_drap%,app_drap%,control%
11370   ELSE
11380     DR_PULD def_trav,-1,-1,menu_drap%,app_drap%,control%
11390   END IF
11400 END DEFine button
11410 :
11420 DEFine PROCedure make_colours (colourway%)
11430 REMark this initialises the GLOBAL variables menu_pap, menu_brd, menu_inv,
11440 REMark menu_ink and menu_bar according to the colourway passed as parameter.
11450 REMark More importantly, this sets the sp.xxx GLOBAL variables.
11460 REMark The GLOBAl variable mycolour_mode% must have been set prior to calling
11470 REMark this function, preferrably via the function set_colours%.
11480 REMark Moreover the colours black, white,red, green,wg_stripes, etc...
11490 REMark must have been set prior to calling this procedure:
11500 REMark Preferrably, they were also set via the function set_colours%
11510 :
11520 rem this function needs the extension WL_MK16 (outptr_bin)
11530 :
11540 REMark the colourways% are:
11550 REMark 0= white/green
11560 REMark 1= black/red
11570 REMark 2= white/red
11580 REMark 3= black/green
11590 remark 4-7= use system palettes
11600 :
11610 rem the Global war mycolour_mode% is:
11620 rem 0 = we are in QL mode 4
11630 rem 1 = we are in PAL mode (256 colours)
11640 rem 2 - we are in 24 bit colour mode
11650 rem preferrably, this is set via the function set_colours%
11660 :
11670   if colourway%>7 or colourway%<0: colourway%=0: REMark must be between 0 & 7
11680 :
11690 rem first make sure that what we request is possible.
11700 rem colourways 4-7 are only possible if we are in 8 or 24 bit colour mode
11710 rem if it is requested in another mode, it is set to 0
11720 :
11730   if colourway%>3
11740      make_my_palette colourway%-4: rem set colours according to system palette
11750      return                         : rem premature exit
11760   endif
11770 :
11780 rem this now is only the old colourways
11790   select on mycolour_mode%
11800     =0                                  : rem QL 4 colours
11810       SELect ON colourway%
11820           =0:                           : remark white/green
11830                 menu_pap=white
11840                 menu_brd=green
11850                 menu_ink=black
11860                 menu_bar=wg_striped
11870                 menu_inv=red
11880           =1:                           : remark black/red
11890                 menu_pap=black
11900                 menu_brd=red
11910                 menu_ink=white
11920                 menu_bar=br_striped
11930                 menu_inv=green
11940           =2:                           : remark white/red
11950                 menu_pap=white
11960                 menu_brd=red
11970                 menu_ink=black
11980                 menu_bar=wr_striped
11990                 menu_inv=green
12000           =3:                           : remark black/green
12010                 menu_pap=black
12020                 menu_brd=green
12030                 menu_ink=white
12040                 menu_bar=bg_striped
12050                 menu_inv=red
12060       END SELect
12070     =1                                  : rem pal colours
12080       SELect ON colourway%
12090           =0:                           : remark white/green
12100                 menu_pap=white+256
12110                 menu_brd=green+256
12120                 menu_ink=black+256
12130                 menu_bar=wg_striped+256
12140                 menu_inv=red +256
12150           =1:                           : remark black/red
12160                 menu_pap=black+256
12170                 menu_brd=red  +256
12180                 menu_ink=white +256
12190                 menu_bar=br_striped +256
12200                 menu_inv=green +256
12210                 omenu_pap=black+256
12220           =2:                           : remark white/red
12230                 menu_pap=white +256
12240                 menu_brd=red   +256
12250                 menu_ink=black +256
12260                 menu_bar=wr_striped +256
12270                 menu_inv=green +256
12280           =3:                           : remark black/green
12290                 menu_pap=black +256
12300                 menu_brd=green +256
12310                 menu_ink=white +256
12320                 menu_bar=bg_striped +256
12330                 menu_inv=red   +256
12340       END SELect
12350     =2                                  : rem 24 bit colours
12360       SELect ON colourway%
12370           =0:                           : remark white/green
12380                 menu_pap=WL_MK16(white)
12390                 menu_brd=WL_MK16(green)
12400                 menu_ink=WL_MK16(black)
12410                 menu_bar=WL_MK16(wg_striped)
12420                 menu_inv=WL_MK16(red)
12430           =1:                           : remark black/red
12440                 menu_pap=WL_MK16(black)
12450                 menu_brd=WL_MK16(red)
12460                 menu_ink=WL_MK16(white)
12470                 menu_bar=WL_MK16(br_striped)
12480                 menu_inv=WL_MK16(green)
12490           =2:                           : remark white/red
12500                 menu_pap=WL_MK16(white)
12510                 menu_brd=WL_MK16(red)
12520                 menu_ink=WL_MK16(black)
12530                 menu_bar=WL_MK16(wr_striped)
12540                 menu_inv=WL_MK16(green)
12550           =3:                           : remark black/green
12560                 menu_pap=WL_MK16(black)
12570                 menu_brd=WL_MK16(green)
12580                 menu_ink=WL_MK16(white)
12590                 menu_bar=WL_MK16(bg_striped)
12600                 menu_inv=WL_MK16(red)
12610       END SELect
12620   end select
12630 :
12640   make_my_old_palette
12650 :
12660 END DEFine make_colours
12670 :
12680 def proc make_my_palette (cw%)
12690   sp.winbd            = hex('0200') : rem Window border
12700   sp.winbg            = hex('0201') : rem Window background
12710   sp.winfg            = hex('0202') : rem Window foreground
12720   sp.winmg            = hex('0203') : rem Window middleground
12730   sp.titlebg          = hex('0204') : rem Title background
12740   sp.titletextbg  = hex('0205') : rem Title text background
12750   sp.titlefg          = hex('0206') : rem Title foreground
12760   sp.litemhigh        = hex('0207') : rem Loose item highlight
12770   sp.litemavabg   = hex('0208') : rem Loose item available background
12780   sp.litemavafg   = hex('0209') : rem Loose item available foreground
12790   sp.litemselbg   = hex('020a') : rem Loose item selected background
12800   sp.litemselfg   = hex('020b') : rem Loose item selected foreground
12810   sp.litemunabg   = hex('020c') : rem Loose item unavailable background
12820   sp.litemunafg   = hex('020d') : rem Loose item unavailable foreground
12830   sp.infwinbd         = hex('020e') : rem Information window border
12840   sp.infwinbg         = hex('020f') : rem Information window background
12850   sp.infwinfg         = hex('0210') : rem Information window foreground
12860   sp.infwinmg         = hex('0211') : rem Information window middleground
12870   sp.subinfbd         = hex('0212') : rem Subsidiary information window border
12880   sp.subinfbg         = hex('0213') : rem Subsidiary information window background
12890   sp.subinffg         = hex('0214') : rem Subsidiary information window foreground
12900   sp.subinfmg         = hex('0215') : rem Subsidiary information window middleground
12910   sp.appbd            = hex('0216') : rem Application window border
12920   sp.appbg            = hex('0217') : rem Application window background
12930   sp.appfg            = hex('0218') : rem Application window foreground
12940   sp.appmg            = hex('0219') : rem Application window middleground
12950   sp.appihigh         = hex('021a') : rem Application window item highlight
12960   sp.appiavabg        = hex('021b') : rem Application window item available background
12970   sp.appiavafg        = hex('021c') : rem Application window item available foreground
12980   sp.appiselbg        = hex('021d') : rem Application window item selected background
12990   sp.appiselfg        = hex('021e') : rem Application window item selected foreground
13000   sp.appiunabg        = hex('021f') : rem Application window item unavailable background
13010   sp.appiunafg        = hex('0220') : rem Application window item unavailable foreground
13020   sp.scrbar           = hex('0221') : rem Pan/scroll bar
13030   sp.scrbarsec        = hex('0222') : rem Pan/scroll bar section
13040   sp.scrbararr        = hex('0223') : rem Pan/scroll bar arrow
13050   sp.buthigh          = hex('0224') : rem Button highlight
13060   sp.butbd            = hex('0225') : rem Button border
13070   sp.butbg            = hex('0226') : rem Button background
13080   sp.butfg            = hex('0227') : rem Button foreground
13090   sp.hintbd           = hex('0228') : rem Hint border
13100   sp.hintbg           = hex('0229') : rem Hint background
13110   sp.hintfg           = hex('022a') : rem Hint foreground
13120   sp.hintmg           = hex('022b') : rem Hint middleground
13130   sp.errbg            = hex('022c') : rem Error message background
13140   sp.errfg            = hex('022d') : rem Error message foreground
13150   sp.errmg            = hex('022e') : rem Error message middleground
13160   sp.shaded           = hex('022f') : rem sp.shaded area
13170   sp.3ddark           = hex('0230') : rem Dark 3D border shade
13180   sp.3dlight          = hex('0231') : rem Light 3D border shade
13190   sp.vertfill         = hex('0232') : rem Vertical area fill
13200   sp.subtitbg         = hex('0233')  : rem Subtitle background
13210   sp.subtittxtbg  = hex('0234')  : rem Subtitle text background
13220   sp.subtitfg         = hex('0235')  : rem Subtitle foreground
13230   sp.mindexbg         = hex('0236')  : rem Menu index background
13240   sp.mindexfg         = hex('0237')  : rem Menu index foreground
13250   sp.separator        = hex('0238')  : rem Seperator lines etc.
13260   if not (is_open(#0) or is_open(#1))
13270     open#1,'con'
13280     sp_jobpal -1,cw%
13290     close#1
13300   else
13310     sp_jobpal -1,cw%
13320   endif
13330 end def make_my_palette
13340 :
13350 def proc make_my_old_palette
13360 rem this translates the colours used in the wdws into 4 colour mode...
13370   sp.winbd          =         menu_ink   : rem Window border
13380   sp.winbg          =         menu_pap   : rem Window background
13390   sp.winfg          =         menu_pap   : rem Window foreground
13400   sp.winmg          =         menu_pap   : rem Window middleground
13410   sp.titlebg        =         menu_bar   : rem Title background
13420   sp.titletextbg=   menu_pap   : rem Title text background
13430   sp.titlefg        =         menu_ink   : rem Title foreground
13440   sp.litemhigh      =         menu_brd   : rem Loose item highlight
13450   sp.litemavabg =   menu_pap   : rem Loose item available background
13460   sp.litemavafg =   menu_ink   : rem Loex fifiose item available foreground
13470   sp.litemselbg =   menu_brd   : rem Loose item selected background
13480   sp.litemselfg =   menu_ink   : rem Loose item selected foreground
13490   sp.litemunabg =   menu_pap   : rem Loose item unavailable background
13500   sp.litemunafg =   menu_brd   : rem Loose item unavailable foreground
13510   sp.infwinbd       =         menu_brd   : rem Information window border
13520   sp.infwinbg       =         menu_pap   : rem Information window background
13530   sp.infwinfg       =         menu_ink   : rem Information window foreground
13540   sp.infwinmg       =         menu_pap   : rem Information window foreground
13550   sp.subinfbd       =         menu_brd   : rem Information window border (sub)
13560   sp.subinfbg       =         menu_pap   : rem Information window background
13570   sp.subinffg       =         menu_ink   : rem Information window foreground
13580   sp.subinfmg       =         menu_pap   : rem Information window foreground
13590   sp.appbd          =         menu_brd   : rem Application window border
13600   sp.appbg          =         menu_pap   : rem Application window background
13610   sp.appfg          =         menu_ink   : rem Application window foreground
13620   sp.appmg          =         menu_pap   : rem Application window middleground
13630   sp.appihigh       =         menu_ink   : rem Application window item highlight
13640   sp.appiavabg      =         menu_pap   : rem Application window item available background
13650   sp.appiavafg      =         menu_ink   : rem Application window item available foreground
13660   sp.appiselbg      =         menu_brd   : rem Application window item selected background
13670   sp.appiselfg      =         menu_ink   : rem Application window item selected foreground
13680   sp.appiunabg      =         menu_pap   : rem Application window item unavailable background
13690   sp.appiunafg      =         menu_brd   : rem Application window item unavailable foreground
13700   sp.scrbar         =         menu_ink   : rem Pan/scroll bar
13710   sp.scrbarsec      =         menu_pap   : rem bar section
13720   sp.scrbararr      =         menu_brd   : rem Pan/scroll bar arrow
13730   sp.buthigh        =         menu_ink   : rem Button highlight
13740   sp.butbd          =         menu_brd   : rem Button border
13750   sp.butbg          =         menu_pap   : rem Button background
13760   sp.butfg          =         menu_ink   : rem Button foreground
13770   sp.hintbd         =         menu_brd   : rem Hint border
13780   sp.hintbg         =         menu_ink   : rem Hint background
13790   sp.hintfg         =         menu_pap   : rem Hint foreground
13800   sp.hintmg         =         menu_ink   : rem Hint middleground
13810   sp.errbg          =         menu_inv   : rem Error message background
13820   sp.errfg          =         menu_ink   : rem Error message foreground
13830   sp.errmg          =         menu_ink   : rem Error message middleground
13840   sp.shaded         =         0            : rem sp.shaded area
13850   sp.3ddark         =         0            : rem Dark 3D border shade
13860   sp.3dlight        =         white        : rem Light 3D border shade
13870   sp.vertfill       =         menu_pap   : rem Vertical area fill
13880   sp.subtitbg       =         menu_pap   : rem Subtitle background
13890   sp.subtittxtbg=   menu_pap   : rem Subtitle text background
13900   sp.subtitfg       =         menu_ink   : rem Subtitle foreground
13910   sp.mindexbg       =         menu_pap   : rem Menu index background
13920   sp.mindexfg       =         menu_brd   : rem same,        foreground
13930   sp.separator      =         menu_brd   : rem Seperator lines etc.
13940 end def make_my_old_palette
13950 :
13960 DEFine FuNction centr$(ctr$,leng)
13970 rem this "centres" the string ctr$ (i.e. left padds it with spaces) so that
13980 rem it is centred in a window of leng width (leng is length in chars)
13990   LOCal l%,cta$
14000   cta$=ctr$
14010   strip_spaces cta$
14020   l%=INT(leng-LEN(cta$))/2
14030   if l%<0:return cta$
14040   return FILL$(' ',l%)&cta$&FILL$(' ',l%)
14050 END DEFine centr$
14060 :
14070 def proc calc_ysize (y_csize%)
14080 rem This tries to calculate the window y size depending on the given y size,
14090 rem the number of rows wished in the menu appsub window and the y position of
14100 rem the menu appsub window.
14110 rem It uses and changes the GLOBAL variables rows%, app_y_orig% and ysize%.
14120 rem It also uses the GLOBAL var maxy% which is the maximum y size a window
14130 rem could have in the current screen resolution.
14140 rem algo is as follows:
14150 rem if both ysize and rows% are undefined (=-1) : make wdw as big as possible
14160 rem if one is undefined, calc the other
14170 rem if both are defined, give precedence to the rows number
14180 rem
14190 rem param : y_csize% is the y character height, either 0 (10 pix) or 1 (20 pix)
14200 rem
14210 local y_spcg%
14220   if rows%=0:return
14230   y_spcg% = 12+(y_csize%*10)
14240   if rows%= -1
14250     if ysize%= -1
14260       rows%=(maxy%-14-app_y_orig%) div y_spcg% : rem max nbr of rows
14270     else
14280       rows%= (ysize%-app_y_orig%-4) div y_spcg%
14290     endif
14300   endif
14310   if rows%<2:rows%=2
14320   ysize%=rows%*y_spcg%+app_y_orig%+4
14330   if ysize%>=maxy%-14
14340     ysize%=maxy%-app_y_orig%-14
14350     rows%=ysize% div y_spcg%
14360     ysize%=rows%*y_spcg% + app_y_orig% + 4
14370   endif
14380   if ysize%<minysize%
14390     ysize%=minysize% -app_y_orig%-14
14400     rows%=ysize% div y_spcg%
14410     ysize%=rows%*y_spcg% + app_y_orig% + 4
14420   endif
14430 end def calc_ysize
14440 :
14450 DEFine PROCedure scroll_arrows(rows%,nbr_objects%,appfen,cty%)
14460 rem This determined whether an appsub wdw should have scroll arrows.
14470 rem Params: number of visible rows in the appsub wdw, ,total nbr of object rows
14480 rem in the abbsub wdw (not the visible rows, but the rows with objects),
14490 rem pointer to the appsub wdw defn returned by the APP_MAKE or APP_MAKE2 function
14500 rem and the control definition
14510   IF nbr_objects%<=rows%
14520     POKE_W appfen+150,0       : rem all objects fit , so no scroll arrows
14530                                         : rem and no y offset to start of menu
14540     poke_l appfen+96,0                  : rem no scroll bars
14550     cty%(1,2)=nbr_objects%    : rem nbr of columns/rows
14560   ELSE
14570     POKE_W appfen+150,6       : rem leave space for arrows
14580     cty%(1,2)=rows%-1                   : rem if scroll arrows are there, there is one line less in the window
14590     poke_l appfen+96,hex("2210222")
14600   END IF
14610   IF DIMN(cty%,1)=2:cty%(2,2)=cty%(1,2)
14620   cty%(0,1)=1                            : rem show that definition has changed
14630 END DEFine scroll_arrows
14640 :
14650 DEFine FuNction getstr$(poste%,drap%,defn,a$)
14660 REMark opens and sets a window over a loose item and proposes a sting to be edited.
14670 REMark parameters:
14680 REMark - item nbr
14690 REMark - falg whether result MUST be a numbrr (flag<>0)
14700 REMark - the working definition
14710 REMark - the string o edit
14720 rem returns the string or ""
14730 rem uses the global (!) vars sp.litemselbg and sp.litemselfg
14740 rem
14750 local b$,chan%
14760   chan%=FOPEN("con")
14770   b$=getstr2$(poste%,drap%,defn,a$,chan%)
14780   close#chan%
14790   return b$
14800 END DEFine getstr$
14810 :
14820 DEFine FuNction getstr2$(poste%,drap%,defn,a$,chan%)
14830 REMark sets a window over a loose item and proposes a sting to be edited.
14840 REMark parameters:
14850 REMark - item nbr
14860 REMark - falg whether result MUST be a numbrr (flag<>0)
14870 REMark - the working definition
14880 REMark - the string o edit
14890 remark - a screen channel to be used
14900 rem returns the string or ""
14910 rem uses the global (!) vars sp.litemselbg and sp.litemselfg
14920 rem
14930   LOCal b$,res
14940   b$=" ":b$=a$           : REMark c'est curieusement nƒcessaire
14950   wm_PAPER#chan%,sp.litemselbg
14960   wm_INK#chan%,sp.litemselfg
14970   DR_LWDF#chan%,defn,poste%             : rem open channel over item
14980   CLS#chan%
14990   res=GET_STR(#chan%,drap%,b$)                                : rem get string
15000   IF res<0:b$=""                        : rem ooops
15010   CH_ITEM defn,-1,poste%,-1,"",b$
15020   RETurn b$
15030 END DEFine getstr2$
15040 :
15050 def fn showcont$(string$,length%)
15060 rem this adds '...' at the end of a string, to show that it continues
15070 local l%,lengt%
15080   l%=len(string$)
15090   if not l%:return ""                             : rem empty string
15100   lengt%=length% div 6
15110   if l%<=lengt%:return string$                    : rem entire string fits wdw
15120   return string$(1 to lengt%-3)&"..."
15130 end def showcont$
15140 :
15150 def fn get_free_text$(defn,item%,prompt$,length%)
15160 rem this opens wdw over loose-item item% of the working definition defn
15170 rem allows free text to be entered
15180 rem params: working defintion,item over which wdw is to be opened
15190 rem           first value of string, length of max string in wdw, if this is...
15200 rem              -1, the length will be determined here
15210 local chan%,string$,tempsizes%(3)
15220   chan%=fopen('con')
15230   if chan%<0:return prompt$
15240   dr_lwdf#chan%,defn,item%              : rem open wdw over item
15250   paper#chan%,menu_brd
15260   ink#chan%,menu_ink
15270   cls#chan%
15280   string$=wedit$(#chan%,prompt$)
15290   if length%=-1
15300      wsipo#chan%,tempsizes%
15310      length%=tempsizes%(0)
15320   endif
15330   close#chan%
15340   if length%
15350     ch_item defn,-1,item%,-1,"",showcont$(string$,length%)
15360   else
15370     ch_item defn,-1,item%,-1,"",string$
15380   endif
15390   return string$
15400 end def get_free_text$
15410 :
15420 def proc make_my_palette (cw%)
15430   sp.winbd            = hex('0200') : rem Window border
15440   sp.winbg            = hex('0201') : rem Window background
15450   sp.winfg            = hex('0202') : rem Window foreground
15460   sp.winmg            = hex('0203') : rem Window middleground
15470   sp.titlebg          = hex('0204') : rem Title background
15480   sp.titletextbg  = hex('0205') : rem Title text background
15490   sp.titlefg          = hex('0206') : rem Title foreground
15500   sp.litemhigh        = hex('0207') : rem Loose item highlight
15510   sp.litemavabg   = hex('0208') : rem Loose item available background
15520   sp.litemavafg   = hex('0209') : rem Loose item available foreground
15530   sp.litemselbg   = hex('020a') : rem Loose item selected background
15540   sp.litemselfg   = hex('020b') : rem Loose item selected foreground
15550   sp.litemunabg   = hex('020c') : rem Loose item unavailable background
15560   sp.litemunafg   = hex('020d') : rem Loose item unavailable foreground
15570   sp.infwinbd         = hex('020e') : rem Information window border
15580   sp.infwinbg         = hex('020f') : rem Information window background
15590   sp.infwinfg         = hex('0210') : rem Information window foreground
15600   sp.infwinmg         = hex('0211') : rem Information window middleground
15610   sp.subinfbd         = hex('0212') : rem Subsidiary information window border
15620   sp.subinfbg         = hex('0213') : rem Subsidiary information window background
15630   sp.subinffg         = hex('0214') : rem Subsidiary information window foreground
15640   sp.subinfmg         = hex('0215') : rem Subsidiary information window middleground
15650   sp.appbd            = hex('0216') : rem Application window border
15660   sp.appbg            = hex('0217') : rem Application window background
15670   sp.appfg            = hex('0218') : rem Application window foreground
15680   sp.appmg            = hex('0219') : rem Application window middleground
15690   sp.appihigh         = hex('021a') : rem Application window item highlight
15700   sp.appiavabg        = hex('021b') : rem Application window item available background
15710   sp.appiavafg        = hex('021c') : rem Application window item available foreground
15720   sp.appiselbg        = hex('021d') : rem Application window item selected background
15730   sp.appiselfg        = hex('021e') : rem Application window item selected foreground
15740   sp.appiunabg        = hex('021f') : rem Application window item unavailable background
15750   sp.appiunafg        = hex('0220') : rem Application window item unavailable foreground
15760   sp.scrbar           = hex('0221') : rem Pan/scroll bar
15770   sp.scrbarsec        = hex('0222') : rem Pan/scroll bar section
15780   sp.scrbararr        = hex('0223') : rem Pan/scroll bar arrow
15790   sp.buthigh          = hex('0224') : rem Button highlight
15800   sp.butbd            = hex('0225') : rem Button border
15810   sp.butbg            = hex('0226') : rem Button background
15820   sp.butfg            = hex('0227') : rem Button foreground
15830   sp.hintbd           = hex('0228') : rem Hint border
15840   sp.hintbg           = hex('0229') : rem Hint background
15850   sp.hintfg           = hex('022a') : rem Hint foreground
15860   sp.hintmg           = hex('022b') : rem Hint middleground
15870   sp.errbg            = hex('022c') : rem Error message background
15880   sp.errfg            = hex('022d') : rem Error message foreground
15890   sp.errmg            = hex('022e') : rem Error message middleground
15900   sp.shaded           = hex('022f') : rem sp.shaded area
15910   sp.3ddark           = hex('0230') : rem Dark 3D border shade
15920   sp.3dlight          = hex('0231') : rem Light 3D border shade
15930   sp.vertfill         = hex('0232') : rem Vertical area fill
15940   sp.subtitbg         = hex('0233')  : rem Subtitle background
15950   sp.subtittxtbg  = hex('0234')  : rem Subtitle text background
15960   sp.subtitfg         = hex('0235')  : rem Subtitle foreground
15970   sp.mindexbg         = hex('0236')  : rem Menu index background
15980   sp.mindexfg         = hex('0237')  : rem Menu index foreground
15990   sp.separator        = hex('0238')  : rem Seperator lines etc.
16000   if cw%
16010     if not (is_open(#0) or is_open(#1))
16020       open#1,'con'
16030       sp_jobpal -1,cw%
16040       close#1
16050     else
16060       sp_jobpal -1,cw%
16070     endif
16080   endif
16090 end def make_my_palette
16100 :
16110 def fn set_colours% (force_mode%)
16120 rem this sets colour variables according to the colour mode wished, if possible.
16130 rem force_mode%=
16140 rem       0 if ql colours wished (mode 4 only)
16150 rem       1 if pal colours wished
16160 rem       2 if 24 bit colours wished
16170 rem This function returns the true QL mode set (4,8,32,33 etc.).
16180 rem This function also sets the GLOBAL variable mycolour_mode% to the
16190 rem mode 0,1,2 as above - whatever is possible on the machine, i.e.
16200 rem if colour_24 is wished on a 4 colour machine (which won't succeed)
16210 rem this function will set set that variable to 0, i.e. QL mode.
16220 rem
16230 rem This function needs the outptr toolkit
16240 local mode%
16250   mode%=rmode                                     : rem get current mode now
16260   select on force_mode%
16270       = 0                                         : rem mode 4 wished
16280        select on mode%
16290             = 4                                   : rem already on, so do nothing
16300             = 0,1,8 : mode 4            : rem old modes, set to 4 colours
16310             = remainder
16320               colour_ql                           : rem if higher colour mode, set to "mode 4"
16330               mode 4
16340        end select
16350        mode%=0                                    : rem new mode we're in  - 4 colour mode
16360       = 1                                         : rem PALette wished
16370        select on mode%
16380             = 16,32,33 : colour_pal:mode%=1  : rem we're in high colour mode, but PAL colours wished
16390             = remainder
16400               if mode%<>4:mode 4
16410               mode%=0
16420        end select
16430       = 2
16440        select on mode%
16450             = 32,33 : colour_24 :mode%=2          : rem we're in high col mode 24 bit colours
16460             = 16 : colour_pal : mode%=1
16470             = remainder
16480               if mode%<>4:mode 4
16490               mode%=0
16500        end select
16510   end select
16520   mycolour_mode%=mode%                            : rem set this global variable now:
16530   rem now set some colour variables
16540   select on mode%
16550        = 0                                        : rem Ql 4 mode colours
16560           Black            = 0
16570           White            = 7
16580           Red              = 2
16590           Green            = 4
16600           wg_striped     = 92
16610           br_striped     = 82
16620           wr_striped     = 107
16630           bg_striped     = 100
16640        = 1                              : rem Colour_pal
16650           Black            = 0
16660           White            = 1
16670           Red              = 2
16680           Green            = 3
16690           wg_striped     = light_green
16700           br_striped     = dark_red
16710           wr_striped     = light_red
16720           bg_striped     = dark_green
16730        = 2                              : rem colour_24
16740           Black            = hex('000000')
16750           White            = hex('FFFFFF')
16760           Red              = hex('FF0000')
16770           Green            = hex('00FF00')
16780           wg_striped     = light_green
16790           br_striped     = dark_red
16800           wr_striped     = light_red
16810           bg_striped     = dark_green
16820   end select
16830   mode%=rmode
16840   ret mode%                             : rem return current screen mode now
16850 end def set_colours%
16860 :
16870 def fn do_caps(a$,caps%)
16880 rem set string to capitales etc,caps% determines whether the string....
16890 REMark ...must be lower case (=0), upper case(=1), all words capitalized (=2),
16900 REMark ... first word only capitalized (=3), or nothing(=-1)
16910   SELect ON caps%
16920    =0: MIN a$
16930    =1: MAJ a$
16940    =2: CAP2 a$
16950    =3: CAP a$
16960   END SELect
16970   return a$
16980 end def do_caps
16990 :
17000 def fn mk_main_app (app_addr,subwinarray$,x_csize%,y_csize%, use_apm2%,hit_is_do%,sizex%,origx%)
17010 rem This makes a standard menu appsub with standard global variables.
17020 rem It presumes that the followng vars have been set:
17030 rem  * rows% holds the number of rows to be seen in the appsub window when there
17040 rem    are no scroll arrows (if there are, 1 less row will be seen)
17050 rem  * app_y_orig% = y origin of appsub within the main wdw
17060 rem  * xsize% = x size of main window (NOT subwindow)
17070 rem  * menu_selkeys$ holds the selkeys to exclude (string with upper cased keys)
17080 rem  *      set to "" if no selkeys wished, set to " " if no selkeys are excluded
17090 rem  * appw_sections% holds the nbr of sections to show
17100 rem  * main_cty% (DIMed here) is the  control sections array
17110 rem  * main_mfl% (DIMed here) is the menu items flag array
17120 rem
17130 rem Params:
17140 rem  * app_addr is the address of the appsub window, but 0 on first call
17150 rem  * subwinarry$ holds the data (2 dimensional string array)
17160 rem  * x, y_csize% are the csizes of objects in the appsub, standard values
17170 rem  * use_apm2% whether we use (=1) AP_MAKE2 or not (=0)
17180 rem  * hit_is_do% if hit should be = do
17190 rem  * sizex%= wished x size, leave at 0 if automatic size wished
17200 rem  * origx%= wished x orig, leave at 0 if automatic orig wished
17210 rem
17220 local temp%,selk%,app_attrs%(3,1),xs%,xo%
17230   if app_addr:rechp app_addr
17240   dim main_cty%(0):dim main_mfl%(0,0)
17250   temp%=x_csize%*16                               : rem x csize into upper nibble
17260   temp%=(temp%+y_csize%)*256            : rem y into lower, all into upper byte
17270   temp%=temp%+appw_sections%            : rem temp% is changed by the call to fen_app
17280   if menu_selkeys$=""
17290     selk%=0                                       : rem use no selkeys
17300   else
17310     selk%=1
17320   endif
17330   if hit_is_do%:selk%=selk%+256         : rem hit should be do
17340   if sizex%<1
17350     xs%=xsize%-16
17360   else
17370     xs%=sizex%
17380   endif
17390   if origx%<1
17400     xo%=0
17410   else
17420     xo%=origx%
17430   endif
17440   if use_apm2%
17450     app_addr=ap_make2(selk%,xs%,rows%,xo%,app_y_orig%,temp%,subwinarray$)
17460   else
17470     app_addr=ap_make(selk%,xs%,rows%,xo%,app_y_orig%,temp%,subwinarray$,menu_selkeys$&" ")
17480   endif                                 : rem on return temp%=nbr of objects
17490   IF app_addr = 0: RETurn 0             : rem  error, return 0
17500 :
17510   dim main_cty%(appw_sections%,2)       : rem control defn
17520   main_cty%(0,0)=1                      : rem at start show 1 section
17530   if temp%>rows%
17540     main_cty%(1,2)=rows%                : rem nbr of rows to show
17550   else
17560     main_cty%(1,2)=temp%                : rem there are less objects than rows
17570   endif
17580   main_cty%(1,2)=rows%
17590   if appw_sections%=2:main_cty%(2,2)=2
17600   if temp%
17610      dim main_mfl%(temp%-1,0)                     : rem flag array if there are any objects
17620   end if
17630   scroll_arrows rows%,temp%,app_addr,main_cty%
17640   return app_addr
17650 end define mk_main_app
17660 :
17670 def proc make_standard_sprites
17680 rem This makes standard move, sleep and wake sprites and sets the
17690 rem GLOBAL vars move_sprite,, sleep_sprite, wake_sprite and size_sprite to them.
17700 rem If there are system sprites, these are used.
17710 rem This also makes the "main_sprite" pointer sprite.
17720 :
17730   espace_vide=ALCHP(100)         : rem for pointers with no mask
17740 :
17750 restore 17750
17760   main_sprite=RD_SPRT(0)         : REMark ici un masque normal
17770     data 11,13,6,5,4
17780     data '     www     '
17790     data '     waw     '
17800     data '     waw     '
17810     data '     waw     '
17820     data 'wwwwwa awwwww'
17830     data 'waaaa   aaaaw'
17840     data 'wwwwwa awwwww'
17850     data '     waw     '
17860     data '     waw     '
17870     data '     waw     '
17880     data '     www     '
17890 :
17900   if sys_tspr_addr(6)<>0
17910     move_sprite=6
17920   else
17930 restore 17930
17940     move_sprite=RD_SPRT(1)         : REMark ici un masque 0
17950     data 10,14,5,4,4
17960     data 'aaaaaaaaaa    '
17970     data 'awwwwwwwwa    '
17980     data 'awwrrrrwwa    '
17990     data 'awwrrrrwwaaaaa'
18000     data 'awwrrwwwwwwwwa'
18010     data 'awwwwwwwwrrwwa'
18020     data 'aaaaawwrrrrwwa'
18030     data '    awwrrrrwwa'
18040     data '    awwwwwwwwa'
18050     data '    aaaaaaaaaa'
18060   endif
18070 :
18080   if sys_tspr_addr(10)<>0
18090     sleep_sprite=10
18100   else
18110 restore 18110
18120     sleep_sprite= RD_SPRT(1)             : REMark ici un masque 0
18130     data 7,15,0,0,4
18140     data 'wwwww          '
18150     data '   w           '
18160     data '  w  wwww      '
18170     data ' w     w       '
18180     data 'wwwww w  wwww  '
18190     data '     wwww  w   '
18200     data '          wwww '
18210   endif
18220 :
18230   if sys_tspr_addr(11)<>0
18240     wake_sprite=11
18250   else
18260 restore 18260
18270     wake_sprite=RD_SPRT(1)          : REMark ici un masque 0
18280     data 9,14,0,0,4
18290     data "             w"
18300     data "            w "
18310     data "      w   ww  "
18320     data "     ww www   "
18330     data "    wwwwww    "
18340     data "   www ww     "
18350     data "  w   w      "
18360     data " w            "
18370     data "w             "
18380   endif
18390 :
18400   if sys_tspr_addr(7)<>0
18410     size_sprite=7
18420   else
18430 restore 18430
18440     size_sprite=RD_SPRT(1)
18450     data 9,14,5,4,4
18460     data 'aaaaaaaaaaaaaa'
18470     data 'awwwwwwwwwwwwa'
18480     data 'awwrrrrrrrrwwa'
18490     data 'awwrrrrrrrrwwa'
18500     data 'awwrrwwwwwwwwa'
18510     data 'awwrrwwrrrrwwa'
18520     data 'awwrrwwrrrrwwa'
18530     data 'awwwwwwwwwwwwa'
18540     data 'aaaaaaaaaaaaaa'
18550   endif
18560 :
18570 end def make_standard_sprites
18580 :
18590 DEFine PROCedure warn_make
18600 rem makes warning & info window
18610 rem uses global vars sp.xxx
18620 rem SETS the global var warning_width% (nbr of chars in one line in wdw)
18630 local lys%,warn_lot,warn_iot1,warn_iwt
18640 local x%,y%,warning_paper,warning_brd
18650 restore 18650
18660   x%=200:y%=82
18670   lys%=10
18680   DIM warn_lfl%(1)
18690   warn_lot=RD_LOT(std_iattr,1)
18700     DATA 30,lys%,4,4,0,0,cancel$,text+retr,'ESC'
18710     DATA 30,lys%,x%-34,4,0,0,'O',text+retr,"OK"
18720 :
18730   warn_iot1=RD_IOT (0)
18740     DATA 12*9,10,0,1,text,sp.errfg,2,0,'Attention'
18750 :
18760   warn_iwt=RD_IWT(1)
18770     DATA x%-16,y%-32,8,24
18780     DATA 0,1,sp.winbd,sp.errbg
18790     DATA 0
18800 :
18810     DATA 110,12,(x%-110) div 2,4
18820     DATA 0,1,sp.winbd,sp.errbg
18830     DATA warn_iot1
18840 :
18850   warn_defn=RD_WDEF
18860     DATA 2,1,sp.winbd,sp.errbg
18870     DATA x%,y%,0,0
18880     DATA main_sprite,warn_lot,warn_iwt,0
18890 :
18900   warning_width%=(x%-16) div 6                    : rem width of warning window in chars
18910   info_is_pulled_down%=0
18920   warn_wdw_addr=peek_l(warn_defn+100)+20: rem ptr to 2nd info wdw
18930  rem warn_wdw_addr=peek_l(warn_wdw_addr+16): rem ptr to object list
18940 END DEFine warn_make
18950 :
18960 DEFine PROCedure about_make (titre$,version$)
18970 local lxs%,lys%,xesp%,inf1y%,abt_lot,longueur_titre%,titre_x%
18980 local abt_iwt,abt_iot1,abt_iot2
18990   ab_xt%=200:ab_yt%=120    : REMark tailles x et y: la taille x devrait
19000                                    : REMark ‘tre un chiffre divisible par 4
19010   lxs%=24:lys%=10                    : REMark tailles x et y pour postes standard
19020   inf1y%=lys%+4            : REMark posi. y de la fen. d'inf. intƒrieure
19030   xesp%=lxs%+2
19040   nbr_post%=0                      : REMark nombre de postes dans un coin
19050 :
19060 restore 19060
19070 wolfsoft_sprite=rD_SPrT(0)
19080     DATA 23,51,0,0,4
19090     DATA 'rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr'
19100     DATA 'rrgggggggggggggggggggggggggggggggggggggggggggggggrr'
19110     DATA 'rrggggggggrrrrrrrrrrrrrrrrgggggggggggggggggggggggrr'
19120     DATA 'rrgggggggggggggggggggggrgggggggggggggggggggggggggrr'
19130     DATA 'rrggggggggggggggggggggrggggggggggggggggggggggggggrr'
19140     DATA 'rrggggggggagggggagggrrrrrrrrrrrrrggaaaaaaaaggggggrr'
19150     DATA 'rrggggggggagggggaggggggggggggggggggagggggggggggggrr'
19160     DATA 'rrggggggggaggaggaggaaaaaaaggaggggggaaaaaaagggggggrr'
19170     DATA 'rrggggggggagaaagaggaawwaaaggaggggggagggggggggggggrr'
19180     DATA 'rrggggggggaaagaaaggaawwwwaggaggggggagggggggggggggrr'
19190     DATA 'rrggrrrrrgaagggaaggawwwwaaggaggggggagggggrrrrrrrgrr'
19200     DATA 'rrgrgggggrgggggggggaaawwaaggaggggggggggrrrgggggggrr'
19210     DATA 'rrgrggggggrggggggggaaaaaaaggaaaaaagggrrggrgggggggrr'
19220     DATA 'rrgrgggggggggggggrrrgggggggggggrrrggrggggrgggggggrr'
19230     DATA 'rrggrrrrrrggggggrgggrrgggggggrrggggggggggrgggggggrr'
19240     DATA 'rrggggggggrrrgggrgggggrrgggrrggggggggggggrgggggggrr'
19250     DATA 'rrgggggggggggrggrgggggggrggrgggggggggggggrgggggggrr'
19260     DATA 'rrggggggggggggrgrggggggggrgrrrrrrrgggggggrgggggggrr'
19270     DATA 'rrgrggggggggggrgrggggggggrgrgggggggggggggrgggggggrr'
19280     DATA 'rrggrgggggggrrgggrggggggrggrgggggggggggggrgggggggrr'
19290     DATA 'rrgggrrrrrrrggggggrrrrrrgggrgggggggggggggrgggggggrr'
19300     DATA 'rrgggggggggggggggggggggggggggggggggggggggggggggggrr'
19310     DATA 'rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr'
19320 :
19330   yinf1y%=inf1y%+4:
19340 :
19350   DIM abt_lfl%(0)
19360   abt_lot=RD_LOT(std_iattr,0)
19370     DATA ab_xt%-16,lys%,8,ab_yt%-lys%-8,0,0,cancel$,text+retr,'Super!'
19380 :
19390 : REMark  D'abord le titre qui est un objet d'une sous-fen‘tre d'info.
19400 :
19410   longueur_titre%=LEN(" Version "&version$)*6               : REMark on calcule la taille et la
19420   titre_x%=INT((ab_xt%-longueur_titre%)/2)  : REMark position x de cet objet
19430   abt_iot2=RD_IOT(1)
19440     DATA longueur_titre%,lys%,4,8,text,sp.winfg,0,0," Version "&version$
19450     DATA 52,24,ab_xt%-60,40,sprite,0,wolfsoft_sprite
19460   longueur_titre%=LEN(titre$)*6     : REMark on calcule la taille et la
19470   titre_x%=INT((ab_xt%-longueur_titre%)/2)  : REMark position x de cet objet
19480   abt_iot1=RD_IOT(0)
19490     DATA longueur_titre%,lys%,4,INT((lys%-10)/2),text,sp.titlefg,0,0,titre$
19500   abt_iwt=RD_IWT(2)               : REMark on veut 3 sous-fen. d'info
19510 REMark d'abord la fen‘tre contenant la barre entourant le titre
19520     DATA ab_xt%-8-(2*nbr_post%*xesp%),lys%+2,xesp%*nbr_post%+4,0  : REMark taille x,y, origines x,y
19530     DATA 0,0,sp.infwinbd,sp.titlebg     : REMark ombre, taille & couleur bordure
19540                                    : REMark puis couleur papier
19550     DATA 0                         : REMark pointeur vers objets
19560 REMark maintenant la fen‘tre qui contient le titre
19570     DATA longueur_titre%+8,lys%,titre_x%-2,2   : REMark on utilise titre_x% etc
19580     DATA 0,0, sp.infwinbd,sp.titletextbg
19590     DATA abt_iot1                 : REMark un objet, le titre
19600 REMark maintenant la fen‘tre de la bordure intƒrieure
19610     DATA ab_xt%-8,ab_yt%-inf1y%-2,4,inf1y%
19620     DATA 0,1,sp.infwinbd,sp.infwinbg
19630     DATA abt_iot2
19640   abt_defn=RD_WDEF
19650     DATA 2,1,sp.winbd,sp.winbg: REMark ombre, larg. & coul. bord., coul. papier
19660     DATA ab_xt%,ab_yt%,10,10 : REMark taille x,y et position pointeur
19670     DATA main_sprite,abt_lot,abt_iwt,0
19680 :
19690 end def about_make
19700 :
19710 DEFine PROCedure about (datet$)
19720   LOCal loop%,item%,dummy%,chan%
19730   DR_PULD abt_defn,-1,-1,abt_lfl%
19740   chan%=fopen('con')
19750   dr_iwdf#chan%,abt_defn,2
19760   wm_ink#chan%,sp.infwinfg
19770   wm_paper#chan%,sp.infwinbg
19780   at#chan%,4,2
19790   print#chan%,"Copyright (C) "
19800   at#chan%,5,2
19810   print#chan%, datet$
19820   at#chan%,6,2
19830   print#chan%,"Wolfgang H. Lenerz"
19840   close#chan%
19850   REPeat loop%
19860     RD_PTR abt_defn,item%,dummy%,dummy%,dummy%,dummy%,abt_lfl%
19870     SELect ON item%
19880             =0       : EXIT loop%
19890     END SELect
19900   END REPeat loop%
19910   DR_UNST abt_defn
19920 END DEFine about
19930 :
19940 def proc do_popup(string$)
19950 rem this pops up a small "hint" window showing the string$ passed
19960 rem as parameter.
19970 rem The string MUST be 1 line long and MUST fit
19980 rem inside the window (YOU must make sure of that!)
19990   do_popup2 string$,0
20000 end def do_popup
20010 :
20020 def proc popup_make
20030 rem make a small window defn
20040 local x%,y%,p_iot,popsub(0)
20050 restore 20050
20060   p_sprt=rd_sprt(0)                     : rem make an invisible pointer, all transparent
20070     data 1,2,0,0,4
20080     data '  '
20090   x%=14                                 : rem bogus window sizes
20100   y%=10
20110   popsub(0)=rd_appw                     : rem the info wdw
20120     DATA x%,y%,0,0
20130     DATA 0,0, sp.hintbd,sp.hintbg
20140     DATA 0,""
20150   popup_defn=RD_WDEF                    : rem the working defn
20160     DATA 0,1,sp.hintbd,sp.hintbg        : rem no shadow, border size & col, paper col
20170     DATA x%,y%,40,2
20180     DATA p_sprt,0,0,mk_awl(popsub)
20190 end def popup_make
20200 :
20210 def proc do_popup2(string$,main_defn)
20220 rem This pops up a small "hint" window showing the string$ passed
20230 rem as parameter.
20240 rem main_defn is the working defintion of the window over which the hint
20250 rem window is to hover. Position the pointer there where you need it before
20260 rem calling this.
20270 rem If the string is too long to fit into the window (which can only be as long
20280 rem as the outline of the working defn) then the string is split up at the
20290 rem first convenient space and put on a second line, and so on.
20300 rem If this would lead to the hint window being too high, only as many
20310 rem lines as possible will be displayed.
20320 rem !!!!!
20330 rem This presumes that a char is 10 pixels high & 6 pixels wide (standard ql 6x10 matrix)..
20340 rem !!!!!
20350 rem The string may contain the char chr$(10) - there will be a newline.
20360 rem
20370 rem note : do not try to pass a screen chaneel, open & close one here.
20380 rem
20390 local dummy%,lp%,address,con%,temp%,lastspace%,xs%,ys%,temp$
20400 local hint$(10),slen% ,maxlength%,popup_lfl%(0),popup_mfl%(0,0)
20410   if string$="":return                  : rem empty string, do nothing
20420   strip_spaces string$                 : rem no spaces at ends
20430   con%=fopen("con")
20440   if main_defn<>0
20450     xs%=peek_w (main_defn+32)
20460     ys%=peek_w(main_defn+34)            : rem get max sizes the hint wdw may have
20470   else
20480     scr_size#con%,xs,ys%
20490   endif
20500   xs%=(xs%-4) div 6                     : rem max nbr of chars in 1 line
20510   ys%=(ys%-4) div 10                    : rem max nbr of lines in wdw
20520   if xs%=0 or ys%=0:close#con%:return   : rem nothing will really fit, just leave
20530   dim hint$(ys%,xs%)                    : rem array to contain string
20540   rem now parse the string, find newlines, make sure of string length
20550   dummy%=1                              : rem start of current string section
20560   temp%=0                               : rem line
20570   slen%=0                               : rem current length of string
20580   for lp%=1 to len(string$)
20590     if string$(lp%)=chr$(10)
20600       hint$(temp%)=string$(dummy% to lp%-1): rem cut string here
20610       temp%=temp%+1
20620       if temp%=ys%:exit lp%             : rem max nbr of lines reached
20630       dummy%=lp%+1                      : rem this is where new start of string is
20640       lastspace%=lp%
20650     else
20660       if string$(lp%)=" "
20670         lastspace%=lp%                  : rem this is where last space is
20680       endif
20690     endif
20700     slen%=slen%+1                       : rem one more char
20710     if slen% > xs%
20720       hint$(temp%)=string$(dummy% to lastspace%-1) : rem too many chars in line
20730       slen%=0
20740       temp%=temp%+1                     : rem we need nother line
20750       if temp%=ys%:exit lp%             : rem max nbr of lines reached
20760       dummy%=lastspace%+1
20770     endif
20780   end for lp%
20790   if temp%<ys%
20800      hint$(temp%)=string$(dummy% to)       : rem add last part
20810      temp%=temp%+1
20820   endif
20830   maxlength%=0
20840   for lp%=0 to temp%
20850     temp$= hint$(lp%)
20860     strip_spaces temp$                 : rem use intermediary var, because of QLIB
20870     if maxlength%<len(temp$):maxlength%=len (temp$)
20880   end for lp%
20890   lp%=(maxlength%*6)+4                  : rem hint window length
20900   poke_w popup_defn+32,lp%              : rem set window xsize
20910   poke_w popup_defn+34,temp%*10+2       : rem
20920   address=peek_l(popup_defn+112)        : rem ptr to app sub wdw...
20930   address=peek_l(address)               : rem ...now
20940   poke_w address,lp%-2                  : rem set its length
20950   poke_w address+2,temp%*10             : rem set its height
20960   dr_puld popup_defn,-1,-1,popup_lfl%,popup_mfl%
20970   dr_awdf#con%,popup_defn,0             : rem pull wdw over info wdw
20980   wm_paper#con%,sp.hintbg
20990   wm_ink#con%,sp.hintfg
21000   for lp%=0 to dimn(hint$,1)
21010     if hint$(lp%)<>"":temp$=hint$(lp%):strip_spaces temp$:print#con%,temp$
21020   end for lp%
21030   temp%=0:slen%=0:xs%=0:ys%=0:dummy%=0
21040   RD_PTR popup_defn,temp%,dummy%,slen%,xs%,ys%,popup_lfl%,popup_mfl%: rem comes back immediatley
21050   RD_PTR popup_defn,temp%,dummy%,slen%,xs%,ys%,popup_lfl%,popup_mfl%
21060   close#con%
21070   dr_unst popup_defn
21080 end def do_popup2
21090 :
21100 DEFine FuNction RD_SPRT(drap%)
21110 REMark drap% determine si masque 0
21120   LOCal tmp_patt$(32,32)
21130   LOCal xs,ys,xo,yo, md, l
21140   READ ys,xs,xo,yo,md
21150   DIM tmp_patt$(ys,xs)
21160   FOR l=0 TO ys-1:READ tmp_patt$(l)
21170   l=ALCHP(SPRSP(xs,ys))
21180   SPSET l,xo,yo,md,tmp_patt$(0 TO ys-1,1 TO xs)
21190   IF drap%
21200     POKE_L l+16,espace_vide-(l+16)
21210   END IF
21220   RETurn l
21230 END DEFine RD_SPRT
21240 :
21250 DEFine FuNction RD_WDEF
21260 rem read window defn
21270   LOCal ldef%(3), lspr, lloose, linfo, lappl, lattr%(3)
21280   RD_WATT lattr%
21290   READ ldef%(0), ldef%(1), ldef%(2), ldef%(3)
21300   READ lspr, lloose, linf, lappl
21310   RETurn MK_WDEF (ldef%, lattr%, lspr, lloose, linf, lappl)
21320 END DEFine RD_WDEF
21330 :
21340 DEFine FuNction RD_LOT (lattr,nitem)
21350   LOCal count(3)
21360   LOCal item, ltyp, a$, lsk$
21370   LOCal ldef%(nitem,6), lptr(3,nitem), lstr$(nitem,85)
21380   lsk$=''
21390   FOR item = 0 TO nitem
21400     READ ldef%(item,0), ldef%(item,1), ldef%(item,2), ldef%(item,3)
21410     READ ldef%(item,4), ldef%(item,5)
21420     READ a$: lsk$=lsk$ & a$
21430     READ ltyp
21440     ldef%(item,6)=ltyp: ltyp=(ltyp MOD 256)/2
21450     IF ltyp>10 or ltyp <0:ltyp=0
21460     IF ltyp
21470       READ lptr(ltyp,count(ltyp))
21480     ELSE
21490       READ lstr$(count(0))
21500     END IF
21510     count(ltyp)=count(ltyp)+1
21520   END FOR item
21530   RETurn MK_LIL (lattr, ldef%(TO, 0 TO 1), ldef%(TO, 2 TO 3), ldef%(TO, 4 TO 5), lsk$, ldef%(TO, 6), lstr$, lptr(1), lptr(2), lptr(3))
21540 END DEFine RD_LOT
21550 :
21560 DEFine FuNction RD_IWT(nitem)
21570   LOCal item,mc1
21580   LOCal ldef%(nitem,3), latt%(nitem,3), lptr(nitem)
21590   FOR item = 0 TO nitem
21600     READ ldef%(item,0), ldef%(item,1), ldef%(item,2), ldef%(item,3)
21610     READ latt%(item,0), latt%(item,1), latt%(item,2), latt%(item,3)
21620     READ lptr(item)
21630   END FOR item
21640   RETurn MK_IWL (ldef%, latt%, lptr)
21650 END DEFine RD_IWT
21660 :
21670 DEFine FuNction RD_IOT(nitem)
21680   LOCal count(3)
21690   LOCal item, ltyp, work1, work2
21700   LOCal ldef%(nitem,4), lptr(3,nitem), lstr$(nitem,85)
21710   FOR item = 0 TO nitem
21720     READ ldef%(item,0), ldef%(item,1), ldef%(item,2), ldef%(item,3)
21730     READ ltyp
21740     ldef%(item,4)=ltyp:  ltyp=(ltyp MOD 256)/2
21750     IF ltyp >10:ltyp=0
21760     IF ltyp
21770       READ lptr(0,item),lptr(ltyp,count(ltyp))
21780     ELSE
21790       if mycolour_mode%=2
21800           read work1,work2,work3
21810           lptr(0,item)=WL_4_IOL(work1,work2,work3)
21820       else
21830           READ work1
21840           READ work2: work1=work1*256+work2
21850           READ work2: lptr(0,item)=work1*256+work2
21860       endif
21870       READ lstr$(count(0))
21880     END IF
21890     count(ltyp) = count(ltyp) + 1
21900   END FOR item
21910   RETurn MK_IOL (ldef%(TO, 0 TO 1), ldef%(TO, 2 TO 3), lptr(0), ldef%(TO, 4), lstr$, lptr(1), lptr(2), lptr(3))
21920 END DEFine RD_IOT
21930 :
21940 DEFine PROCedure RD_IATT (lattr)
21950   LOCal i
21960   READ lattr(0,0), lattr(0,1)
21970   FOR i=1 TO 3: READ lattr(i,0), lattr(i,1), lattr(i,2), lattr(i,3)
21980 END DEFine RD_IATT
21990 :
22000 DEFine PROCedure RD_WATT (lattr%)
22010   READ lattr%(0), lattr%(1),lattr%(2),lattr%(3)
22020 END DEFine RD_WATT
22030 :
22040 DEFine FuNction RD_APPW
22050   LOCal ldef%(3), lspr, sk$, lattr%(3)
22060   READ ldef%(0), ldef%(1), ldef%(2), ldef%(3)
22070   RD_WATT lattr%
22080   READ lspr, sk$
22090   RETurn MK_APPW (ldef%, lattr%, lspr,sk$)
22100 END DEFine
22110 :
