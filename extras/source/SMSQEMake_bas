10 REMark $$asmb=dev8_extras_source_outptr_bin,0,10
20 REMark $$asmb=dev1_booty_qptr_bin,50,172
30 REMark $$asmb=dev8_extras_source_SMSQEMake_bin,0,10
40 REMark $$stak=20000
50 rem compiled with the basic_linker
60 :
70 compiled=not is_open(#0)
80 if not compiled
90   check_for_PE
100   clear:clchp
110   scr_size#0,maxx%,maxy%
120   maxy%=maxy%-28
130   outln#0,maxx%,maxy%,0,28
140   wset -1
150 else
160   open#1,"con"
170   check_for_PE
180   scr_size#1,maxx%,maxy%
190 end if
200 :
210 init
220 main
230 stop
240 :
250 def proc check_for_PE
260   if p_env(#1)<>2
270     cls#1:ink#1,2:print#1,"This software works only in the pointer environment"
280     a$=inkey$(#1,-1)
290     stop
300   end if
310 end def check_for_PE
320 :
330 DEFine PROCedure init
340 LOCal temp%,targets%,start%,lp%,v$
350   text=0:sprite=2:blob=4:pattern=6
360   retr=256:retn=-256:sous1=254:sous2=252:sous3=250
370   rem normal: hit = selects/deselects, do = returns & leaves selected
380   rem retr = return even on hit, reset item to available after,
390   rem retn = return even on hit, hit selects/deselects, do selects
400 :
410   hit$=CHR$(1):do$=CHR$(2):cancel$=CHR$(3):sleep$=CHR$(7):wake$=CHR$(8)
420   help$=CHR$(4):move$=CHR$(5):size$=CHR$(6):cr$=CHR$(10)
430 :
440   make_standard_sprites
450   colourway%=SMSCFG(2)                  : rem use first syspals
460   if colourway%>3 or colourway%<0:colourway%=0
470   temp%=set_colours% (2)      : rem always try to set highest colours
480   make_my_palette colourway%  : rem set colours according to system palette
490 :
500 restore 500
510 :
520 : rem make loose item attributes
530 :
540   DIM std_iattr(3,3)
550   RD_IATT std_iattr
560     DATA 1,sp.litemhigh : rem current item border size & colour
570     DATA sp.litemunabg,sp.litemunafg,0,0 : rem unavailable item paper & ink
580     DATA sp.litemavabg,sp.litemavafg,0,0 : rem available     "    "       "
590     DATA sp.litemselbg,sp.litemselfg,0,0 : rem selected
600 :
610   targets%=0
620   rem IF NOT compiled:cmd$="-tj-tg-st-mk-as"
630   quit_always%=0
640   quit_no_errors%=0
650   autostart%=0
660   do_make_it%=0
670   force_assembly$=""
680   delete_first%=0
690   select_all%=0
700   autochangesize%=(SMSCFG(3)=="Yes")
710   IF cmd$<>''
720       IF '-qa' INSTR cmd$:quit_always%=1
730       IF '-q0' INSTR cmd$:quit_no_errors%=1
740       IF '-as' INSTR cmd$:autostart%=1
750       IF '-mk' INSTR cmd$:do_make_it%=1
760       IF '-de' INSTR cmd$:delete_first%=1
770       IF '-sa' INSTR cmd$:select_all%=1
780       IF '-tg' INSTR cmd$:targets%=targets%+1 : rem Generic
790       IF '-ti' INSTR cmd$:targets%=targets%+2 : rem Atari
800       IF '-to' INSTR cmd$:targets%=targets%+4 : rem gOld
810       IF '-tq' INSTR cmd$:targets%=targets%+8 : rem Q40
820       IF '-tx' INSTR cmd$:targets%=targets%+16 : rem qXl
830       IF '-tu' INSTR cmd$:targets%=targets%+32 : rem aUrora
840       IF '-tj' INSTR cmd$:targets%=targets%+64 : rem Java
850       IF '-tr' INSTR cmd$:targets%=targets%+128 : rem ptRgen
860       IF '-tc' INSTR cmd$:targets%=targets%+256 : rem qpC
870       IF '-t8' INSTR cmd$:targets%=targets%+512 : REMark q68
880       IF '-ta' INSTR cmd$:targets%=255+256+512    : rem all targets
890       IF '-fa' INSTR cmd$:force_assembly$=" -f": rem force assembly of all files
900   ELSE
910     targets%=1
920   END IF
930   make_my_data targets%
940   xsize%=500                                      : rem window x size divisible by 4!
950   ysize%=200                                      : rem provisional y size%
960   rows%=-1                                        : rem make rows dependent on wdw size
970   rep$=SMSCFG(1)                        : rem dir with files
980   make_main_wdw
990   IF (select_all%):main_lfl%(all_it%)=129:set_statusses
1000   start%=1
1010   FOR lp%=target_its% TO target_its%+9
1020     IF targets% && start%: main_lfl%(lp%)=129
1030     start%=start%*2
1040   END FOR lp%
1050   IF do_make_it%:main_lfl%(make_it%)=129
1060   IF delete_first%:main_lfl%(del_it%)=129
1070 :
1080   warn_make
1090   v$=smscfg(0)
1100   about_make "SMSQEMake",v$
1110 :
1120 END DEFine init
1130 :
1140 define procedure main
1150 local lp%,item%,event%,swnum%,xrel%,yrel%,item%,lp2%,tot%,errors%
1160   if compiled
1170      dr_ppos main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
1180   else
1190      dr_puld main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
1200   end if
1210   pos_ptr main_defn,40*65536+20,1
1220   if autostart%
1230      errors%=do_the_work%
1240      if quit_always%:stop
1250      if quit_no_errors% and not errors%:stop
1260      if errors%
1270           errors%=warning%("There were errors"&chr$(10)&"check the highlit items",0,"errors!")
1280      endif
1290   endif
1300   repeat lp%
1310     rd_ptr main_defn,item%,swnum%,event%,xrel%,yrel%,main_lfl%,main_mfl%,main_cty%
1320     if swnum%= -1
1330       select on item%
1340             =esc%     : exit lp%                            : remark quit prog
1350             =move_it% : ch_win main_defn                    : remark move
1360             =size_it% : change_size xrel%,yrel%   : remark change size
1370             =sleep_it%: button main_defn,main_lfl%,main_mfl%,main_cty%,"SMSQ/E Make"
1380             =all_it%  : set_statusses             : remark set all appsub item statusses
1390                           main_cty%(0,1)=1                  : remark and redraw
1400             =go_it%   : errors%=do_the_work%
1410                           if errors%
1420                                errors%=warning%("There were errors"&chr$(10)&"check the highlit items",0,"errors!")
1430                           endif
1440                           main_lfl%(del_it%)=1
1450             =dir_it%  : make_new_dir item%
1460             =target_its% to make_it%-1,alltargets_it%
1470                           if item%=alltargets_it%
1480                                machines%=-1
1490                                for lp2%= target_its% to make_it%-1
1500                                   main_lfl%(lp2%)=129
1510                                end for lp2%
1520                            else
1530                               start%=1:machines%=0
1540                               for lp2%=target_its% to make_it%-1
1550                                   if main_lfl%(lp2%):machines%=machines%+start%
1560                                   start%=start%*2
1570                               end for lp2%
1580                           endif
1590                           make_my_data machines%  : remark make data arrays
1600                           if autochangesize%
1610                               autochange_size xrel%,yrel%
1620                           else
1630                               app_addr=mk_main_app(app_addr,mdata$,0,0,1,0,0,0) : rem make apsub wdw
1640                               main_app_list=app_addr+180
1650                               ap_in main_defn,main_app_list : remark put it in
1660                               dr_wdrw main_defn:main_cty%(0,1)=1 : remark and redraw entire wdw
1670                           end if
1680             =info_it% : about "2013-2017"
1690       end select
1700     end if
1710   end repeat lp%
1720   dr_unst main_defn
1730   if compiled:close#1
1740   rechp espace_vide
1750 end define main
1760 :
1770 DEFine FuNction do_the_work%
1780 REMark this tries to compile all of the selected files
1790 REMark if the file was compiled OK, status (of the link file) set to available
1800 REMark if the file was not compiled ok, status left selected
1810 LOCal lp%,bound%,a$,my_error%,tot_err%
1820   bound%=DIMN(main_mfl%,1)              : REMark number of items to check
1830   tot_err%=0
1840   IF main_lfl%(del_it%)<>0
1850      EW "dev8_extras_del_all_bas";"auto stop"
1860   END IF
1870   FOR lp%=0 TO bound%
1880     a$=mdata$(lp%+1)                              : REMark potential file to compile
1890     IF a$(1)<>"*" AND main_mfl%(lp%,0)
1900        a$=rep$&a$                       : REMark add dir
1910        my_error%=compile_and_check% (a$): REMark try to compile
1920        IF NOT my_error%
1930              main_mfl%(lp%,0)=1
1940              DR_ADRW main_defn,0,main_mfl%,main_cty%
1950        END IF
1960        tot_err%=tot_err%+my_error%
1970     END IF
1980   END FOR lp%
1990   main_cty%(0,1)=1
2000   main_lfl%(go_it%)=1
2010   IF main_lfl%(make_it%)=128 AND NOT tot_err%:make_targets
2020   RETurn tot_err%
2030 END DEFine do_the_work%
2040 :
2050 DEFine FuNction compile_and_check% (a$)
2060 REMark this tries to compile a file, using the "make" prog
2070 REMark this returns 1 if errors, else 0
2080 LOCal chan%,is_ok$,ch_len
2090   ch_len=EXEPF_W ("make";a$&" -w -l"&force_assembly$)                   : REMark exec make & wait
2100   IF ch_len<>0
2110      EXEC_W "make";a$&" -w -l"&force_assembly$                 : REMark exec make & wait
2120   END IF
2130   is_ok$=a$(1 TO LEN(a$)-4)             : REMark file name w/o extension
2140   chan%=FOP_IN(is_ok$&'log')            : REMark open log file
2150   IF chan%<0:RETurn 1                             : REMark can't even open it!
2160   ch_len=FLEN(#chan%)                             : REMark file length
2170   GET#chan%\ch_len-10                             : REMark this is where error report is
2180   INPUT#chan%,is_ok$                              : REMark get it
2190   CLOSE#chan%
2200   IF NOT is_ok$=="No errors"
2210     RETurn 1                                      : REMark anything other than "no errors" signals errors
2220   ELSE
2230     RETurn 0
2240   END IF
2250 END DEFine compile_and_check%
2260 :
2270 DEFine PROCedure make_new_dir (poste%)
2280 REMark get athe new dir where the files are located
2290 LOCal quel_rep$
2300   IF MENU_OK
2310     quel_rep$= DIR_SELECT$("The Files are where?",,10,10,main_coul%,app_coul%)
2320   ELSE
2330     quel_rep$=getstr$(poste%,0,main_defn,a_lire$)           : REMark use menu extns if possible
2340   END IF
2350   IF LEN (quel_rep$) >= 5
2360      rep$=quel_rep$(1 TO 5)
2370   END IF
2380   CH_ITEM main_defn,-1,poste%,-1,"",rep$
2390   main_lfl%(poste%)=main_lfl%(poste%)+1
2400 END DEFine make_new_dir
2410 :
2420 DEFine PROCedure make_my_data (what_machine%)
2430 REMark what_machine% = 1 -> generic
2440 REMark what_machine% = 2 -> atari
2450 REMark what_machine% = 4 -> Gold Card
2460 REMark what_machine% = 8 -> Qx0
2470 REMark what_machine% = 16 -> QXL
2480 REMark what_machine% = 32 -> aurora
2490 REMark what_machine% = 64 -> java
2500 REMark what_machine% = 128 -> ptrgen
2510 REMark what_machine% = 256 -> qpc
2520 REMark what_machine% = 512 -> q68
2530 REMark these may be combined
2540   DIM mdata$(250,50)
2550   REMark first make generic data
2560   data_count%=1                         : REMark general data count (global var)
2570   IF what_machine%&&1
2580     generic_data                        : REMark set up generic data
2590     read_my_datas                       : REMark and read it
2600   END IF
2610   IF what_machine%&&2
2620      atari_data                         : REMark set up machine specific data....
2630      read_my_datas                      : REMark and read it
2640   END IF
2650   IF what_machine%&&4
2660      gc_data                                      : REMark set up machine specific data....
2670      read_my_datas                      : REMark and read it
2680   END IF
2690   IF what_machine%&&8
2700      q40_data                                     : REMark set up machine specific data....
2710      read_my_datas                      : REMark and read it
2720   END IF
2730   IF what_machine%&&16
2740      qxl_data                                     : REMark set up machine specific data....
2750      read_my_datas                      : REMark and read it
2760   END IF
2770   IF what_machine%&&32
2780      aurora_data                        : REMark set up machine specific data....
2790      read_my_datas                      : REMark and read it
2800   END IF
2810   IF what_machine%&&64
2820      java_data                                    : REMark set up machine specific data....
2830      read_my_datas                      : REMark and read it
2840   END IF
2850   IF what_machine%&&128
2860      ptrgen_data                        : REMark set up machine specific data....
2870      read_my_datas                      : REMark and read it
2880   END IF
2890   IF what_machine%&&256
2900      qpc_data                                     : REMark set up machine specific data....
2910      read_my_datas                      : REMark and read it
2920   END IF
2930   IF what_machine%&&512
2940      q68_data                                     : REMark set up machine specific data....
2950      read_my_datas                      : REMark and read it
2960   END IF
2970 END DEFine make_my_data
2980 :
2990 DEFine PROCedure read_my_datas
3000 REMark reads datas into the global var mdata$
3010 REMark uses data_count% from make_my_data
3020 LOCal lp%
3030   REPeat lp%
3040     READ mdata$(data_count%)
3050     IF mdata$(data_count%)="":EXIT lp%
3060     data_count%=data_count%+1
3070   END REPeat lp%
3080 END DEFine read_my_datas
3090 :
3100 DEFine PROCedure generic_data
3110 restore 3110
3120   DATA '**** -- SMSQ Generic -- ****'
3130   DATA 'smsq_smsq_loader_link'
3140   DATA 'smsq_smsq_fh_link'
3150   DATA 'smsq_smsq_link'
3160   DATA 'smsq_smsq_cache_link'
3170   DATA 'smsq_sbas_link'
3180   DATA 'smsq_smsq_lang_link'
3190   DATA 'smsq_sbas_lang_link'
3200   DATA 'smsq_sbas_procs_link'
3210   DATA 'smsq_smsq_wman_link'
3220   DATA 'smsq_smsq_hotkey_link'
3230   DATA 'smsq_smsq_vers_link'
3240   DATA 'smsq_home_link'
3250   DATA 'smsq_recent_link'
3260   DATA 'smsq_smsq_1mb_link',''
3270 END DEFine generic_data
3280 :
3290 DEFine PROCedure q40_data
3300 restore 3300
3310   DATA '**** -- Q40/Q60 -- ****'
3320   DATA 'smsq_q40_hwinit_link'
3330   DATA 'smsq_q40_nasty_link'
3340   DATA 'smsq_q40_cache_link'
3350   DATA 'smsq_q40_cachemode_link'
3360   DATA 'smsq_smsq_cache40c_link'
3370   DATA 'smsq_q40_driver_ser_link'
3380   DATA 'smsq_q40_driver_dv3_link'
3390   DATA 'smsq_q40_driver_ql_link'
3400   DATA 'smsq_q40_driver_16_link'
3410   DATA 'smsq_q40_kbd_lang_link'
3420   DATA 'smsq_smsq_q40_link'
3430   DATA 'smsq_q40_sysspr_link',''
3440 END DEFine q40_data
3450 :
3460 DEFine PROCedure atari_data
3470 restore 3470
3480   DATA '**** -- Atari -- ****'
3490   DATA 'smsq_atari_hwinit_link'
3500   DATA 'smsq_atari_nasty_link'
3510   DATA 'smsq_atari_driver_ql_link'
3520   DATA 'smsq_atari_driver_mo_link'
3530   DATA 'smsq_atari_driver_ser_link'
3540   DATA 'smsq_atari_driver_dv3_link'
3550   DATA 'smsq_atari_kbd_lang_link'
3560   DATA 'smsq_atari_sysspr_link'
3570   DATA 'sys_boot_st_host_link',''
3580 END DEFine atari_data
3590 :
3600 DEFine PROCedure gc_data
3610 restore 3610
3620   DATA '**** -- (Super)GoldCard -- ****'
3630   DATA 'smsq_gold_host_link'
3640   DATA 'smsq_gold_hwinit_link'
3650   DATA 'smsq_gold_nasty_link'
3660   DATA 'smsq_gold_nasty_s_link'
3670   DATA 'smsq_gold_driver_ql_link'
3680   DATA 'smsq_gold_driver_8_link'
3690   DATA 'smsq_gold_driver_most_link'
3700   DATA 'smsq_gold_driver_nd_link'
3710   DATA 'smsq_gold_driver_nds_link'
3720   DATA 'smsq_gold_driver_dv3_link'
3730   DATA 'smsq_gold_kbd_lang_link'
3740   DATA 'smsq_gold_kbd_abc_lng_link'
3750   DATA 'smsq_gold_kbd_abc_link'
3760   DATA 'smsq_gold_roms_link'
3770   DATA 'smsq_gold_qimi_link'
3780   DATA 'smsq_gold_sysspr_link',''
3790 END DEFine gc_data
3800 :
3810 DEFine PROCedure aurora_data
3820 restore 3820
3830   DATA '**** -- Aurora -- ****'
3840   DATA 'smsq_gold_host_link'
3850   DATA 'smsq_gold_hwinit_link'
3860   DATA 'smsq_gold_nasty_link'
3870   DATA 'smsq_gold_nasty_s_link'
3880   DATA 'smsq_aurora_driver_8_link'
3890   DATA 'smsq_gold_driver_ql_link'
3900   DATA 'smsq_gold_driver_most_link'
3910   DATA 'smsq_gold_driver_nd_link'
3920   DATA 'smsq_gold_driver_nds_link'
3930   DATA 'smsq_gold_driver_dv3_link'
3940   DATA 'smsq_gold_kbd_lang_link'
3950   DATA 'smsq_gold_kbd_abc_lng_link'
3960   DATA 'smsq_gold_kbd_abc_link'
3970   DATA 'smsq_gold_roms_link'
3980   DATA 'smsq_gold_qimi_link'
3990   DATA 'smsq_aurora_sysspr_link'
4000   DATA 'smsq_gold_sysspr_link',''
4010 END DEFine aurora_data
4020 :
4030 DEFine PROCedure qxl_data
4040 restore 4040
4050   DATA '**** -- QXL -- ****'
4060   DATA 'smsq_qxl_host_link'
4070   DATA 'smsq_qxl_hwinit_link'
4080   DATA 'smsq_qxl_nasty_e_link'
4090   DATA 'smsq_qxl_driver_ql_link'
4100   DATA 'smsq_qxl_driver_16_link'
4110   DATA 'smsq_qxl_driver_most_link'
4120   DATA 'smsq_qxl_driver_nd_link'
4130   DATA 'smsq_qxl_procs_link'
4140   DATA 'smsq_qxl_driver_dv3e_link'
4150   DATA 'smsq_qxl_kbd_lang_link'
4160   DATA 'smsq_qxl_ecache_link'
4170   DATA 'smsq_qxl_sysspr_link',''
4180 END DEFine qxl_data
4190 :
4200 DEFine PROCedure java_data
4210 restore 4210
4220   DATA '**** -- Java -- ****'
4230   DATA 'smsq_java_host_link'
4240   DATA 'smsq_java_smsq_link'
4250   DATA 'smsq_java_smsq_1mb_link'
4260   DATA 'smsq_java_hwinit_link'
4270   DATA 'smsq_java_driver_ql_link'
4280   DATA 'smsq_java_driver_8_link'
4290   DATA 'smsq_java_driver_16_link'
4300   DATA 'smsq_java_driver_most_link'
4310   DATA 'smsq_java_driver_dv3e_link'
4320   DATA 'smsq_java_ip_link'
4330   DATA 'smsq_gold_kbd_lang_link'
4340   DATA 'smsq_java_sysspr_link',''
4350 END DEFine java_data
4360 :
4370 DEFine PROCedure qpc_data
4380 restore 4380
4390   DATA "**** -- QPC -- ****"
4400   DATA 'smsq_qpc_host_link'
4410   DATA 'smsq_qpc_hwinit_link'
4420   DATA 'smsq_qpc_nasty_e_link'
4430   DATA 'smsq_qpc_driver_ql_link'
4440   DATA 'smsq_qpc_driver_16_link'
4450   DATA 'smsq_qpc_driver_8_link'
4460   DATA 'smsq_qpc_driver_ql_link'
4470   DATA 'smsq_qpc_driver_most_link'
4480   DATA 'smsq_qpc_procs_link'
4490   DATA 'smsq_qpc_driver_dv3e_link'
4500   DATA 'smsq_qpc_kbd_lang_link'
4510   DATA 'smsq_qpc_dos_link'
4520   DATA 'smsq_qpc_ip_link'
4530   DATA 'smsq_qpc_cdaudio_link'
4540   DATA 'smsq_smsq_qpc_link'
4550   DATA 'smsq_qpc_sysspr_link',''
4560 END DEFine qpc_data
4570 :
4580 DEFine PROCedure ptrgen_data
4590 restore 4590
4600   DATA "**** -- PtrGen -- ****"
4610   DATA "ee_wman_link","ee_ptr_link","ee_hot_german_link","ee_hot_french_link"
4620   DATA "ee_hot_english_link",""
4630 END DEFine ptrgen_data
4640 :
4650 DEFine PROCedure q68_data
4660 restore 4660
4670   DATA '**** -- Q68 -- ****'
4680   DATA 'smsq_q68_sbas_procs_link'
4690   DATA 'smsq_q68_hwinit_link'
4700   DATA 'smsq_q68_nasty_link'
4710   DATA 'smsq_q68_driver_dv3_link'
4720   DATA 'smsq_q68_driver_most_link'
4730   DATA 'smsq_q68_driver_ql_link'
4740   DATA 'smsq_q68_driver_16_link'
4750   DATA 'smsq_q68_driver_8_link'
4760   DATA 'smsq_q68_driver_nd_link'
4770   DATA 'smsq_q68_kbd_lang_link'
4780   DATA 'smsq_smsq_q68_link'
4790   DATA 'smsq_q40_sysspr_link',''
4800 END DEFine q68_data
4810 :
4820 DEFine PROCedure make_targets
4830 REMark targets are only made if there was no error during compilation
4840 REMark to achieve this, a primitive approach is used:
4850 REMark a check is made whether an appsub menu item status is still selected
4860 REMark if it is, then the
4870   LOCal lp%,current_target%,tot_targets%
4880   tot_targets%=0                        : REMark no targets to make yet
4890   current_target%=0                               : REMark and no target yet
4900   FOR lp%=0 TO data_count%-2
4910     IF main_mfl%(lp%,0)=16
4920       REMark we're covering a new target
4930       tot_targets%=tot_targets%+current_target% : REMark show old target
4940       current_target%=find_target%(lp%+1) : REMark get new target we're covering
4950     ELSE
4960       IF main_mfl%(lp%,0)<>0:current_target%=0
4970     END IF
4980   END FOR lp%
4990   tot_targets%=tot_targets%+current_target%
5000   REMark at the end, here, tot_targets holds a bitmap
5010   REMark of targets for which compilation was ok
5020   IF (machines%&&1) AND NOT (tot_targets% && 1):RETurn : REMark generic was asked for but not compiled correctly!
5030   IF tot_targets%&&2:atari_target
5040   IF tot_targets%&&4:gc_target
5050   IF tot_targets%&&8:qx0_target
5060   IF tot_targets%&&16:qxl_target
5070   IF tot_targets%&&32:aurora_target
5080   IF tot_targets%&&64:java_target
5090   REMark IF tot_targets%&&128:ptr_gen_target  : rem no need for this
5100   IF tot_targets%&&256:qpc_target
5110   IF tot_targets%&&512:q68_target
5120 END DEFine make_targets
5130 :
5140 DEFine PROCedure atari_target
5150   cmdl$='m'
5160   p$=rep$&'sys_boot_st_flp'
5170   f$=rep$&'sys_boot_file'
5180   ah$=rep$&'sys_boot_st_host'
5190   ld$=rep$&'smsq_smsq_loader'
5200   hi$=rep$&'smsq_atari_hwinit'
5210   os1f$=rep$&'smsq_smsq_fh_os'
5220   os1$=rep$&'smsq_smsq_os'
5230   ca$=rep$&'smsq_smsq_cache'
5240   os2$=rep$&'smsq_sbas_control'
5250   ns1$=rep$&'smsq_atari_nasty'
5260   ln1$=rep$&'smsq_smsq_lang'
5270   ln2$=rep$&'smsq_atari_kbd_lang'
5280   ln3$=rep$&'smsq_sbas_lang'
5290   ex1$=rep$&'smsq_sbas_procs_x'
5300   ex2$=rep$&'smsq_atari_driver_dv3'
5310   ex3$=rep$&'smsq_atari_driver_ser'
5320   ex4$=rep$&'smsq_atari_driver_mono'
5330   ex5$=rep$&'smsq_atari_driver_ql'
5340   ex6$=rep$&'smsq_smsq_wman'
5350   ex7$=rep$&'smsq_smsq_hotkey'
5360   ex8$=rep$&'smsq_atari_sysspr'
5370   ex9$=rep$&'smsq_home_home'
5380   ex10$=rep$&'smsq_recent_recent'
5390   nl$=rep$&'sys_boot_null'
5400   IF 'm' INSTR cmdl$ = 0: ex4$ = nl$
5410   EW f$, ah$,ld$,hi$,os1f$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$, ex10$,rep$&'smsq_atari_SMSQ.PRG'
5420 END DEFine atari_target
5430 :
5440 DEFine PROCedure gc_target
5450 REMark there are  2 targets for the Goldcard!
5460   f$=rep$&'sys_boot_file'
5470   v$=rep$&'smsq_smsq_vers'
5480   h$=rep$&'smsq_gold_host'
5490   ld$=rep$&'smsq_smsq_loader'
5500   hi$=rep$&'smsq_gold_hwinit'
5510   os1$=rep$&'smsq_smsq_os'
5520   ca$=rep$&'smsq_smsq_cache'
5530   os2$=rep$&'smsq_sbas_control'
5540   ns1$=rep$&'smsq_gold_nasty'
5550   ns2$=rep$&'smsq_gold_nasty_s'
5560   ln1$=rep$&'smsq_smsq_lang'
5570   ln2$=rep$&'smsq_gold_kbd_lang'
5580   ln2a$=rep$&'smsq_gold_kbd_abc_lang'
5590   ln3$=rep$&'smsq_sbas_lang'
5600   ex1$=rep$&'smsq_sbas_procs_x'   : REMark this must be after "roms"
5610   ex2a$=rep$&'smsq_gold_kbd_abc'
5620   ex2$=rep$&'smsq_gold_driver_most'
5630   ex3a$=rep$&'smsq_gold_driver_ql'
5640   ex38$=rep$&'smsq_gold_driver_8'
5650   ex3q$=rep$&'smsq_gold_qimi'
5660   ex3w$=rep$&'smsq_smsq_wman'
5670   ex4$=rep$&'smsq_gold_driver_dv3'
5680   ex5$=rep$&'smsq_gold_driver_nd'
5690   ex6$=rep$&'smsq_gold_driver_nds'
5700   ex7$=rep$&'smsq_smsq_hotkey'
5710   ex8$=rep$&'smsq_gold_sysspr'
5720   ex9$=rep$&'smsq_home_home'
5730   ex10$=rep$&'smsq_gold_roms'
5740   ex11$=rep$&'smsq_recent_recent'
5750   nl$=rep$&'sys_boot_null'
5760   EW f$, v$,h$,ld$,hi$,os1$,ca$,os2$,ns1$,ns2$,ln1$,ln2$,ln2a$,ln3$,ex2a$,ex2$,ex3a$,ex3q$,ex3w$,ex4$,ex5$,ex6$,ex7$,ex8$,ex1$,ex9$,ex10$, ex11$,rep$&'SMSQ_GOLD_gold'
5770   EW f$, v$,h$,ld$,hi$,os1$,ca$,os2$,ns1$,ns2$,ln1$,ln2$,ln2a$,ln3$,ex2a$,ex2$,ex38$,ex3q$,ex3w$,ex4$,ex5$,ex6$,ex7$,ex8$,ex1$,ex9$,ex10$, ex11$,rep$&'SMSQ_GOLD_gold8'
5780 END DEFine gc_target
5790 :
5800 DEFine PROCedure aurora_target
5810   f$=rep$&'sys_boot_file'
5820   v$=rep$&'smsq_smsq_vers'
5830   h$=rep$&'smsq_gold_host'
5840   ld$=rep$&'smsq_smsq_loader'
5850   hi$=rep$&'smsq_gold_hwinit'
5860   os1$=rep$&'smsq_smsq_os'
5870   ca$=rep$&'smsq_smsq_cache'
5880   os2$=rep$&'smsq_sbas_control'
5890   ns1$=rep$&'smsq_gold_nasty'
5900   ns2$=rep$&'smsq_gold_nasty_s'
5910   ln1$=rep$&'smsq_smsq_lang'
5920   ln2$=rep$&'smsq_gold_kbd_lang'
5930   ln2a$=rep$&'smsq_gold_kbd_abc_lang'
5940   ln3$=rep$&'smsq_sbas_lang'
5950   ex1$=rep$&'smsq_sbas_procs_x'   : REMark this must be after "roms"
5960   ex2a$=rep$&'smsq_gold_kbd_abc'
5970   ex2$=rep$&'smsq_gold_driver_most'
5980   ex3a$=rep$&'smsq_gold_driver_ql'
5990   ex3b$=rep$&'smsq_aurora_driver_8'
6000   ex3q$=rep$&'smsq_gold_qimi'
6010   ex3w$=rep$&'smsq_smsq_wman'
6020   ex3sq$=rep$&'smsq_aurora_sysspr'
6030   ex3sh$=rep$&'smsq_gold_sysspr'
6040   ex4$=rep$&'smsq_gold_driver_dv3'
6050   ex5$=rep$&'smsq_gold_driver_nd'
6060   ex6$=rep$&'smsq_gold_driver_nds'
6070   ex8$=rep$&"smsq_home_home"
6080   ex9$=rep$&'smsq_smsq_hotkey'
6090   ex10$=rep$&'smsq_gold_roms'
6100   ex11$=rep$&'smsq_recent_recent'
6110   nl$=rep$&'sys_boot_null'
6120   EW f$, v$,h$,ld$,hi$,os1$,ca$,os2$,ns1$,ns2$,ln1$,ln2$,ln2a$,ln3$,ex2a$,ex2$,ex3a$,ex3b$,ex3q$,ex3w$,ex3sh$,ex4$,ex5$,ex6$,ex9$,ex10$,ex8$,ex1$,ex11$, rep$&'SMSQ_Aurora_SMSQE'
6130 END DEFine aurora_target
6140 :
6150 DEFine PROCedure qx0_target
6160   nl$=rep$&'sys_boot_null'
6170   f$=rep$&'sys_boot_file'
6180   qr$=rep$&'sys_boot_q40_rom'
6190   ld$=rep$&'smsq_smsq_loader'
6200   hi$=rep$&'smsq_q40_hwinit'
6210   os1$=rep$&'smsq_smsq_q40_os' : REMark -*** change for fast memory   **
6220   ca$=rep$&'smsq_smsq_cache40c'
6230   caq$=rep$&'smsq_q40_cache'
6240   caq4$=rep$&'smsq_q40_cachemode'
6250   os2$=rep$&'smsq_sbas_control'
6260   ns2$=rep$&'smsq_q40_nasty'
6270   ln1$=rep$&'smsq_smsq_lang'
6280   ln2$=rep$&'smsq_q40_kbd_lang'
6290   ln3$=rep$&'smsq_sbas_lang'
6300   ex1$=rep$&'smsq_sbas_procs_x'
6310   ex2$=rep$&'smsq_q40_driver_dv3'
6320   ex3$=rep$&'smsq_q40_driver_ser'
6330   ex4a$=rep$&'smsq_q40_driver_ql'
6340   ex4b$=rep$&'smsq_q40_driver_16'
6350   ex4w$=rep$&'smsq_smsq_wman'
6360   ex5$=rep$&'smsq_q40_sysspr'
6370   ex9$=rep$&'smsq_smsq_hotkey'
6380   ex10$=rep$&'smsq_home_home'
6390   ex11$=rep$&'smsq_recent_recent'
6400   EW f$, qr$,ld$,hi$,os1$,ca$,caq$,os2$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex4a$,ex4b$,ex4w$,ex5$,ex9$,ex10$,ex11$,ns2$,caq4$, rep$&'smsq_q40_rom'
6410 END DEFine qx0_target
6420 :
6430 DEFine PROCedure qxl_target
6440   IF FOP_IN (rep$&'smsq_qxl_qxlh.exe') <> -7: PRINT 'QXLH.EXE exists'; cmd$: QUIT
6450   p$   = rep$&'sys_boot_file'
6460   bl$  = rep$&'smsq_qxl_qxl2_exe'
6470   hst$ = rep$&'smsq_qxl_host'
6480   hi$  = rep$&'smsq_qxl_hwinit'
6490   ld$  = rep$&'smsq_smsq_loader'
6500   os1$ = rep$&'smsq_smsq_os'
6510   ca$  = rep$&'smsq_smsq_cache'
6520   os2$ = rep$&'smsq_sbas_control'
6530   ns1$ = rep$&'smsq_qxl_nasty_e'
6540   ln1$ = rep$&'smsq_smsq_lang'
6550   ln2$ = rep$&'smsq_qxl_kbd_lang'
6560   ln3$ = rep$&'smsq_sbas_lang'
6570   ex1$ = rep$&'smsq_qxl_procs_x'
6580   ex2$ = rep$&'smsq_qxl_driver_most'  : REMark Keyboard before CON
6590   ex3$ = rep$&'smsq_qxl_driver_ql'
6600   ex3b$ = rep$&'smsq_qxl_driver_16'
6610   ex3w$ = rep$&'smsq_smsq_wman'
6620   ex4$ = rep$&'smsq_qxl_driver_nd'
6630   ex5$ = rep$&'smsq_qxl_driver_dv3e'
6640   ex6$ = rep$&'smsq_smsq_hotkey'
6650   ex7$ = rep$&'smsq_qxl_sysspr'
6660   ex8$ = rep$&'smsq_home_home'
6670   ex10$= rep$&'smsq_recent_recent'
6680   last$ = rep$&'smsq_qxl_ecache'
6690   dml$ = rep$&'smsq_qxl_dummy'
6700   qm$  = rep$&'qmon_qxl_bin'
6710   r$='ram1_smsqe.exe' : f$=rep$&'smsq_qxl_smsqe.exe'
6720   cct$=rep$&"extras_exe_cct"
6730   DELETE f$
6740   EW p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3w$,ex4$,ex5$,ex6$,ex7$,ex8$,ex11$,last$, r$
6750   EW cct$, bl$,r$, f$
6760   DELETE r$
6770   OPEN #4,f$
6780   lenf=FLEN(#4)
6790   lens% = INT ((lenf+511)/512)
6800   lenb% = lenf - lens% * 512
6810   IF lenb%: lenb% = lenb% + 512
6820   BPUT #4\2, lenb% MOD 256, lenb% DIV 256, lens% MOD 256, lens% DIV 256
6830   CLOSE #4
6840 END DEFine qxl_target
6850 :
6860 DEFine PROCedure java_target
6870   f$=rep$&'sys_boot_file'
6880   v$=rep$&'smsq_smsq_vers'
6890   h$=rep$&'smsq_java_host'
6900   ld$=rep$&'smsq_smsq_loader'
6910   hi$=rep$&'smsq_java_hwinit'
6920   os1$=rep$&'smsq_java_smsq_os'
6930   os3$=rep$&'smsq_java_smsq_1mb_os'     : REMark must be after os
6940   ca$=rep$&'smsq_smsq_cache'
6950   os2$=rep$&'smsq_sbas_control'
6960   ln1$=rep$&'smsq_smsq_lang'
6970   ln2$=rep$&'smsq_gold_kbd_lang'
6980   ln3$=rep$&'smsq_sbas_lang'
6990   sb$=rep$&'smsq_sbas_procs_x'                    : REMark this must be after "roms"
7000   dr1$=rep$&'smsq_java_driver_most'
7010   dr2$=rep$&'smsq_java_driver_ql'
7020   dr3$=rep$&'smsq_java_driver_8'
7030   dr4$=rep$&'smsq_java_driver_16'
7040   dr5$=rep$&'smsq_smsq_wman'
7050   dr6$=rep$&'smsq_java_driver_dv3e'
7060 rem  dr7$=rep$&'smsq_java_driver_qsd_qsd'
7070   hk$=rep$&'smsq_smsq_hotkey'
7080   sp$=rep$&'smsq_java_sysspr'
7090   hm$=rep$&'smsq_home_home'
7100   ip$=rep$&'smsq_java_ip_x'
7110   re$=rep$&'smsq_recent_recent'
7120   EW f$,h$,ld$,hi$,os1$,os3$,ca$,os2$,ln1$,ln2$,ln3$,sb$,dr1$,dr2$,dr3$,dr4$,dr5$,dr6$,hk$,sp$,hm$,ip$,re$, rep$&'SMSQ_java_java'
7130 END DEFine java_target
7140 :
7150 DEFine PROCedure qpc_target
7160   p$   = rep$&'sys_boot_file'
7170   hst$ = rep$&'smsq_qpc_host'
7180   hi$  = rep$&'smsq_qpc_hwinit'
7190   ld$  = rep$&'smsq_smsq_loader'
7200   os1$ = rep$&'smsq_smsq_qpc_os'
7210   ca$  = rep$&'smsq_smsq_cache'
7220   os2$ = rep$&'smsq_sbas_control'
7230   ns1$ = rep$&'smsq_qpc_nasty_e'
7240   ln1$ = rep$&'smsq_smsq_lang'
7250   ln2$ = rep$&'smsq_qpc_kbd_lang'
7260   ln3$ = rep$&'smsq_sbas_lang'
7270   ex1$ = rep$&'smsq_sbas_procs_x'
7280   ex2$ = rep$&'smsq_qpc_driver_most'  : REMark Keyboard before CON
7290   ex3$ = rep$&'smsq_qpc_driver_ql'
7300   ex3b$= rep$&'smsq_qpc_driver_16'
7310   ex3c$= rep$&'smsq_qpc_driver_8'
7320   ex3w$= rep$&'smsq_smsq_wman'
7330   ex3s$= rep$&'smsq_qpc_sysspr'
7340   ex4$ = rep$&'smsq_qpc_driver_dv3e'
7350   ex5$ = rep$&'smsq_smsq_hotkey'
7360   ex6$ = rep$&'smsq_qpc_procs_x'
7370   ex7$ = rep$&'smsq_qpc_cdaudio_x'
7380   ex8$ = rep$&'smsq_qpc_dos_x'
7390   ex9$ = rep$&'smsq_qpc_ip_x'
7400   exa$ = rep$&'smsq_home_home'
7410   exb$ = rep$&'smsq_recent_recent'
7420   qm$ =  rep$&"qmon_qpc_smsq"
7430   r$='ram1_smsqe.bin'
7440   EW p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3c$,ex3w$,ex3s$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$,exa$,exb$, r$
7450   COPY_O r$,rep$&'smsq_qpc_smsqe.bin'
7460   DELETE r$
7470   REMark rd$='ram1_smsqe.deb'
7480   REMark EW p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3c$,ex3w$,ex3s$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$,exa$,qm$, rd$
7490   REMark COPY_O r$,qpc$&'release_smsqe.bin'
7500   REMark COPY_O rd$,qpc$&'exe_smsqe.bin'
7510 END DEFine qpc_target
7520 :
7530 DEFine PROCedure q68_target
7540   local c%
7550   tgt$= rep$&'smsq_q68_QL_RAM.BIN'
7560   leng=350000
7570   nl$=rep$&'sys_boot_null'
7580   f$=rep$&'sys_boot_file'
7590   qr$=rep$&'sys_boot_q68_rom_bin'
7600   ld$=rep$&'smsq_smsq_loader'
7610   hi$=rep$&'smsq_q68_hwinit'
7620   os1$=rep$&'smsq_smsq_q68_os' : REMark change for fast memory
7630   ca$  = rep$&'smsq_smsq_cache'
7640   ns2$=rep$&'smsq_q68_nasty'
7650   os2$=rep$&'smsq_sbas_control'
7660   ln1$=rep$&'smsq_smsq_lang'
7670   ln2$=rep$&'smsq_q68_kbd_lang'
7680   ln3$=rep$&'smsq_sbas_lang'
7690   ex1$=rep$&'smsq_q68_sbas_procs_x'
7700   ex2$=rep$&'smsq_q68_driver_dv3'
7710   ex3$=rep$&'smsq_q68_driver_most'
7720   ex4a$=rep$&'smsq_q68_driver_ql'
7730   ex4b$=rep$&'smsq_q68_driver_16'
7740   ex4c$=rep$&'smsq_q68_driver_8'
7750   ex4w$=rep$&'smsq_smsq_wman'
7760   ex5$=rep$&'smsq_q40_sysspr'
7770 rem  ex6$=rep$&'smsq_q68_driver_nd'
7780   ex9$=rep$&'smsq_smsq_hotkey'
7790   ex10$=rep$&'smsq_home_home'
7800   ex11$=rep$&'smsq_recent_recent'
7810   EW f$, qr$,ld$,hi$,os1$,ca$,os2$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex4a$,ex4b$,ex4c$,ex4w$,ex5$,ex9$,ex10$,ex11$,ns2$,tgt$ : rem no net
7820   rem EW f$, qr$,ld$,hi$,os1$,ca$,os2$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex4a$,ex4b$,ex4w$,ex5$,ex6$,ex9$,ex10$,ex11$,ns2$,tgt$
7830   COPY_O tgt$,tgt$&"3"
7840   c%=fop_in (tgt$)
7850   fleng=flen(#c%)
7860   close#c%
7870   a=ALCHP (leng)
7880   LBYTES tgt$,a
7890   poke_l a+16,fleng                               : rem set length here
7900   SBYTES_O tgt$,a,leng
7910   RECHP a
7920 END DEFine q68_target
7930 :
7940 DEFine PROCedure findit
7950 LOCal lp%,a$
7960 restore 7960
7970   DATA p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3c$,ex3w$,ex3s$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$,exa$, r$,""
7980   REPeat lp%
7990     READ a$:IF a$="":EXIT lp%
8000     t%=FOP_IN(a$ )
8010     IF (t%<0)
8020        PRINT "not found "& a$
8030     END IF
8040  END REPeat lp%
8050 END DEFine findit
8060 :
8070 DEFine FuNction find_target% (current%)
8080   IF "SMSQ Generic" INSTR mdata$(current%):RETurn 1
8090   IF "Atari" INSTR mdata$(current%):RETurn 2
8100   IF "GoldCard" INSTR mdata$(current%):RETurn 4
8110   IF "Q40" INSTR mdata$(current%):RETurn 8
8120   IF "QXL" INSTR mdata$(current%):RETurn 16
8130   IF "Aurora" INSTR mdata$(current%):RETurn 32
8140   IF "Java" INSTR mdata$(current%):RETurn 64
8150   IF "Ptr_Gen" INSTR mdata$(current%):RETurn 128
8160   IF "QPC" INSTR mdata$(current%):RETurn 256
8170   IF "Q68" INSTR mdata$(current%):RETurn 512
8180   RETurn 0                                     : REMark huh???
8190 END DEFine find_target%
8200 :
8210 define procedure change_size (x%,y%)
8220 rem this uses the GLOBAL vars : maxx%,maxy%, xsize%,ysize%,main_xxx...
8230 local xrel%,yrel%,temp,a$,ttemp%(main_lit%),abs%,yabs%,t%,bt$,mtemp%(0,0)
8240   main_lfl%(size_it%)=1                 : remark reset to available
8250   dim mtemp%(dimn(main_mfl%,1),dimn(main_mfl%,2))
8260   arrcopy main_lfl%,ttemp%              : remark keep statusses
8270   arrcopy main_mfl%,mtemp%
8280   ch_win main_defn,xrel%,yrel%                    : remark get ptr displacement
8290   xsize%=xsize%-xrel%+3
8300   if xsize%<420:xsize%=420
8310   ysize%=ysize%-yrel%                             : remark new sizes
8320   t%=2^4+2^5                                      : rem return immediately from read ptr call
8330   rptr xabs%,yabs%,t%,t%,xrel%,yrel%,bt$: remark get absolute coords
8340   if xsize%>maxx%-16:xsize%=maxy%-16
8350   if ysize%>maxy%-16:ysize%=maxy%-16    : remark max values
8360   dr_unst main_defn                               : remark no more wdw defn...
8370   dr_remv main_defn                               : remark .... now!
8380   app_addr=0                                      : remark nor any appsub wdw
8390   rows%=-1
8400   make_main_wdw                         : remark make window anew
8410   arrcopy ttemp%,main_lfl%
8420   arrcopy mtemp%,main_mfl%
8430   t%=lxs%*3
8440   xabs%=xabs%-t%:if xabs%<0:xabs%=0     : remark position ptr nicely
8450   yabs%=yabs%-8:if yabs%<0:yabs%=0
8460   sptr xabs%,yabs%,0                              : remark now
8470   if compiled
8480      dr_ppos main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8490   else
8500      dr_puld main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8510   end if
8520   pos_ptr main_defn,x%*65536+y%,1      : remark position pointer in wdw
8530 end define change_size
8540 :
8550 def proc autochange_size (x%,y%)
8560 rem change size when items added/removed
8570 rem this tries to change the wdw position as little as possible
8580 local lp%,xrel%,yrel%,ttemp%(main_lit%),abs%,yabs%,t%,bt$
8590   t%=2^4+2^5                                      : rem return immediately from read ptr call
8600   rptr xabs%,yabs%,t%,t%,xrel%,yrel%,bt$: remark get absolute coords
8610   arrcopy main_lfl%,ttemp%              : remark keep statusses
8620   dr_unst main_defn                               : remark no more wdw defn...
8630   dr_remv main_defn                               : remark .... now!
8640   app_addr=0                                      : remark nor any appsub wdw
8650   rows%=data_count%-1
8660   make_main_wdw                         : remark make window anew
8670   for lp%=0 to dimn(main_lfl%,1)
8680      main_lfl%(lp%)=ttemp%(lp%)+1
8690   end for lp%
8700   set_statusses
8710   main_cty%(0,1)=1
8720   xabs%=xabs%-x%:if xabs%<0:xabs%=x%    : remark position ptr nicely
8730   yabs%=yabs%-y%:if yabs%<0:yabs%=y%
8740   sptr xabs%,yabs%,0                              : remark now
8750   if compiled
8760      dr_ppos main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8770   else
8780      dr_puld main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8790   end if
8800   pos_ptr main_defn,x%*65536+y%,1       : remark position pointer in wdw
8810 end define autochange_size
8820 :
8830 DEFine PROCedure set_statusses
8840 REMark set all statusses of menu appsub objects
8850 LOCal temp%,lp%,stat%
8860   temp%=DIMN(main_mfl%,1)               : REMark how many are there?
8870   stat%=main_lfl%(all_it%)              : REMark status of "all" item
8880   FOR lp%=0 TO temp%
8890     IF mdata$(lp%+1,1)='*'
8900       main_mfl%(lp%,0)=16               : REMark comments set to unavailable
8910     ELSE
8920       main_mfl%(lp%,0)=stat%            : REMark all other to status
8930     END IF
8940   END FOR lp%
8950 END DEFine set_statusses
8960 :
8970 define procedure make_main_wdw
8980 rem make the main window - a pretty standard window with 1 menu appsub wdw
8990 local main_lot,main_iwt,main_iot1,infy1%,lxs%,lys%,xesp%,nbr_post%,nbr_trgs%
9000 local title$,title_size%,title_x%,temp%,appwinoffset%,li_xorig%,li_xsize%
9010 :
9020   appwinoffset%=16                      : remark appsub win additional y offset
9030   lxs%=24:lys%=12                       : remark standard item x,y, sizes
9040   inf1y%=lys%+4                         : remark y orig of inner border
9050   xesp%=lxs%+2                                    : remark loose items x spacing
9060   nbr_post%=5                                     : remark nbr of item right & left in title bar
9070   li_xorig%=6
9080   li_xsize%=7*6 + 2
9090   nbr_trgs%=10                                     : rem number of targets
9100 :
9110   title$="dir: "&rep$&" "
9120   rem first make sure of the wdw sizes (we also come here from change_size!)
9130   temp%=(xsize%-li_xorig%) div nbr_trgs% : rem x size of 1 target loose item
9140   xsize%=temp%*nbr_trgs%+ li_xorig% +3
9150   xsize%=xsize%-(xsize% mod 4)                    : rem make into nbr divisible by 4
9160 :
9170   rem calculate the y size of the wdw so that it always looks nice, in that
9180   rem the rows in the appsub always fill the appsub entirely
9190   app_y_orig%=inf1y% + appwinoffset%    : rem y offset for appsub win within wdw
9200   calc_ysize 0                                    : rem set ysize% and rows% variables
9210 :
9220   rem first calc info obj size - this also influences one loose item, used
9230   rem in the title bar
9240   title_size%=len(title$)*6             : rem length in pixels
9250   title_x%=int((xsize%-title_size%)/2): rem x orig
9260 :
9270   rem first the loose items
9280 :
9290   esc%=0:move_it%=esc%+1:size_it%=move_it%+1
9300   sleep_it%=size_it%+1:all_it%=sleep_it%+1:go_it%=all_it%+1
9310   dir_it%=go_it%+1:target_its%=dir_it%+1:make_it%=target_its%+nbr_trgs%
9320   info_it%=make_it%+1:del_it%=info_it%+1:alltargets_it%=del_it%+1
9330 :
9340 restore 9340
9350 :
9360   main_lit%=20:dim main_lfl%(main_lit%)   : rem there are 21 items
9370   main_lot=rd_lot(std_iattr,main_lit%)
9380     data lxs%,lys%,4+xesp%*0,2,0,0,cancel$,text+retr,'ESC'
9390     data lxs%,lys%,4+xesp%*1,2,0,0,move$,sprite+retr,move_sprite
9400     data lxs%,lys%,4+xesp%*2,2,0,0,size$,sprite+retn,size_sprite
9410     data lxs%,lys%,xsize%-2-xesp%*1,2,0,0,sleep$,sprite+retr,sleep_sprite
9420     data lxs%,lys%,xsize%-2-xesp%*3,2,0,0,'A',sous1+retn,"All"
9430     data lxs%,lys%,xsize%-2-xesp%*4,2,0,0,'O',sous1+retn,"Ok"
9440     data 6*6,lys%-2,title_x%+30,3,0,0   ,'D',text+retn,rep$
9450     data li_xsize%,lys%,li_xorig%,inf1y%+2,0,0,        'G',sous1+retn,"Generic"
9460     data li_xsize%,lys%,li_xorig%+temp%,inf1y%+2,0,0,  'T',sous2+retn,"Atari"
9470     data li_xsize%,lys%,li_xorig%+temp%*2,inf1y%+2,0,0,'L',sous3+retn,"Goldcrd"
9480     data li_xsize%,lys%,li_xorig%+temp%*3,inf1y%+2,0,0,'Q',sous1+retn,"Q40/Q60"
9490     data li_xsize%,lys%,li_xorig%+temp%*4,inf1y%+2,0,0,'X',sous2+retn,"Qxl"
9500     data li_xsize%,lys%,li_xorig%+temp%*5,inf1y%+2,0,0,'U',sous2+retn,"Aurora"
9510     data li_xsize%,lys%,li_xorig%+temp%*6,inf1y%+2,0,0,'J',sous1+retn,"Java"
9520     data li_xsize%,lys%,li_xorig%+temp%*7,inf1y%+2,0,0,'P',sous1+retn,"PtrGen"
9530     data li_xsize%,lys%,li_xorig%+temp%*8,inf1y%+2,0,0,'C',sous3+retn,"QPC"
9540     data li_xsize%,lys%,li_yorig%+temp%*9,inf1y%+2,0,0,'8',sous3+retn,"Q68"
9550     data 4*6,lys%,xsize%-2-xesp%*2,2,0,0,'M',sous1+retn,"Make"
9560     data 4*6,lys%,xsize%-2-xesp%*5,2,0,0,'?',sous1+retn,"?"
9570     data lxs%,lys%,4+xesp%*3,2,0,0,"E",sous2+retn,"DEL"
9580     data lxs%,lys%,4+xesp%*4,2,0,0,"S",sous1+retn,"SaT"
9590 :
9600 rem now info wdw objects - here only one, the title
9610   rem make the title data: calculate size and x position of this object
9620   main_iot1=rd_iot(0)
9630     data title_size%,10,4,int((lys%-10)/2),sous1,sp.titlefg,0,0,title$
9640 :
9650 rem now the info wdws
9660   main_iwt=rd_iwt(2)                              : rem there are 3
9670   rem first the title bar
9680     data xsize%-8-(2*nbr_post%*xesp%),lys%+2,xesp%*nbr_post%+4,0       : rem x,y sizes & origs
9690     data 0,0,sp.infwinbd,sp.titlebg     : rem shadow, border size & col,paper col
9700     data 0                                        : rem object pointer (none)
9710 :
9720   rem now wdw containing title itself
9730     data title_size%+8,lys%,title_x%-4,2
9740     data 0,0,sp.infwindbd,sp.infwinbg
9750     data main_iot1                      : rem one object
9760 :
9770   rem inner border
9780     data xsize%-8,ysize%-inf1y%-2,4,inf1y%
9790     data 0,1,sp.infwinbd,sp.infwinbg
9800     data 0
9810 :
9820 rem now the appsub wdw - use the outptr functions for this
9830   main_app_list=0                       : rem appsub win list
9840   app_addr=0                                      : rem there is no appsub win yet
9850   menu_selkeys$=""                      : rem selkeys to exclude
9860   appw_sections%=1                      : rem display only one section
9870   app_addr=mk_main_app(app_addr,mdata$,0,0,1,0,0,0) : rem make apsub wdw
9880   main_app_list = app_addr+180                    : rem list built by outptr
9890   set_statusses                         : rem set statusses of menu items
9900 :
9910 rem the working defn
9920   main_defn=rd_wdef
9930     data 2,1,sp.winbd,sp.winbg                    : rem shad,border size & col,pap col
9940     data xsize%,ysize%,0,0              : rem x,y size & initial ptr pos
9950     data main_sprite,main_lot,main_iwt,main_app_list : rem sprite,loose items, info wins, appsubs
9960 end define make_main_wdw
9970 :
9980 def fn warning_pos% (mess$,channel%,title$,pos)
9990 rem warning wdw with pointer positioning
10000   pos_ptr main_defn,pos,-1
10010   return warning%(mess$,channel%,title$)
10020 end def warning_pos%
10030 :
10040 define function warning%(mess$,channel%,title$)
10050 rem shows a warning message (mess$) in a small window. hit esc or ok
10060 rem to return; returns 0 if esc, 1 if ok  hit
10070 local item%,lp%,chan%,y%,swnum%,infot%
10080   stop_info
10090   if channel%
10100     chan%=channel%
10110   else
10120     chan%=fopen("con")
10130   endif
10140   ch_item warn_defn,-3,0,-1,'','Attention'
10150   ch_item warn_defn,-1,0,-1,cancel$,'ESC'
10160   ch_item warn_defn,-1,1,-1,'O','OK'
10170   warn_lfl%(0)=1:warn_lfl%(1)=1
10180   poke_w warn_defn+44,sp.errmg                           : rem border colour of wdw
10190   poke_w warn_defn+46,sp.errbg                           : rem paper colour of wdw
10200   poke_w warn_wdw_addr+14,sp.errbg             : rem paper of title info wdw
10210   obj_addr=peek_l(warn_wdw_addr+16)            : rem ptr to object list
10220   poke_w obj_addr+10,sp.errfg                            : rem info object text  colour
10230   dr_puld warn_defn,-1,-1
10240   dr_iwdf #chan%,warn_defn,0
10250   wm_paper#chan%,sp.errbg
10260   wm_ink#chan%,sp.errfg
10270   cls#chan%
10280   if title$<>"":print#chan%,title$;" :"
10290   print #chan%,mess$
10300   pos_ptr warn_defn,160*65536+10,-1
10310   repeat lp%
10320     rd_ptr warn_defn,item%,swnum%,y%,y%,y%,warn_lfl%
10330     if swnum%=-1:exit lp%
10340   end repeat lp%
10350   if not channel%:close#chan%
10360   dr_unst warn_defn
10370   return item%
10380 end define warning%
10390 :
10400 def proc info_pos (mess$,channel%,pos)
10410 rem warning wdw with positioning
10420   pos_ptr main_defn,pos,-1
10430   info mess$,channel%
10440 end def info_pos
10450 :
10460 define procedure info(mess$,channel%)
10470 rem shows window containing mess$. channel% is a screen channel, if this is 0,
10480 rem a temp screen channel will be opened.
10490 local chan%,infot%,obj_addr
10500   if channel%
10510     chan%=channel%
10520   else
10530     chan%=fopen("con")
10540   endif
10550   ch_item warn_defn,-3,0,-1,"",'  Info.  '
10560   ch_item warn_defn,-1,0,-1,"",'Info'
10570   ch_item warn_defn,-1,1,-1,"",'Info'
10580   poke_w warn_defn+44,sp.infwinbg                 : rem paper colour of wdw
10590   poke_w warn_defn+46,sp.winbd                              : rem border around wdw
10600   poke_w warn_wdw_addr+14,sp.infwinbg             : rem paper of title info wdw
10610   obj_addr=peek_l(warn_wdw_addr+16)               : rem ptr to object list
10620   poke_w obj_addr+10,sp.infwinfg                  : rem info object text        colour
10630   dr_puld warn_defn,-1,-1
10640   pos_ptr warn_defn,90*65536+70,-1
10650   dr_iwdf #chan%,warn_defn,0
10660   wm_paper#chan%,sp.infwinbg
10670   wm_ink#chan%,sp.infwinfg
10680   cls#chan%
10690   print #chan%,mess$
10700   if not channel%:close#chan%
10710   info_is_pulled_down%=1
10720 end define info
10730 :
10740 def proc info_wait(mess$,channel%)
10750 rem shows info wdw, waits until user clicks, closed info wdw
10760   show_info mess$,channel%
10770   info_wait_to_close
10780 end def info_wait
10790 :
10800 def proc info_wait_to_close
10810 local item%,lp%,chan%,y%,swnum%,infot%
10820   repeat lp%
10830     rd_ptr warn_defn,item%,swnum%,y%,y%,y%,warn_lfl%
10840     if swnum%=-1:exit lp%
10850   end repeat lp%
10860   stop_info
10870 end def info_wait_to_close
10880 :
10890 def proc info_pos_wait (mess$,channel%,pos)
10900 rem positions & shows info wdw, waits until user clicks,closes info wdw
10910   info_pos mess$,channel%,pos
10920   info_wait_to_close
10930 end def info_pos_wait
10940 :
10950 def proc stop_info
10960   if info_is_pulled_down%
10970     dr_unst warn_defn
10980     info_is_pulled_down%=0
10990   endif
11000 end def stop_info
11010 :
11020 def proc show_info (mess$,channel%)
11030 rem either opens the info wdw and shows the message or shows the message in
11040 rem the existing info wdw
11050 local chan%
11060   if channel%
11070     chan%=channel%
11080   else
11090     chan%=fopen("con")
11100   endif
11110   if info_is_pulled_down%
11120     cls#chan%
11130     wm_paper#chan%,sp.infwinbg
11140     wm_ink#chan%,sp.infwinfg
11150     cls#chan%
11160     print #chan%,mess$
11170   else
11180     info mess$,chan%
11190   endif
11200   if not channel%:close#chan%
11210 end def show_info
11220 :
11230 DEFine PROCedure button (def_trav,menu_drap%,app_drap%,control%,chaine$,type_col%)
11240 REMark les parametres sont, dans l'ordre:
11250 REMark la dƒfinition de la fen‘tre, suivie des tableaux pour
11260 REMark les postes du menu dƒliƒ, les postes de la sous-fen‘tre d'appl.
11270 REMark et la dƒfinition de contr˜le, suivi du nom du bouton et
11280 REMark du type couleurs.
11290 REMark Il est supposƒ que vous avez ouvert une fen‘tre #1 si
11300 REMark le programme est compilƒ
11310   DR_UNST def_trav
11320   IF compiled: CLOSE#1
11330   button_wait chaine$
11340 rem  BTN chaine$,type_col%
11350   IF compiled
11360     OPEN#1,"CON_"
11370     DR_PPOS def_trav,-1,-1,menu_drap%,app_drap%,control%
11380   ELSE
11390     DR_PULD def_trav,-1,-1,menu_drap%,app_drap%,control%
11400   END IF
11410 END DEFine button
11420 :
11430 DEFine PROCedure make_colours (colourway%)
11440 REMark this initialises the GLOBAL variables menu_pap, menu_brd, menu_inv,
11450 REMark menu_ink and menu_bar according to the colourway passed as parameter.
11460 REMark More importantly, this sets the sp.xxx GLOBAL variables.
11470 REMark The GLOBAl variable mycolour_mode% must have been set prior to calling
11480 REMark this function, preferrably via the function set_colours%.
11490 REMark Moreover the colours black, white,red, green,wg_stripes, etc...
11500 REMark must have been set prior to calling this procedure:
11510 REMark Preferrably, they were also set via the function set_colours%
11520 :
11530 rem this function needs the extension WL_MK16 (outptr_bin)
11540 :
11550 REMark the colourways% are:
11560 REMark 0= white/green
11570 REMark 1= black/red
11580 REMark 2= white/red
11590 REMark 3= black/green
11600 remark 4-7= use system palettes
11610 :
11620 rem the Global war mycolour_mode% is:
11630 rem 0 = we are in QL mode 4
11640 rem 1 = we are in PAL mode (256 colours)
11650 rem 2 - we are in 24 bit colour mode
11660 rem preferrably, this is set via the function set_colours%
11670 :
11680   if colourway%>7 or colourway%<0: colourway%=0: REMark must be between 0 & 7
11690 :
11700 rem first make sure that what we request is possible.
11710 rem colourways 4-7 are only possible if we are in 8 or 24 bit colour mode
11720 rem if it is requested in another mode, it is set to 0
11730 :
11740   if colourway%>3
11750      make_my_palette colourway%-4: rem set colours according to system palette
11760      return                         : rem premature exit
11770   endif
11780 :
11790 rem this now is only the old colourways
11800   select on mycolour_mode%
11810     =0                                  : rem QL 4 colours
11820       SELect ON colourway%
11830           =0:                           : remark white/green
11840                 menu_pap=white
11850                 menu_brd=green
11860                 menu_ink=black
11870                 menu_bar=wg_striped
11880                 menu_inv=red
11890           =1:                           : remark black/red
11900                 menu_pap=black
11910                 menu_brd=red
11920                 menu_ink=white
11930                 menu_bar=br_striped
11940                 menu_inv=green
11950           =2:                           : remark white/red
11960                 menu_pap=white
11970                 menu_brd=red
11980                 menu_ink=black
11990                 menu_bar=wr_striped
12000                 menu_inv=green
12010           =3:                           : remark black/green
12020                 menu_pap=black
12030                 menu_brd=green
12040                 menu_ink=white
12050                 menu_bar=bg_striped
12060                 menu_inv=red
12070       END SELect
12080     =1                                  : rem pal colours
12090       SELect ON colourway%
12100           =0:                           : remark white/green
12110                 menu_pap=white+256
12120                 menu_brd=green+256
12130                 menu_ink=black+256
12140                 menu_bar=wg_striped+256
12150                 menu_inv=red +256
12160           =1:                           : remark black/red
12170                 menu_pap=black+256
12180                 menu_brd=red  +256
12190                 menu_ink=white +256
12200                 menu_bar=br_striped +256
12210                 menu_inv=green +256
12220                 omenu_pap=black+256
12230           =2:                           : remark white/red
12240                 menu_pap=white +256
12250                 menu_brd=red   +256
12260                 menu_ink=black +256
12270                 menu_bar=wr_striped +256
12280                 menu_inv=green +256
12290           =3:                           : remark black/green
12300                 menu_pap=black +256
12310                 menu_brd=green +256
12320                 menu_ink=white +256
12330                 menu_bar=bg_striped +256
12340                 menu_inv=red   +256
12350       END SELect
12360     =2                                  : rem 24 bit colours
12370       SELect ON colourway%
12380           =0:                           : remark white/green
12390                 menu_pap=WL_MK16(white)
12400                 menu_brd=WL_MK16(green)
12410                 menu_ink=WL_MK16(black)
12420                 menu_bar=WL_MK16(wg_striped)
12430                 menu_inv=WL_MK16(red)
12440           =1:                           : remark black/red
12450                 menu_pap=WL_MK16(black)
12460                 menu_brd=WL_MK16(red)
12470                 menu_ink=WL_MK16(white)
12480                 menu_bar=WL_MK16(br_striped)
12490                 menu_inv=WL_MK16(green)
12500           =2:                           : remark white/red
12510                 menu_pap=WL_MK16(white)
12520                 menu_brd=WL_MK16(red)
12530                 menu_ink=WL_MK16(black)
12540                 menu_bar=WL_MK16(wr_striped)
12550                 menu_inv=WL_MK16(green)
12560           =3:                           : remark black/green
12570                 menu_pap=WL_MK16(black)
12580                 menu_brd=WL_MK16(green)
12590                 menu_ink=WL_MK16(white)
12600                 menu_bar=WL_MK16(bg_striped)
12610                 menu_inv=WL_MK16(red)
12620       END SELect
12630   end select
12640 :
12650   make_my_old_palette
12660 :
12670 END DEFine make_colours
12680 :
12690 def proc make_my_palette (cw%)
12700   sp.winbd            = hex('0200') : rem Window border
12710   sp.winbg            = hex('0201') : rem Window background
12720   sp.winfg            = hex('0202') : rem Window foreground
12730   sp.winmg            = hex('0203') : rem Window middleground
12740   sp.titlebg          = hex('0204') : rem Title background
12750   sp.titletextbg  = hex('0205') : rem Title text background
12760   sp.titlefg          = hex('0206') : rem Title foreground
12770   sp.litemhigh        = hex('0207') : rem Loose item highlight
12780   sp.litemavabg   = hex('0208') : rem Loose item available background
12790   sp.litemavafg   = hex('0209') : rem Loose item available foreground
12800   sp.litemselbg   = hex('020a') : rem Loose item selected background
12810   sp.litemselfg   = hex('020b') : rem Loose item selected foreground
12820   sp.litemunabg   = hex('020c') : rem Loose item unavailable background
12830   sp.litemunafg   = hex('020d') : rem Loose item unavailable foreground
12840   sp.infwinbd         = hex('020e') : rem Information window border
12850   sp.infwinbg         = hex('020f') : rem Information window background
12860   sp.infwinfg         = hex('0210') : rem Information window foreground
12870   sp.infwinmg         = hex('0211') : rem Information window middleground
12880   sp.subinfbd         = hex('0212') : rem Subsidiary information window border
12890   sp.subinfbg         = hex('0213') : rem Subsidiary information window background
12900   sp.subinffg         = hex('0214') : rem Subsidiary information window foreground
12910   sp.subinfmg         = hex('0215') : rem Subsidiary information window middleground
12920   sp.appbd            = hex('0216') : rem Application window border
12930   sp.appbg            = hex('0217') : rem Application window background
12940   sp.appfg            = hex('0218') : rem Application window foreground
12950   sp.appmg            = hex('0219') : rem Application window middleground
12960   sp.appihigh         = hex('021a') : rem Application window item highlight
12970   sp.appiavabg        = hex('021b') : rem Application window item available background
12980   sp.appiavafg        = hex('021c') : rem Application window item available foreground
12990   sp.appiselbg        = hex('021d') : rem Application window item selected background
13000   sp.appiselfg        = hex('021e') : rem Application window item selected foreground
13010   sp.appiunabg        = hex('021f') : rem Application window item unavailable background
13020   sp.appiunafg        = hex('0220') : rem Application window item unavailable foreground
13030   sp.scrbar           = hex('0221') : rem Pan/scroll bar
13040   sp.scrbarsec        = hex('0222') : rem Pan/scroll bar section
13050   sp.scrbararr        = hex('0223') : rem Pan/scroll bar arrow
13060   sp.buthigh          = hex('0224') : rem Button highlight
13070   sp.butbd            = hex('0225') : rem Button border
13080   sp.butbg            = hex('0226') : rem Button background
13090   sp.butfg            = hex('0227') : rem Button foreground
13100   sp.hintbd           = hex('0228') : rem Hint border
13110   sp.hintbg           = hex('0229') : rem Hint background
13120   sp.hintfg           = hex('022a') : rem Hint foreground
13130   sp.hintmg           = hex('022b') : rem Hint middleground
13140   sp.errbg            = hex('022c') : rem Error message background
13150   sp.errfg            = hex('022d') : rem Error message foreground
13160   sp.errmg            = hex('022e') : rem Error message middleground
13170   sp.shaded           = hex('022f') : rem sp.shaded area
13180   sp.3ddark           = hex('0230') : rem Dark 3D border shade
13190   sp.3dlight          = hex('0231') : rem Light 3D border shade
13200   sp.vertfill         = hex('0232') : rem Vertical area fill
13210   sp.subtitbg         = hex('0233')  : rem Subtitle background
13220   sp.subtittxtbg  = hex('0234')  : rem Subtitle text background
13230   sp.subtitfg         = hex('0235')  : rem Subtitle foreground
13240   sp.mindexbg         = hex('0236')  : rem Menu index background
13250   sp.mindexfg         = hex('0237')  : rem Menu index foreground
13260   sp.separator        = hex('0238')  : rem Seperator lines etc.
13270   if not (is_open(#0) or is_open(#1))
13280     open#1,'con'
13290     sp_jobpal -1,cw%
13300     close#1
13310   else
13320     sp_jobpal -1,cw%
13330   endif
13340 end def make_my_palette
13350 :
13360 def proc make_my_old_palette
13370 rem this translates the colours used in the wdws into 4 colour mode...
13380   sp.winbd          =         menu_ink   : rem Window border
13390   sp.winbg          =         menu_pap   : rem Window background
13400   sp.winfg          =         menu_pap   : rem Window foreground
13410   sp.winmg          =         menu_pap   : rem Window middleground
13420   sp.titlebg        =         menu_bar   : rem Title background
13430   sp.titletextbg=   menu_pap   : rem Title text background
13440   sp.titlefg        =         menu_ink   : rem Title foreground
13450   sp.litemhigh      =         menu_brd   : rem Loose item highlight
13460   sp.litemavabg =   menu_pap   : rem Loose item available background
13470   sp.litemavafg =   menu_ink   : rem Loex fifiose item available foreground
13480   sp.litemselbg =   menu_brd   : rem Loose item selected background
13490   sp.litemselfg =   menu_ink   : rem Loose item selected foreground
13500   sp.litemunabg =   menu_pap   : rem Loose item unavailable background
13510   sp.litemunafg =   menu_brd   : rem Loose item unavailable foreground
13520   sp.infwinbd       =         menu_brd   : rem Information window border
13530   sp.infwinbg       =         menu_pap   : rem Information window background
13540   sp.infwinfg       =         menu_ink   : rem Information window foreground
13550   sp.infwinmg       =         menu_pap   : rem Information window foreground
13560   sp.subinfbd       =         menu_brd   : rem Information window border (sub)
13570   sp.subinfbg       =         menu_pap   : rem Information window background
13580   sp.subinffg       =         menu_ink   : rem Information window foreground
13590   sp.subinfmg       =         menu_pap   : rem Information window foreground
13600   sp.appbd          =         menu_brd   : rem Application window border
13610   sp.appbg          =         menu_pap   : rem Application window background
13620   sp.appfg          =         menu_ink   : rem Application window foreground
13630   sp.appmg          =         menu_pap   : rem Application window middleground
13640   sp.appihigh       =         menu_ink   : rem Application window item highlight
13650   sp.appiavabg      =         menu_pap   : rem Application window item available background
13660   sp.appiavafg      =         menu_ink   : rem Application window item available foreground
13670   sp.appiselbg      =         menu_brd   : rem Application window item selected background
13680   sp.appiselfg      =         menu_ink   : rem Application window item selected foreground
13690   sp.appiunabg      =         menu_pap   : rem Application window item unavailable background
13700   sp.appiunafg      =         menu_brd   : rem Application window item unavailable foreground
13710   sp.scrbar         =         menu_ink   : rem Pan/scroll bar
13720   sp.scrbarsec      =         menu_pap   : rem bar section
13730   sp.scrbararr      =         menu_brd   : rem Pan/scroll bar arrow
13740   sp.buthigh        =         menu_ink   : rem Button highlight
13750   sp.butbd          =         menu_brd   : rem Button border
13760   sp.butbg          =         menu_pap   : rem Button background
13770   sp.butfg          =         menu_ink   : rem Button foreground
13780   sp.hintbd         =         menu_brd   : rem Hint border
13790   sp.hintbg         =         menu_ink   : rem Hint background
13800   sp.hintfg         =         menu_pap   : rem Hint foreground
13810   sp.hintmg         =         menu_ink   : rem Hint middleground
13820   sp.errbg          =         menu_inv   : rem Error message background
13830   sp.errfg          =         menu_ink   : rem Error message foreground
13840   sp.errmg          =         menu_ink   : rem Error message middleground
13850   sp.shaded         =         0            : rem sp.shaded area
13860   sp.3ddark         =         0            : rem Dark 3D border shade
13870   sp.3dlight        =         white        : rem Light 3D border shade
13880   sp.vertfill       =         menu_pap   : rem Vertical area fill
13890   sp.subtitbg       =         menu_pap   : rem Subtitle background
13900   sp.subtittxtbg=   menu_pap   : rem Subtitle text background
13910   sp.subtitfg       =         menu_ink   : rem Subtitle foreground
13920   sp.mindexbg       =         menu_pap   : rem Menu index background
13930   sp.mindexfg       =         menu_brd   : rem same,        foreground
13940   sp.separator      =         menu_brd   : rem Seperator lines etc.
13950 end def make_my_old_palette
13960 :
13970 DEFine FuNction centr$(ctr$,leng)
13980 rem this "centres" the string ctr$ (i.e. left padds it with spaces) so that
13990 rem it is centred in a window of leng width (leng is length in chars)
14000   LOCal l%,cta$
14010   cta$=ctr$
14020   strip_spaces cta$
14030   l%=INT(leng-LEN(cta$))/2
14040   if l%<0:return cta$
14050   return FILL$(' ',l%)&cta$&FILL$(' ',l%)
14060 END DEFine centr$
14070 :
14080 def proc calc_ysize (y_csize%)
14090 rem This tries to calculate the window y size depending on the given y size,
14100 rem the number of rows wished in the menu appsub window and the y position of
14110 rem the menu appsub window.
14120 rem It uses and changes the GLOBAL variables rows%, app_y_orig% and ysize%.
14130 rem It also uses the GLOBAL var maxy% which is the maximum y size a window
14140 rem could have in the current screen resolution.
14150 rem algo is as follows:
14160 rem if both ysize and rows% are undefined (=-1) : make wdw as big as possible
14170 rem if one is undefined, calc the other
14180 rem if both are defined, give precedence to the rows number
14190 rem
14200 rem param : y_csize% is the y character height, either 0 (10 pix) or 1 (20 pix)
14210 rem
14220 local y_spcg%
14230   if rows%=0:return
14240   y_spcg% = 12+(y_csize%*10)
14250   if rows%= -1
14260     if ysize%= -1
14270       rows%=(maxy%-14-app_y_orig%) div y_spcg% : rem max nbr of rows
14280     else
14290       rows%= (ysize%-app_y_orig%-4) div y_spcg%
14300     endif
14310   endif
14320   if rows%<2:rows%=2
14330   ysize%=rows%*y_spcg%+app_y_orig%+4
14340   if ysize%>=maxy%-14
14350     ysize%=maxy%-app_y_orig%-14
14360     rows%=ysize% div y_spcg%
14370     ysize%=rows%*y_spcg% + app_y_orig% + 4
14380   endif
14390   if ysize%<minysize%
14400     ysize%=minysize% -app_y_orig%-14
14410     rows%=ysize% div y_spcg%
14420     ysize%=rows%*y_spcg% + app_y_orig% + 4
14430   endif
14440 end def calc_ysize
14450 :
14460 DEFine PROCedure scroll_arrows(rows%,nbr_objects%,appfen,cty%)
14470 rem This determined whether an appsub wdw should have scroll arrows.
14480 rem Params: number of visible rows in the appsub wdw, ,total nbr of object rows
14490 rem in the abbsub wdw (not the visible rows, but the rows with objects),
14500 rem pointer to the appsub wdw defn returned by the APP_MAKE or APP_MAKE2 function
14510 rem and the control definition
14520   IF nbr_objects%<=rows%
14530     POKE_W appfen+150,0       : rem all objects fit , so no scroll arrows
14540                                         : rem and no y offset to start of menu
14550     poke_l appfen+96,0                  : rem no scroll bars
14560     cty%(1,2)=nbr_objects%    : rem nbr of columns/rows
14570   ELSE
14580     POKE_W appfen+150,6       : rem leave space for arrows
14590     cty%(1,2)=rows%-1                   : rem if scroll arrows are there, there is one line less in the window
14600     poke_l appfen+96,hex("2210222")
14610   END IF
14620   IF DIMN(cty%,1)=2:cty%(2,2)=cty%(1,2)
14630   cty%(0,1)=1                            : rem show that definition has changed
14640 END DEFine scroll_arrows
14650 :
14660 DEFine FuNction getstr$(poste%,drap%,defn,a$)
14670 REMark opens and sets a window over a loose item and proposes a sting to be edited.
14680 REMark parameters:
14690 REMark - item nbr
14700 REMark - falg whether result MUST be a numbrr (flag<>0)
14710 REMark - the working definition
14720 REMark - the string o edit
14730 rem returns the string or ""
14740 rem uses the global (!) vars sp.litemselbg and sp.litemselfg
14750 rem
14760 local b$,chan%
14770   chan%=FOPEN("con")
14780   b$=getstr2$(poste%,drap%,defn,a$,chan%)
14790   close#chan%
14800   return b$
14810 END DEFine getstr$
14820 :
14830 DEFine FuNction getstr2$(poste%,drap%,defn,a$,chan%)
14840 REMark sets a window over a loose item and proposes a sting to be edited.
14850 REMark parameters:
14860 REMark - item nbr
14870 REMark - falg whether result MUST be a numbrr (flag<>0)
14880 REMark - the working definition
14890 REMark - the string o edit
14900 remark - a screen channel to be used
14910 rem returns the string or ""
14920 rem uses the global (!) vars sp.litemselbg and sp.litemselfg
14930 rem
14940   LOCal b$,res
14950   b$=" ":b$=a$           : REMark c'est curieusement nƒcessaire
14960   wm_PAPER#chan%,sp.litemselbg
14970   wm_INK#chan%,sp.litemselfg
14980   DR_LWDF#chan%,defn,poste%             : rem open channel over item
14990   CLS#chan%
15000   res=GET_STR(#chan%,drap%,b$)                                : rem get string
15010   IF res<0:b$=""                        : rem ooops
15020   CH_ITEM defn,-1,poste%,-1,"",b$
15030   RETurn b$
15040 END DEFine getstr2$
15050 :
15060 def fn showcont$(string$,length%)
15070 rem this adds '...' at the end of a string, to show that it continues
15080 local l%,lengt%
15090   l%=len(string$)
15100   if not l%:return ""                             : rem empty string
15110   lengt%=length% div 6
15120   if l%<=lengt%:return string$                    : rem entire string fits wdw
15130   return string$(1 to lengt%-3)&"..."
15140 end def showcont$
15150 :
15160 def fn get_free_text$(defn,item%,prompt$,length%)
15170 rem this opens wdw over loose-item item% of the working definition defn
15180 rem allows free text to be entered
15190 rem params: working defintion,item over which wdw is to be opened
15200 rem           first value of string, length of max string in wdw, if this is...
15210 rem              -1, the length will be determined here
15220 local chan%,string$,tempsizes%(3)
15230   chan%=fopen('con')
15240   if chan%<0:return prompt$
15250   dr_lwdf#chan%,defn,item%              : rem open wdw over item
15260   paper#chan%,menu_brd
15270   ink#chan%,menu_ink
15280   cls#chan%
15290   string$=wedit$(#chan%,prompt$)
15300   if length%=-1
15310      wsipo#chan%,tempsizes%
15320      length%=tempsizes%(0)
15330   endif
15340   close#chan%
15350   if length%
15360     ch_item defn,-1,item%,-1,"",showcont$(string$,length%)
15370   else
15380     ch_item defn,-1,item%,-1,"",string$
15390   endif
15400   return string$
15410 end def get_free_text$
15420 :
15430 def proc make_my_palette (cw%)
15440   sp.winbd            = hex('0200') : rem Window border
15450   sp.winbg            = hex('0201') : rem Window background
15460   sp.winfg            = hex('0202') : rem Window foreground
15470   sp.winmg            = hex('0203') : rem Window middleground
15480   sp.titlebg          = hex('0204') : rem Title background
15490   sp.titletextbg  = hex('0205') : rem Title text background
15500   sp.titlefg          = hex('0206') : rem Title foreground
15510   sp.litemhigh        = hex('0207') : rem Loose item highlight
15520   sp.litemavabg   = hex('0208') : rem Loose item available background
15530   sp.litemavafg   = hex('0209') : rem Loose item available foreground
15540   sp.litemselbg   = hex('020a') : rem Loose item selected background
15550   sp.litemselfg   = hex('020b') : rem Loose item selected foreground
15560   sp.litemunabg   = hex('020c') : rem Loose item unavailable background
15570   sp.litemunafg   = hex('020d') : rem Loose item unavailable foreground
15580   sp.infwinbd         = hex('020e') : rem Information window border
15590   sp.infwinbg         = hex('020f') : rem Information window background
15600   sp.infwinfg         = hex('0210') : rem Information window foreground
15610   sp.infwinmg         = hex('0211') : rem Information window middleground
15620   sp.subinfbd         = hex('0212') : rem Subsidiary information window border
15630   sp.subinfbg         = hex('0213') : rem Subsidiary information window background
15640   sp.subinffg         = hex('0214') : rem Subsidiary information window foreground
15650   sp.subinfmg         = hex('0215') : rem Subsidiary information window middleground
15660   sp.appbd            = hex('0216') : rem Application window border
15670   sp.appbg            = hex('0217') : rem Application window background
15680   sp.appfg            = hex('0218') : rem Application window foreground
15690   sp.appmg            = hex('0219') : rem Application window middleground
15700   sp.appihigh         = hex('021a') : rem Application window item highlight
15710   sp.appiavabg        = hex('021b') : rem Application window item available background
15720   sp.appiavafg        = hex('021c') : rem Application window item available foreground
15730   sp.appiselbg        = hex('021d') : rem Application window item selected background
15740   sp.appiselfg        = hex('021e') : rem Application window item selected foreground
15750   sp.appiunabg        = hex('021f') : rem Application window item unavailable background
15760   sp.appiunafg        = hex('0220') : rem Application window item unavailable foreground
15770   sp.scrbar           = hex('0221') : rem Pan/scroll bar
15780   sp.scrbarsec        = hex('0222') : rem Pan/scroll bar section
15790   sp.scrbararr        = hex('0223') : rem Pan/scroll bar arrow
15800   sp.buthigh          = hex('0224') : rem Button highlight
15810   sp.butbd            = hex('0225') : rem Button border
15820   sp.butbg            = hex('0226') : rem Button background
15830   sp.butfg            = hex('0227') : rem Button foreground
15840   sp.hintbd           = hex('0228') : rem Hint border
15850   sp.hintbg           = hex('0229') : rem Hint background
15860   sp.hintfg           = hex('022a') : rem Hint foreground
15870   sp.hintmg           = hex('022b') : rem Hint middleground
15880   sp.errbg            = hex('022c') : rem Error message background
15890   sp.errfg            = hex('022d') : rem Error message foreground
15900   sp.errmg            = hex('022e') : rem Error message middleground
15910   sp.shaded           = hex('022f') : rem sp.shaded area
15920   sp.3ddark           = hex('0230') : rem Dark 3D border shade
15930   sp.3dlight          = hex('0231') : rem Light 3D border shade
15940   sp.vertfill         = hex('0232') : rem Vertical area fill
15950   sp.subtitbg         = hex('0233')  : rem Subtitle background
15960   sp.subtittxtbg  = hex('0234')  : rem Subtitle text background
15970   sp.subtitfg         = hex('0235')  : rem Subtitle foreground
15980   sp.mindexbg         = hex('0236')  : rem Menu index background
15990   sp.mindexfg         = hex('0237')  : rem Menu index foreground
16000   sp.separator        = hex('0238')  : rem Seperator lines etc.
16010   if cw%
16020     if not (is_open(#0) or is_open(#1))
16030       open#1,'con'
16040       sp_jobpal -1,cw%
16050       close#1
16060     else
16070       sp_jobpal -1,cw%
16080     endif
16090   endif
16100 end def make_my_palette
16110 :
16120 def fn set_colours% (force_mode%)
16130 rem this sets colour variables according to the colour mode wished, if possible.
16140 rem force_mode%=
16150 rem       0 if ql colours wished (mode 4 only)
16160 rem       1 if pal colours wished
16170 rem       2 if 24 bit colours wished
16180 rem This function returns the true QL mode set (4,8,32,33 etc.).
16190 rem This function also sets the GLOBAL variable mycolour_mode% to the
16200 rem mode 0,1,2 as above - whatever is possible on the machine, i.e.
16210 rem if colour_24 is wished on a 4 colour machine (which won't succeed)
16220 rem this function will set set that variable to 0, i.e. QL mode.
16230 rem
16240 rem This function needs the outptr toolkit
16250 local mode%
16260   mode%=rmode                                     : rem get current mode now
16270   select on force_mode%
16280       = 0                                         : rem mode 4 wished
16290        select on mode%
16300             = 4                                   : rem already on, so do nothing
16310             = 0,1,8 : mode 4            : rem old modes, set to 4 colours
16320             = remainder
16330               colour_ql                           : rem if higher colour mode, set to "mode 4"
16340               mode 4
16350        end select
16360        mode%=0                                    : rem new mode we're in  - 4 colour mode
16370       = 1                                         : rem PALette wished
16380        select on mode%
16390             = 16,32,33 : colour_pal:mode%=1  : rem we're in high colour mode, but PAL colours wished
16400             = remainder
16410               if mode%<>4:mode 4
16420               mode%=0
16430        end select
16440       = 2
16450        select on mode%
16460             = 32,33 : colour_24 :mode%=2          : rem we're in high col mode 24 bit colours
16470             = 16 : colour_pal : mode%=1
16480             = remainder
16490               if mode%<>4:mode 4
16500               mode%=0
16510        end select
16520   end select
16530   mycolour_mode%=mode%                            : rem set this global variable now:
16540   rem now set some colour variables
16550   select on mode%
16560        = 0                                        : rem Ql 4 mode colours
16570           Black            = 0
16580           White            = 7
16590           Red              = 2
16600           Green            = 4
16610           wg_striped     = 92
16620           br_striped     = 82
16630           wr_striped     = 107
16640           bg_striped     = 100
16650        = 1                              : rem Colour_pal
16660           Black            = 0
16670           White            = 1
16680           Red              = 2
16690           Green            = 3
16700           wg_striped     = light_green
16710           br_striped     = dark_red
16720           wr_striped     = light_red
16730           bg_striped     = dark_green
16740        = 2                              : rem colour_24
16750           Black            = hex('000000')
16760           White            = hex('FFFFFF')
16770           Red              = hex('FF0000')
16780           Green            = hex('00FF00')
16790           wg_striped     = light_green
16800           br_striped     = dark_red
16810           wr_striped     = light_red
16820           bg_striped     = dark_green
16830   end select
16840   mode%=rmode
16850   ret mode%                             : rem return current screen mode now
16860 end def set_colours%
16870 :
16880 def fn do_caps(a$,caps%)
16890 rem set string to capitales etc,caps% determines whether the string....
16900 REMark ...must be lower case (=0), upper case(=1), all words capitalized (=2),
16910 REMark ... first word only capitalized (=3), or nothing(=-1)
16920   SELect ON caps%
16930    =0: MIN a$
16940    =1: MAJ a$
16950    =2: CAP2 a$
16960    =3: CAP a$
16970   END SELect
16980   return a$
16990 end def do_caps
17000 :
17010 def fn mk_main_app (app_addr,subwinarray$,x_csize%,y_csize%, use_apm2%,hit_is_do%,sizex%,origx%)
17020 rem This makes a standard menu appsub with standard global variables.
17030 rem It presumes that the followng vars have been set:
17040 rem  * rows% holds the number of rows to be seen in the appsub window when there
17050 rem    are no scroll arrows (if there are, 1 less row will be seen)
17060 rem  * app_y_orig% = y origin of appsub within the main wdw
17070 rem  * xsize% = x size of main window (NOT subwindow)
17080 rem  * menu_selkeys$ holds the selkeys to exclude (string with upper cased keys)
17090 rem  *      set to "" if no selkeys wished, set to " " if no selkeys are excluded
17100 rem  * appw_sections% holds the nbr of sections to show
17110 rem  * main_cty% (DIMed here) is the  control sections array
17120 rem  * main_mfl% (DIMed here) is the menu items flag array
17130 rem
17140 rem Params:
17150 rem  * app_addr is the address of the appsub window, but 0 on first call
17160 rem  * subwinarry$ holds the data (2 dimensional string array)
17170 rem  * x, y_csize% are the csizes of objects in the appsub, standard values
17180 rem  * use_apm2% whether we use (=1) AP_MAKE2 or not (=0)
17190 rem  * hit_is_do% if hit should be = do
17200 rem  * sizex%= wished x size, leave at 0 if automatic size wished
17210 rem  * origx%= wished x orig, leave at 0 if automatic orig wished
17220 rem
17230 local temp%,selk%,app_attrs%(3,1),xs%,xo%
17240   if app_addr:rechp app_addr
17250   dim main_cty%(0):dim main_mfl%(0,0)
17260   temp%=x_csize%*16                               : rem x csize into upper nibble
17270   temp%=(temp%+y_csize%)*256            : rem y into lower, all into upper byte
17280   temp%=temp%+appw_sections%            : rem temp% is changed by the call to fen_app
17290   if menu_selkeys$=""
17300     selk%=0                                       : rem use no selkeys
17310   else
17320     selk%=1
17330   endif
17340   if hit_is_do%:selk%=selk%+256         : rem hit should be do
17350   if sizex%<1
17360     xs%=xsize%-16
17370   else
17380     xs%=sizex%
17390   endif
17400   if origx%<1
17410     xo%=0
17420   else
17430     xo%=origx%
17440   endif
17450   if use_apm2%
17460     app_addr=ap_make2(selk%,xs%,rows%,xo%,app_y_orig%,temp%,subwinarray$)
17470   else
17480     app_addr=ap_make(selk%,xs%,rows%,xo%,app_y_orig%,temp%,subwinarray$,menu_selkeys$&" ")
17490   endif                                 : rem on return temp%=nbr of objects
17500   IF app_addr = 0: RETurn 0             : rem  error, return 0
17510 :
17520   dim main_cty%(appw_sections%,2)       : rem control defn
17530   main_cty%(0,0)=1                      : rem at start show 1 section
17540   if temp%>rows%
17550     main_cty%(1,2)=rows%                : rem nbr of rows to show
17560   else
17570     main_cty%(1,2)=temp%                : rem there are less objects than rows
17580   endif
17590   main_cty%(1,2)=rows%
17600   if appw_sections%=2:main_cty%(2,2)=2
17610   if temp%
17620      dim main_mfl%(temp%-1,0)                     : rem flag array if there are any objects
17630   end if
17640   scroll_arrows rows%,temp%,app_addr,main_cty%
17650   return app_addr
17660 end define mk_main_app
17670 :
17680 def proc make_standard_sprites
17690 rem This makes standard move, sleep and wake sprites and sets the
17700 rem GLOBAL vars move_sprite,, sleep_sprite, wake_sprite and size_sprite to them.
17710 rem If there are system sprites, these are used.
17720 rem This also makes the "main_sprite" pointer sprite.
17730 :
17740   espace_vide=ALCHP(100)         : rem for pointers with no mask
17750 :
17760 restore 17760
17770   main_sprite=RD_SPRT(0)         : REMark ici un masque normal
17780     data 11,13,6,5,4
17790     data '     www     '
17800     data '     waw     '
17810     data '     waw     '
17820     data '     waw     '
17830     data 'wwwwwa awwwww'
17840     data 'waaaa   aaaaw'
17850     data 'wwwwwa awwwww'
17860     data '     waw     '
17870     data '     waw     '
17880     data '     waw     '
17890     data '     www     '
17900 :
17910   if sys_tspr_addr(6)<>0
17920     move_sprite=6
17930   else
17940 restore 17940
17950     move_sprite=RD_SPRT(1)         : REMark ici un masque 0
17960     data 10,14,5,4,4
17970     data 'aaaaaaaaaa    '
17980     data 'awwwwwwwwa    '
17990     data 'awwrrrrwwa    '
18000     data 'awwrrrrwwaaaaa'
18010     data 'awwrrwwwwwwwwa'
18020     data 'awwwwwwwwrrwwa'
18030     data 'aaaaawwrrrrwwa'
18040     data '    awwrrrrwwa'
18050     data '    awwwwwwwwa'
18060     data '    aaaaaaaaaa'
18070   endif
18080 :
18090   if sys_tspr_addr(10)<>0
18100     sleep_sprite=10
18110   else
18120 restore 18120
18130     sleep_sprite= RD_SPRT(1)             : REMark ici un masque 0
18140     data 7,15,0,0,4
18150     data 'wwwww          '
18160     data '   w           '
18170     data '  w  wwww      '
18180     data ' w     w       '
18190     data 'wwwww w  wwww  '
18200     data '     wwww  w   '
18210     data '          wwww '
18220   endif
18230 :
18240   if sys_tspr_addr(11)<>0
18250     wake_sprite=11
18260   else
18270 restore 18270
18280     wake_sprite=RD_SPRT(1)          : REMark ici un masque 0
18290     data 9,14,0,0,4
18300     data "             w"
18310     data "            w "
18320     data "      w   ww  "
18330     data "     ww www   "
18340     data "    wwwwww    "
18350     data "   www ww     "
18360     data "  w   w      "
18370     data " w            "
18380     data "w             "
18390   endif
18400 :
18410   if sys_tspr_addr(7)<>0
18420     size_sprite=7
18430   else
18440 restore 18440
18450     size_sprite=RD_SPRT(1)
18460     data 9,14,5,4,4
18470     data 'aaaaaaaaaaaaaa'
18480     data 'awwwwwwwwwwwwa'
18490     data 'awwrrrrrrrrwwa'
18500     data 'awwrrrrrrrrwwa'
18510     data 'awwrrwwwwwwwwa'
18520     data 'awwrrwwrrrrwwa'
18530     data 'awwrrwwrrrrwwa'
18540     data 'awwwwwwwwwwwwa'
18550     data 'aaaaaaaaaaaaaa'
18560   endif
18570 :
18580 end def make_standard_sprites
18590 :
18600 DEFine PROCedure warn_make
18610 rem makes warning & info window
18620 rem uses global vars sp.xxx
18630 rem SETS the global var warning_width% (nbr of chars in one line in wdw)
18640 local lys%,warn_lot,warn_iot1,warn_iwt
18650 local x%,y%,warning_paper,warning_brd
18660 restore 18660
18670   x%=200:y%=82
18680   lys%=10
18690   DIM warn_lfl%(1)
18700   warn_lot=RD_LOT(std_iattr,1)
18710     DATA 30,lys%,4,4,0,0,cancel$,text+retr,'ESC'
18720     DATA 30,lys%,x%-34,4,0,0,'O',text+retr,"OK"
18730 :
18740   warn_iot1=RD_IOT (0)
18750     DATA 12*9,10,0,1,text,sp.errfg,2,0,'Attention'
18760 :
18770   warn_iwt=RD_IWT(1)
18780     DATA x%-16,y%-32,8,24
18790     DATA 0,1,sp.winbd,sp.errbg
18800     DATA 0
18810 :
18820     DATA 110,12,(x%-110) div 2,4
18830     DATA 0,1,sp.winbd,sp.errbg
18840     DATA warn_iot1
18850 :
18860   warn_defn=RD_WDEF
18870     DATA 2,1,sp.winbd,sp.errbg
18880     DATA x%,y%,0,0
18890     DATA main_sprite,warn_lot,warn_iwt,0
18900 :
18910   warning_width%=(x%-16) div 6                    : rem width of warning window in chars
18920   info_is_pulled_down%=0
18930   warn_wdw_addr=peek_l(warn_defn+100)+20: rem ptr to 2nd info wdw
18940  rem warn_wdw_addr=peek_l(warn_wdw_addr+16): rem ptr to object list
18950 END DEFine warn_make
18960 :
18970 DEFine PROCedure about_make (titre$,version$)
18980 local lxs%,lys%,xesp%,inf1y%,abt_lot,longueur_titre%,titre_x%
18990 local abt_iwt,abt_iot1,abt_iot2
19000   ab_xt%=200:ab_yt%=120    : REMark tailles x et y: la taille x devrait
19010                                    : REMark ‘tre un chiffre divisible par 4
19020   lxs%=24:lys%=10                    : REMark tailles x et y pour postes standard
19030   inf1y%=lys%+4            : REMark posi. y de la fen. d'inf. intƒrieure
19040   xesp%=lxs%+2
19050   nbr_post%=0                      : REMark nombre de postes dans un coin
19060 :
19070 restore 19070
19080 wolfsoft_sprite=rD_SPrT(0)
19090     DATA 23,51,0,0,4
19100     DATA 'rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr'
19110     DATA 'rrgggggggggggggggggggggggggggggggggggggggggggggggrr'
19120     DATA 'rrggggggggrrrrrrrrrrrrrrrrgggggggggggggggggggggggrr'
19130     DATA 'rrgggggggggggggggggggggrgggggggggggggggggggggggggrr'
19140     DATA 'rrggggggggggggggggggggrggggggggggggggggggggggggggrr'
19150     DATA 'rrggggggggagggggagggrrrrrrrrrrrrrggaaaaaaaaggggggrr'
19160     DATA 'rrggggggggagggggaggggggggggggggggggagggggggggggggrr'
19170     DATA 'rrggggggggaggaggaggaaaaaaaggaggggggaaaaaaagggggggrr'
19180     DATA 'rrggggggggagaaagaggaawwaaaggaggggggagggggggggggggrr'
19190     DATA 'rrggggggggaaagaaaggaawwwwaggaggggggagggggggggggggrr'
19200     DATA 'rrggrrrrrgaagggaaggawwwwaaggaggggggagggggrrrrrrrgrr'
19210     DATA 'rrgrgggggrgggggggggaaawwaaggaggggggggggrrrgggggggrr'
19220     DATA 'rrgrggggggrggggggggaaaaaaaggaaaaaagggrrggrgggggggrr'
19230     DATA 'rrgrgggggggggggggrrrgggggggggggrrrggrggggrgggggggrr'
19240     DATA 'rrggrrrrrrggggggrgggrrgggggggrrggggggggggrgggggggrr'
19250     DATA 'rrggggggggrrrgggrgggggrrgggrrggggggggggggrgggggggrr'
19260     DATA 'rrgggggggggggrggrgggggggrggrgggggggggggggrgggggggrr'
19270     DATA 'rrggggggggggggrgrggggggggrgrrrrrrrgggggggrgggggggrr'
19280     DATA 'rrgrggggggggggrgrggggggggrgrgggggggggggggrgggggggrr'
19290     DATA 'rrggrgggggggrrgggrggggggrggrgggggggggggggrgggggggrr'
19300     DATA 'rrgggrrrrrrrggggggrrrrrrgggrgggggggggggggrgggggggrr'
19310     DATA 'rrgggggggggggggggggggggggggggggggggggggggggggggggrr'
19320     DATA 'rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr'
19330 :
19340   yinf1y%=inf1y%+4:
19350 :
19360   DIM abt_lfl%(0)
19370   abt_lot=RD_LOT(std_iattr,0)
19380     DATA ab_xt%-16,lys%,8,ab_yt%-lys%-8,0,0,cancel$,text+retr,'Super!'
19390 :
19400 : REMark  D'abord le titre qui est un objet d'une sous-fen‘tre d'info.
19410 :
19420   longueur_titre%=LEN(" Version "&version$)*6               : REMark on calcule la taille et la
19430   titre_x%=INT((ab_xt%-longueur_titre%)/2)  : REMark position x de cet objet
19440   abt_iot2=RD_IOT(1)
19450     DATA longueur_titre%,lys%,4,8,text,sp.winfg,0,0," Version "&version$
19460     DATA 52,24,ab_xt%-60,40,sprite,0,wolfsoft_sprite
19470   longueur_titre%=LEN(titre$)*6     : REMark on calcule la taille et la
19480   titre_x%=INT((ab_xt%-longueur_titre%)/2)  : REMark position x de cet objet
19490   abt_iot1=RD_IOT(0)
19500     DATA longueur_titre%,lys%,4,INT((lys%-10)/2),text,sp.titlefg,0,0,titre$
19510   abt_iwt=RD_IWT(2)               : REMark on veut 3 sous-fen. d'info
19520 REMark d'abord la fen‘tre contenant la barre entourant le titre
19530     DATA ab_xt%-8-(2*nbr_post%*xesp%),lys%+2,xesp%*nbr_post%+4,0  : REMark taille x,y, origines x,y
19540     DATA 0,0,sp.infwinbd,sp.titlebg     : REMark ombre, taille & couleur bordure
19550                                    : REMark puis couleur papier
19560     DATA 0                         : REMark pointeur vers objets
19570 REMark maintenant la fen‘tre qui contient le titre
19580     DATA longueur_titre%+8,lys%,titre_x%-2,2   : REMark on utilise titre_x% etc
19590     DATA 0,0, sp.infwinbd,sp.titletextbg
19600     DATA abt_iot1                 : REMark un objet, le titre
19610 REMark maintenant la fen‘tre de la bordure intƒrieure
19620     DATA ab_xt%-8,ab_yt%-inf1y%-2,4,inf1y%
19630     DATA 0,1,sp.infwinbd,sp.infwinbg
19640     DATA abt_iot2
19650   abt_defn=RD_WDEF
19660     DATA 2,1,sp.winbd,sp.winbg: REMark ombre, larg. & coul. bord., coul. papier
19670     DATA ab_xt%,ab_yt%,10,10 : REMark taille x,y et position pointeur
19680     DATA main_sprite,abt_lot,abt_iwt,0
19690 :
19700 end def about_make
19710 :
19720 DEFine PROCedure about (datet$)
19730   LOCal loop%,item%,dummy%,chan%
19740   DR_PULD abt_defn,-1,-1,abt_lfl%
19750   chan%=fopen('con')
19760   dr_iwdf#chan%,abt_defn,2
19770   wm_ink#chan%,sp.infwinfg
19780   wm_paper#chan%,sp.infwinbg
19790   at#chan%,4,2
19800   print#chan%,"Copyright (C) "
19810   at#chan%,5,2
19820   print#chan%, datet$
19830   at#chan%,6,2
19840   print#chan%,"Wolfgang H. Lenerz"
19850   close#chan%
19860   REPeat loop%
19870     RD_PTR abt_defn,item%,dummy%,dummy%,dummy%,dummy%,abt_lfl%
19880     SELect ON item%
19890             =0       : EXIT loop%
19900     END SELect
19910   END REPeat loop%
19920   DR_UNST abt_defn
19930 END DEFine about
19940 :
19950 def proc do_popup(string$)
19960 rem this pops up a small "hint" window showing the string$ passed
19970 rem as parameter.
19980 rem The string MUST be 1 line long and MUST fit
19990 rem inside the window (YOU must make sure of that!)
20000   do_popup2 string$,0
20010 end def do_popup
20020 :
20030 def proc popup_make
20040 rem make a small window defn
20050 local x%,y%,p_iot,popsub(0)
20060 restore 20060
20070   p_sprt=rd_sprt(0)                     : rem make an invisible pointer, all transparent
20080     data 1,2,0,0,4
20090     data '  '
20100   x%=14                                 : rem bogus window sizes
20110   y%=10
20120   popsub(0)=rd_appw                     : rem the info wdw
20130     DATA x%,y%,0,0
20140     DATA 0,0, sp.hintbd,sp.hintbg
20150     DATA 0,""
20160   popup_defn=RD_WDEF                    : rem the working defn
20170     DATA 0,1,sp.hintbd,sp.hintbg        : rem no shadow, border size & col, paper col
20180     DATA x%,y%,40,2
20190     DATA p_sprt,0,0,mk_awl(popsub)
20200 end def popup_make
20210 :
20220 def proc do_popup2(string$,main_defn)
20230 rem This pops up a small "hint" window showing the string$ passed
20240 rem as parameter.
20250 rem main_defn is the working defintion of the window over which the hint
20260 rem window is to hover. Position the pointer there where you need it before
20270 rem calling this.
20280 rem If the string is too long to fit into the window (which can only be as long
20290 rem as the outline of the working defn) then the string is split up at the
20300 rem first convenient space and put on a second line, and so on.
20310 rem If this would lead to the hint window being too high, only as many
20320 rem lines as possible will be displayed.
20330 rem !!!!!
20340 rem This presumes that a char is 10 pixels high & 6 pixels wide (standard ql 6x10 matrix)..
20350 rem !!!!!
20360 rem The string may contain the char chr$(10) - there will be a newline.
20370 rem
20380 rem note : do not try to pass a screen chaneel, open & close one here.
20390 rem
20400 local dummy%,lp%,address,con%,temp%,lastspace%,xs%,ys%,temp$
20410 local hint$(10),slen% ,maxlength%,popup_lfl%(0),popup_mfl%(0,0)
20420   if string$="":return                  : rem empty string, do nothing
20430   strip_spaces string$                 : rem no spaces at ends
20440   con%=fopen("con")
20450   if main_defn<>0
20460     xs%=peek_w (main_defn+32)
20470     ys%=peek_w(main_defn+34)            : rem get max sizes the hint wdw may have
20480   else
20490     scr_size#con%,xs,ys%
20500   endif
20510   xs%=(xs%-4) div 6                     : rem max nbr of chars in 1 line
20520   ys%=(ys%-4) div 10                    : rem max nbr of lines in wdw
20530   if xs%=0 or ys%=0:close#con%:return   : rem nothing will really fit, just leave
20540   dim hint$(ys%,xs%)                    : rem array to contain string
20550   rem now parse the string, find newlines, make sure of string length
20560   dummy%=1                              : rem start of current string section
20570   temp%=0                               : rem line
20580   slen%=0                               : rem current length of string
20590   for lp%=1 to len(string$)
20600     if string$(lp%)=chr$(10)
20610       hint$(temp%)=string$(dummy% to lp%-1): rem cut string here
20620       temp%=temp%+1
20630       if temp%=ys%:exit lp%             : rem max nbr of lines reached
20640       dummy%=lp%+1                      : rem this is where new start of string is
20650       lastspace%=lp%
20660     else
20670       if string$(lp%)=" "
20680         lastspace%=lp%                  : rem this is where last space is
20690       endif
20700     endif
20710     slen%=slen%+1                       : rem one more char
20720     if slen% > xs%
20730       hint$(temp%)=string$(dummy% to lastspace%-1) : rem too many chars in line
20740       slen%=0
20750       temp%=temp%+1                     : rem we need nother line
20760       if temp%=ys%:exit lp%             : rem max nbr of lines reached
20770       dummy%=lastspace%+1
20780     endif
20790   end for lp%
20800   if temp%<ys%
20810      hint$(temp%)=string$(dummy% to)       : rem add last part
20820      temp%=temp%+1
20830   endif
20840   maxlength%=0
20850   for lp%=0 to temp%
20860     temp$= hint$(lp%)
20870     strip_spaces temp$                 : rem use intermediary var, because of QLIB
20880     if maxlength%<len(temp$):maxlength%=len (temp$)
20890   end for lp%
20900   lp%=(maxlength%*6)+4                  : rem hint window length
20910   poke_w popup_defn+32,lp%              : rem set window xsize
20920   poke_w popup_defn+34,temp%*10+2       : rem
20930   address=peek_l(popup_defn+112)        : rem ptr to app sub wdw...
20940   address=peek_l(address)               : rem ...now
20950   poke_w address,lp%-2                  : rem set its length
20960   poke_w address+2,temp%*10             : rem set its height
20970   dr_puld popup_defn,-1,-1,popup_lfl%,popup_mfl%
20980   dr_awdf#con%,popup_defn,0             : rem pull wdw over info wdw
20990   wm_paper#con%,sp.hintbg
21000   wm_ink#con%,sp.hintfg
21010   for lp%=0 to dimn(hint$,1)
21020     if hint$(lp%)<>"":temp$=hint$(lp%):strip_spaces temp$:print#con%,temp$
21030   end for lp%
21040   temp%=0:slen%=0:xs%=0:ys%=0:dummy%=0
21050   RD_PTR popup_defn,temp%,dummy%,slen%,xs%,ys%,popup_lfl%,popup_mfl%: rem comes back immediatley
21060   RD_PTR popup_defn,temp%,dummy%,slen%,xs%,ys%,popup_lfl%,popup_mfl%
21070   close#con%
21080   dr_unst popup_defn
21090 end def do_popup2
21100 :
21110 DEFine FuNction RD_SPRT(drap%)
21120 REMark drap% determine si masque 0
21130   LOCal tmp_patt$(32,32)
21140   LOCal xs,ys,xo,yo, md, l
21150   READ ys,xs,xo,yo,md
21160   DIM tmp_patt$(ys,xs)
21170   FOR l=0 TO ys-1:READ tmp_patt$(l)
21180   l=ALCHP(SPRSP(xs,ys))
21190   SPSET l,xo,yo,md,tmp_patt$(0 TO ys-1,1 TO xs)
21200   IF drap%
21210     POKE_L l+16,espace_vide-(l+16)
21220   END IF
21230   RETurn l
21240 END DEFine RD_SPRT
21250 :
21260 DEFine FuNction RD_WDEF
21270 rem read window defn
21280   LOCal ldef%(3), lspr, lloose, linfo, lappl, lattr%(3)
21290   RD_WATT lattr%
21300   READ ldef%(0), ldef%(1), ldef%(2), ldef%(3)
21310   READ lspr, lloose, linf, lappl
21320   RETurn MK_WDEF (ldef%, lattr%, lspr, lloose, linf, lappl)
21330 END DEFine RD_WDEF
21340 :
21350 DEFine FuNction RD_LOT (lattr,nitem)
21360   LOCal count(3)
21370   LOCal item, ltyp, a$, lsk$
21380   LOCal ldef%(nitem,6), lptr(3,nitem), lstr$(nitem,85)
21390   lsk$=''
21400   FOR item = 0 TO nitem
21410     READ ldef%(item,0), ldef%(item,1), ldef%(item,2), ldef%(item,3)
21420     READ ldef%(item,4), ldef%(item,5)
21430     READ a$: lsk$=lsk$ & a$
21440     READ ltyp
21450     ldef%(item,6)=ltyp: ltyp=(ltyp MOD 256)/2
21460     IF ltyp>10 or ltyp <0:ltyp=0
21470     IF ltyp
21480       READ lptr(ltyp,count(ltyp))
21490     ELSE
21500       READ lstr$(count(0))
21510     END IF
21520     count(ltyp)=count(ltyp)+1
21530   END FOR item
21540   RETurn MK_LIL (lattr, ldef%(TO, 0 TO 1), ldef%(TO, 2 TO 3), ldef%(TO, 4 TO 5), lsk$, ldef%(TO, 6), lstr$, lptr(1), lptr(2), lptr(3))
21550 END DEFine RD_LOT
21560 :
21570 DEFine FuNction RD_IWT(nitem)
21580   LOCal item,mc1
21590   LOCal ldef%(nitem,3), latt%(nitem,3), lptr(nitem)
21600   FOR item = 0 TO nitem
21610     READ ldef%(item,0), ldef%(item,1), ldef%(item,2), ldef%(item,3)
21620     READ latt%(item,0), latt%(item,1), latt%(item,2), latt%(item,3)
21630     READ lptr(item)
21640   END FOR item
21650   RETurn MK_IWL (ldef%, latt%, lptr)
21660 END DEFine RD_IWT
21670 :
21680 DEFine FuNction RD_IOT(nitem)
21690   LOCal count(3)
21700   LOCal item, ltyp, work1, work2
21710   LOCal ldef%(nitem,4), lptr(3,nitem), lstr$(nitem,85)
21720   FOR item = 0 TO nitem
21730     READ ldef%(item,0), ldef%(item,1), ldef%(item,2), ldef%(item,3)
21740     READ ltyp
21750     ldef%(item,4)=ltyp:  ltyp=(ltyp MOD 256)/2
21760     IF ltyp >10:ltyp=0
21770     IF ltyp
21780       READ lptr(0,item),lptr(ltyp,count(ltyp))
21790     ELSE
21800       if mycolour_mode%=2
21810           read work1,work2,work3
21820           lptr(0,item)=WL_4_IOL(work1,work2,work3)
21830       else
21840           READ work1
21850           READ work2: work1=work1*256+work2
21860           READ work2: lptr(0,item)=work1*256+work2
21870       endif
21880       READ lstr$(count(0))
21890     END IF
21900     count(ltyp) = count(ltyp) + 1
21910   END FOR item
21920   RETurn MK_IOL (ldef%(TO, 0 TO 1), ldef%(TO, 2 TO 3), lptr(0), ldef%(TO, 4), lstr$, lptr(1), lptr(2), lptr(3))
21930 END DEFine RD_IOT
21940 :
21950 DEFine PROCedure RD_IATT (lattr)
21960   LOCal i
21970   READ lattr(0,0), lattr(0,1)
21980   FOR i=1 TO 3: READ lattr(i,0), lattr(i,1), lattr(i,2), lattr(i,3)
21990 END DEFine RD_IATT
22000 :
22010 DEFine PROCedure RD_WATT (lattr%)
22020   READ lattr%(0), lattr%(1),lattr%(2),lattr%(3)
22030 END DEFine RD_WATT
22040 :
22050 DEFine FuNction RD_APPW
22060   LOCal ldef%(3), lspr, sk$, lattr%(3)
22070   READ ldef%(0), ldef%(1), ldef%(2), ldef%(3)
22080   RD_WATT lattr%
22090   READ lspr, sk$
22100   RETurn MK_APPW (ldef%, lattr%, lspr,sk$)
22110 END DEFine
22120 :
