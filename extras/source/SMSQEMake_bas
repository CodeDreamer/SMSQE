10 REMark $$asmb=dev8_extras_source_outptr_bin,0,10
20 REMark $$asmb=dev1_booty_qptr_bin,50,172
30 REMark $$asmb=dev8_extras_source_SMSQEMake_bin,0,10
40 REMark $$stak=50000
50 rem compiled with the basic_linker
60 :
70 compiled=not is_open(#0)
80 if not compiled
90   check_for_PE
100   clear:clchp
110   scr_size#0,maxx%,maxy%
120   maxy%=maxy%-28
130   outln#0,maxx%,maxy%,0,28
140   wset -1
150 else
160   open#1,"con"
170   check_for_PE
180   scr_size#1,maxx%,maxy%
190 end if
200 :
210 init
220 main
230 stop
240 :
250 def proc check_for_PE
260   if p_env(#1)<>2
270     cls#1:ink#1,2:print#1,"This software works only in the pointer environment"
280     a$=inkey$(#1,-1)
290     stop
300   end if
310 end def check_for_PE
320 :
330 DEFine PROCedure init
340 LOCal temp%,targets%,start%,lp%,v$
350   text=0:sprite=2:blob=4:pattern=6
360   retr=256:retn=-256:sous1=254:sous2=252:sous3=250
370   rem normal: hit = selects/deselects, do = returns & leaves selected
380   rem retr = return even on hit, reset item to available after,
390   rem retn = return even on hit, hit selects/deselects, do selects
400 :
410   hit$=CHR$(1):do$=CHR$(2):cancel$=CHR$(3):sleep$=CHR$(7):wake$=CHR$(8)
420   help$=CHR$(4):move$=CHR$(5):size$=CHR$(6):cr$=CHR$(10)
430 :
440   make_standard_sprites
450   colourway%=SMSCFG(2)                  : rem use first syspals
460   if colourway%>3 or colourway%<0:colourway%=0
470   temp%=set_colours% (2)      : rem always try to set highest colours
480   make_my_palette colourway%  : rem set colours according to system palette
490 :
500 restore 500
510 :
520 : rem make loose item attributes
530 :
540   DIM std_iattr(3,3)
550   RD_IATT std_iattr
560     DATA 1,sp.litemhigh : rem current item border size & colour
570     DATA sp.litemunabg,sp.litemunafg,0,0 : rem unavailable item paper & ink
580     DATA sp.litemavabg,sp.litemavafg,0,0 : rem available     "    "       "
590     DATA sp.litemselbg,sp.litemselfg,0,0 : rem selected
600 :
610   targets%=0
620   rem IF NOT compiled:cmd$="-tj-tg-st-mk-as"
630   quit_always%=0
640   quit_no_errors%=0
650   autostart%=0
660   do_make_it%=0
670   force_assembly$=""
680   delete_first%=0
690   select_all%=0
700   autochangesize%=(SMSCFG(3)=="Yes")
710   IF cmd$<>''
720       IF '-qa' INSTR cmd$:quit_always%=1
730       IF '-q0' INSTR cmd$:quit_no_errors%=1
740       IF '-as' INSTR cmd$:autostart%=1
750       IF '-mk' INSTR cmd$:do_make_it%=1
760       IF '-de' INSTR cmd$:delete_first%=1
770       IF '-sa' INSTR cmd$:select_all%=1
780       IF '-tg' INSTR cmd$:targets%=targets%+1 : rem Generic
790       IF '-ti' INSTR cmd$:targets%=targets%+2 : rem Atari
800       IF '-to' INSTR cmd$:targets%=targets%+4 : rem gOld
810       IF '-tq' INSTR cmd$:targets%=targets%+8 : rem Q40
820       IF '-tx' INSTR cmd$:targets%=targets%+16 : rem qXl
830       IF '-tu' INSTR cmd$:targets%=targets%+32 : rem aUrora
840       IF '-tj' INSTR cmd$:targets%=targets%+64 : rem Java
850       IF '-tr' INSTR cmd$:targets%=targets%+128 : rem ptRgen
860       IF '-tc' INSTR cmd$:targets%=targets%+256 : rem qpC
870       IF '-t8' INSTR cmd$:targets%=targets%+512 : REMark q68
880       IF '-ta' INSTR cmd$:targets%=255+256+512    : rem all targets
890       IF '-fa' INSTR cmd$:force_assembly$=" -f": rem force assembly of all files
900   ELSE
910     targets%=1
920   END IF
930   make_my_data targets%
940   xsize%=500                                      : rem window x size divisible by 4!
950   ysize%=200                                      : rem provisional y size%
960   rows%=-1                                        : rem make rows dependent on wdw size
970   rep$=SMSCFG(1)                        : rem dir with files
980   make_main_wdw
990   IF (select_all%):main_lfl%(all_it%)=129:set_statusses
1000   start%=1
1010   FOR lp%=target_its% TO target_its%+9
1020     IF targets% && start%: main_lfl%(lp%)=129
1030     start%=start%*2
1040   END FOR lp%
1050   IF do_make_it%:main_lfl%(make_it%)=129
1060   IF delete_first%:main_lfl%(del_it%)=129
1070 :
1080   warn_make
1090   v$=smscfg(0)
1100   about_make "SMSQEMake",v$
1110 :
1120 END DEFine init
1130 :
1140 define procedure main
1150 local lp%,item%,event%,swnum%,xrel%,yrel%,item%,lp2%,tot%,errors%
1160   if compiled
1170      dr_ppos main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
1180   else
1190      dr_puld main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
1200   end if
1210   pos_ptr main_defn,40*65536+20,1
1220   if autostart%
1230      errors%=do_the_work%
1240      if quit_always%:stop
1250      if quit_no_errors% and not errors%:stop
1260      if errors%
1270           errors%=warning%("There were errors"&chr$(10)&"check the highlit items",0,"errors!")
1280      endif
1290   endif
1300   repeat lp%
1310     rd_ptr main_defn,item%,swnum%,event%,xrel%,yrel%,main_lfl%,main_mfl%,main_cty%
1320     if swnum%= -1
1330       select on item%
1340             =esc%     : exit lp%                            : remark quit prog
1350             =move_it% : ch_win main_defn                    : remark move
1360             =size_it% : change_size xrel%,yrel%   : remark change size
1370             =sleep_it%: button main_defn,main_lfl%,main_mfl%,main_cty%,"SMSQ/E Make",4
1380             =all_it%  : set_statusses             : remark set all appsub item statusses
1390                           main_cty%(0,1)=1                  : remark and redraw
1400             =go_it%   : errors%=do_the_work%
1410                           if errors%
1420                                errors%=warning%("There were errors"&chr$(10)&"check the highlit items",0,"errors!")
1430                           endif
1440                           main_lfl%(del_it%)=1
1450             =dir_it%  : make_new_dir item%
1460             =target_its% to make_it%-1,alltargets_it%
1470                           if item%=alltargets_it%
1480                                machines%=-1
1490                                for lp2%= target_its% to make_it%-1
1500                                   main_lfl%(lp2%)=129
1510                                end for lp2%
1520                            else
1530                               start%=1:machines%=0
1540                               for lp2%=target_its% to make_it%-1
1550                                   if main_lfl%(lp2%):machines%=machines%+start%
1560                                   start%=start%*2
1570                               end for lp2%
1580                           endif
1590                           make_my_data machines%  : remark make data arrays
1600                           if autochangesize%
1610                               autochange_size xrel%,yrel%
1620                           else
1630                               app_addr=mk_main_app(app_addr,mdata$,0,0,1,0,0,0) : rem make apsub wdw
1640                               main_app_list=app_addr+180
1650                               ap_in main_defn,main_app_list : remark put it in
1660                               dr_wdrw main_defn:main_cty%(0,1)=1 : remark and redraw entire wdw
1670                           end if
1680             =info_it% : about "2013-2017"
1690       end select
1700     end if
1710   end repeat lp%
1720   dr_unst main_defn
1730   if compiled:close#1
1740   rechp espace_vide
1750 end define main
1760 :
1770 DEFine FuNction do_the_work%
1780 REMark this tries to compile all of the selected files
1790 REMark if the file was compiled OK, status (of the link file) set to available
1800 REMark if the file was not compiled ok, status left selected
1810 LOCal lp%,bound%,a$,my_error%,tot_err%
1820   bound%=DIMN(main_mfl%,1)              : REMark number of items to check
1830   tot_err%=0
1840   IF main_lfl%(del_it%)<>0
1850      EW "dev8_extras_del_all_bas";"auto stop"
1860   END IF
1870   FOR lp%=0 TO bound%
1880     a$=mdata$(lp%+1)                              : REMark potential file to compile
1890     IF a$(1)<>"*" AND main_mfl%(lp%,0)
1900        a$=rep$&a$                       : REMark add dir
1910        my_error%=compile_and_check% (a$): REMark try to compile
1920        IF NOT my_error%
1930              main_mfl%(lp%,0)=1
1940              DR_ADRW main_defn,0,main_mfl%,main_cty%
1950        END IF
1960        tot_err%=tot_err%+my_error%
1970     END IF
1980   END FOR lp%
1990   main_cty%(0,1)=1
2000   main_lfl%(go_it%)=1
2010   IF main_lfl%(make_it%)=128 AND NOT tot_err%:make_targets
2020   RETurn tot_err%
2030 END DEFine do_the_work%
2040 :
2050 DEFine FuNction compile_and_check% (a$)
2060 REMark this tries to compile a file, using the "make" prog
2070 REMark this returns 1 if errors, else 0
2080 LOCal chan%,is_ok$,ch_len
2090   ch_len=EXEPF_W ("make";a$&" -w -l"&force_assembly$)                   : REMark exec make & wait
2100   IF ch_len<>0
2110      EXEC_W "make";a$&" -w -l"&force_assembly$                 : REMark exec make & wait
2120   END IF
2130   is_ok$=a$(1 TO LEN(a$)-4)             : REMark file name w/o extension
2140   chan%=FOP_IN(is_ok$&'log')            : REMark open log file
2150   IF chan%<0:RETurn 1                             : REMark can't even open it!
2160   ch_len=FLEN(#chan%)                             : REMark file length
2170   GET#chan%\ch_len-10                             : REMark this is where error report is
2180   INPUT#chan%,is_ok$                              : REMark get it
2190   CLOSE#chan%
2200   IF NOT is_ok$=="No errors"
2210     RETurn 1                                      : REMark anything other than "no errors" signals errors
2220   ELSE
2230     RETurn 0
2240   END IF
2250 END DEFine compile_and_check%
2260 :
2270 DEFine PROCedure make_new_dir (poste%)
2280 REMark get athe new dir where the files are located
2290 LOCal quel_rep$
2300   IF MENU_OK
2310     quel_rep$= DIR_SELECT$("The Files are where?",,10,10,main_coul%,app_coul%)
2320   ELSE
2330     quel_rep$=getstr$(poste%,0,main_defn,a_lire$)           : REMark use menu extns if possible
2340   END IF
2350   IF LEN (quel_rep$) >= 5
2360      rep$=quel_rep$(1 TO 5)
2370   END IF
2380   CH_ITEM main_defn,-1,poste%,-1,"",rep$
2390   main_lfl%(poste%)=main_lfl%(poste%)+1
2400 END DEFine make_new_dir
2410 :
2420 DEFine PROCedure make_my_data (what_machine%)
2430 REMark what_machine% = 1 -> generic
2440 REMark what_machine% = 2 -> atari
2450 REMark what_machine% = 4 -> Gold Card
2460 REMark what_machine% = 8 -> Qx0
2470 REMark what_machine% = 16 -> QXL
2480 REMark what_machine% = 32 -> aurora
2490 REMark what_machine% = 64 -> java
2500 REMark what_machine% = 128 -> ptrgen
2510 REMark what_machine% = 256 -> qpc
2520 REMark what_machine% = 512 -> q68
2530 REMark these may be combined
2540   DIM mdata$(250,50)
2550   REMark first make generic data
2560   data_count%=1                         : REMark general data count (global var)
2570   IF what_machine%&&1
2580     generic_data                        : REMark set up generic data
2590     read_my_datas                       : REMark and read it
2600   END IF
2610   IF what_machine%&&2
2620      atari_data                         : REMark set up machine specific data....
2630      read_my_datas                      : REMark and read it
2640   END IF
2650   IF what_machine%&&4
2660      gc_data                                      : REMark set up machine specific data....
2670      read_my_datas                      : REMark and read it
2680   END IF
2690   IF what_machine%&&8
2700      q40_data                                     : REMark set up machine specific data....
2710      read_my_datas                      : REMark and read it
2720   END IF
2730   IF what_machine%&&16
2740      qxl_data                                     : REMark set up machine specific data....
2750      read_my_datas                      : REMark and read it
2760   END IF
2770   IF what_machine%&&32
2780      aurora_data                        : REMark set up machine specific data....
2790      read_my_datas                      : REMark and read it
2800   END IF
2810   IF what_machine%&&64
2820      java_data                                    : REMark set up machine specific data....
2830      read_my_datas                      : REMark and read it
2840   END IF
2850   IF what_machine%&&128
2860      ptrgen_data                        : REMark set up machine specific data....
2870      read_my_datas                      : REMark and read it
2880   END IF
2890   IF what_machine%&&256
2900      qpc_data                                     : REMark set up machine specific data....
2910      read_my_datas                      : REMark and read it
2920   END IF
2930   IF what_machine%&&512
2940      q68_data                                     : REMark set up machine specific data....
2950      read_my_datas                      : REMark and read it
2960   END IF
2970 END DEFine make_my_data
2980 :
2990 DEFine PROCedure read_my_datas
3000 REMark reads datas into the global var mdata$
3010 REMark uses data_count% from make_my_data
3020 LOCal lp%
3030   REPeat lp%
3040     READ mdata$(data_count%)
3050     IF mdata$(data_count%)="":EXIT lp%
3060     data_count%=data_count%+1
3070   END REPeat lp%
3080 END DEFine read_my_datas
3090 :
3100 DEFine PROCedure generic_data
3110 restore 3110
3120   DATA '**** -- SMSQ Generic -- ****'
3130   DATA 'smsq_smsq_loader_link'
3140   DATA 'smsq_smsq_fh_link'
3150   DATA 'smsq_smsq_link'
3160   DATA 'smsq_smsq_cache_link'
3170   DATA 'smsq_sbas_link'
3180   DATA 'smsq_smsq_lang_link'
3190   DATA 'smsq_sbas_lang_link'
3200   DATA 'smsq_sbas_procs_link'
3210   DATA 'smsq_smsq_wman_link'
3220   DATA 'smsq_smsq_hotkey_link'
3230   DATA 'smsq_smsq_vers_link'
3240   DATA 'smsq_home_link'
3250   DATA 'smsq_recent_link'
3260   DATA 'smsq_smsq_1mb_link',''
3270 END DEFine generic_data
3280 :
3290 DEFine PROCedure q40_data
3300 restore 3300
3310   DATA '**** -- Q40/Q60 -- ****'
3320   DATA 'smsq_q40_hwinit_link'
3330   DATA 'smsq_q40_nasty_link'
3340   DATA 'smsq_q40_cache_link'
3350   DATA 'smsq_q40_cachemode_link'
3360   DATA 'smsq_smsq_cache40c_link'
3370   DATA 'smsq_q40_driver_ser_link'
3380   DATA 'smsq_q40_driver_dv3_link'
3390   DATA 'smsq_q40_driver_ql_link'
3400   DATA 'smsq_q40_driver_16_link'
3410   DATA 'smsq_q40_kbd_lang_link'
3420   DATA 'smsq_smsq_q40_link'
3430   DATA 'smsq_q40_sysspr_link',''
3440 END DEFine q40_data
3450 :
3460 DEFine PROCedure atari_data
3470 restore 3470
3480   DATA '**** -- Atari -- ****'
3490   DATA 'smsq_atari_hwinit_link'
3500   DATA 'smsq_atari_nasty_link'
3510   DATA 'smsq_atari_driver_ql_link'
3520   DATA 'smsq_atari_driver_mo_link'
3530   DATA 'smsq_atari_driver_ser_link'
3540   DATA 'smsq_atari_driver_dv3_link'
3550   DATA 'smsq_atari_kbd_lang_link'
3560   DATA 'smsq_atari_sysspr_link'
3570   DATA 'sys_boot_st_host_link',''
3580 END DEFine atari_data
3590 :
3600 DEFine PROCedure gc_data
3610 restore 3610
3620   DATA '**** -- (Super)GoldCard -- ****'
3630   DATA 'smsq_gold_host_link'
3640   DATA 'smsq_gold_hwinit_link'
3650   DATA 'smsq_gold_nasty_link'
3660   DATA 'smsq_gold_nasty_s_link'
3670   DATA 'smsq_gold_driver_ql_link'
3680   DATA 'smsq_gold_driver_8_link'
3690   DATA 'smsq_gold_driver_most_link'
3700   DATA 'smsq_gold_driver_nd_link'
3710   DATA 'smsq_gold_driver_nds_link'
3720   DATA 'smsq_gold_driver_dv3_link'
3730   DATA 'smsq_gold_kbd_lang_link'
3740   DATA 'smsq_gold_kbd_abc_lng_link'
3750   DATA 'smsq_gold_kbd_abc_link'
3760   DATA 'smsq_gold_roms_link'
3770   DATA 'smsq_gold_qimi_link'
3780   DATA 'smsq_gold_sysspr_link',''
3790 END DEFine gc_data
3800 :
3810 DEFine PROCedure aurora_data
3820 restore 3820
3830   DATA '**** -- Aurora -- ****'
3840   DATA 'smsq_gold_host_link'
3850   DATA 'smsq_gold_hwinit_link'
3860   DATA 'smsq_gold_nasty_link'
3870   DATA 'smsq_gold_nasty_s_link'
3880   DATA 'smsq_aurora_driver_8_link'
3890   DATA 'smsq_gold_driver_ql_link'
3900   DATA 'smsq_gold_driver_most_link'
3910   DATA 'smsq_gold_driver_nd_link'
3920   DATA 'smsq_gold_driver_nds_link'
3930   DATA 'smsq_gold_driver_dv3_link'
3940   DATA 'smsq_gold_kbd_lang_link'
3950   DATA 'smsq_gold_kbd_abc_lng_link'
3960   DATA 'smsq_gold_kbd_abc_link'
3970   DATA 'smsq_gold_roms_link'
3980   DATA 'smsq_gold_qimi_link'
3990   DATA 'smsq_aurora_sysspr_link'
4000   DATA 'smsq_gold_sysspr_link',''
4010 END DEFine aurora_data
4020 :
4030 DEFine PROCedure qxl_data
4040 restore 4040
4050   DATA '**** -- QXL -- ****'
4060   DATA 'smsq_qxl_host_link'
4070   DATA 'smsq_qxl_hwinit_link'
4080   DATA 'smsq_qxl_nasty_e_link'
4090   DATA 'smsq_qxl_driver_ql_link'
4100   DATA 'smsq_qxl_driver_16_link'
4110   DATA 'smsq_qxl_driver_most_link'
4120   DATA 'smsq_qxl_driver_nd_link'
4130   DATA 'smsq_qxl_procs_link'
4140   DATA 'smsq_qxl_driver_dv3e_link'
4150   DATA 'smsq_qxl_kbd_lang_link'
4160   DATA 'smsq_qxl_ecache_link'
4170   DATA 'smsq_qxl_sysspr_link',''
4180 END DEFine qxl_data
4190 :
4200 DEFine PROCedure java_data
4210 restore 4210
4220   DATA '**** -- Java -- ****'
4230   DATA 'smsq_java_host_link'
4240   DATA 'smsq_java_smsq_link'
4250   DATA 'smsq_java_smsq_1mb_link'
4260   DATA 'smsq_java_hwinit_link'
4270   DATA 'smsq_java_driver_ql_link'
4280   DATA 'smsq_java_driver_8_link'
4290   DATA 'smsq_java_driver_16_link'
4300   DATA 'smsq_java_driver_most_link'
4310   DATA 'smsq_java_driver_dv3e_link'
4320   DATA 'smsq_java_ip_link'
4330   DATA 'smsq_gold_kbd_lang_link'
4340   DATA 'smsq_java_sysspr_link',''
4350 END DEFine java_data
4360 :
4370 DEFine PROCedure qpc_data
4380 restore 4380
4390   DATA "**** -- QPC -- ****"
4400   DATA 'smsq_qpc_host_link'
4410   DATA 'smsq_qpc_hwinit_link'
4420   DATA 'smsq_qpc_nasty_e_link'
4430   DATA 'smsq_qpc_driver_ql_link'
4440   DATA 'smsq_qpc_driver_16_link'
4450   DATA 'smsq_qpc_driver_8_link'
4460   DATA 'smsq_qpc_driver_ql_link'
4470   DATA 'smsq_qpc_driver_most_link'
4480   DATA 'smsq_qpc_procs_link'
4490   DATA 'smsq_qpc_driver_dv3e_link'
4500   DATA 'smsq_qpc_kbd_lang_link'
4510   DATA 'smsq_qpc_dos_link'
4520   DATA 'smsq_qpc_ip_link'
4530   DATA 'smsq_qpc_cdaudio_link'
4540   DATA 'smsq_smsq_qpc_link'
4550   DATA 'smsq_qpc_sysspr_link',''
4560 END DEFine qpc_data
4570 :
4580 DEFine PROCedure ptrgen_data
4590 restore 4590
4600   DATA "**** -- PtrGen -- ****"
4610   DATA "ee_wman_link","ee_ptr_link","ee_hot_german_link","ee_hot_french_link"
4620   DATA "ee_hot_english_link",""
4630 END DEFine ptrgen_data
4640 :
4650 DEFine PROCedure q68_data
4660 restore 4660
4670   DATA '**** -- Q68 -- ****'
4680   DATA 'smsq_q68_sbas_procs_link'
4690   DATA 'smsq_q68_hwinit_link'
4700   DATA 'smsq_q68_nasty_link'
4710   DATA 'smsq_q68_driver_dv3_link'
4720   DATA 'smsq_q68_driver_most_link'
4730   DATA 'smsq_q68_driver_ql_link'
4740   DATA 'smsq_q68_driver_16_link'
4750   DATA 'smsq_q68_driver_8_link'
4760   DATA 'smsq_q68_kbd_lang_link'
4770   DATA 'smsq_smsq_q68_link'
4780   DATA 'smsq_q40_sysspr_link',''
4790 END DEFine q68_data
4800 :
4810 DEFine PROCedure make_targets
4820 REMark targets are only made if there was no error during compilation
4830 REMark to achieve this, a primitive approach is used:
4840 REMark a check is made whether an appsub menu item status is still selected
4850 REMark if it is, then the
4860   LOCal lp%,current_target%,tot_targets%
4870   tot_targets%=0                        : REMark no targets to make yet
4880   current_target%=0                               : REMark and no target yet
4890   FOR lp%=0 TO data_count%-2
4900     IF main_mfl%(lp%,0)=16
4910       REMark we're covering a new target
4920       tot_targets%=tot_targets%+current_target% : REMark show old target
4930       current_target%=find_target%(lp%+1) : REMark get new target we're covering
4940     ELSE
4950       IF main_mfl%(lp%,0)<>0:current_target%=0
4960     END IF
4970   END FOR lp%
4980   tot_targets%=tot_targets%+current_target%
4990   REMark at the end, here, tot_targets holds a bitmap
5000   REMark of targets for which compilation was ok
5010   IF (machines%&&1) AND NOT (tot_targets% && 1):RETurn : REMark generic was asked for but not compiled correctly!
5020   IF tot_targets%&&2:atari_target
5030   IF tot_targets%&&4:gc_target
5040   IF tot_targets%&&8:qx0_target
5050   IF tot_targets%&&16:qxl_target
5060   IF tot_targets%&&32:aurora_target
5070   IF tot_targets%&&64:java_target
5080   REMark IF tot_targets%&&128:ptr_gen_target  : rem no need for this
5090   IF tot_targets%&&256:qpc_target
5100   IF tot_targets%&&512:q68_target
5110 END DEFine make_targets
5120 :
5130 DEFine PROCedure atari_target
5140   cmdl$='m'
5150   p$=rep$&'sys_boot_st_flp'
5160   f$=rep$&'sys_boot_file'
5170   ah$=rep$&'sys_boot_st_host'
5180   ld$=rep$&'smsq_smsq_loader'
5190   hi$=rep$&'smsq_atari_hwinit'
5200   os1f$=rep$&'smsq_smsq_fh_os'
5210   os1$=rep$&'smsq_smsq_os'
5220   ca$=rep$&'smsq_smsq_cache'
5230   os2$=rep$&'smsq_sbas_control'
5240   ns1$=rep$&'smsq_atari_nasty'
5250   ln1$=rep$&'smsq_smsq_lang'
5260   ln2$=rep$&'smsq_atari_kbd_lang'
5270   ln3$=rep$&'smsq_sbas_lang'
5280   ex1$=rep$&'smsq_sbas_procs_x'
5290   ex2$=rep$&'smsq_atari_driver_dv3'
5300   ex3$=rep$&'smsq_atari_driver_ser'
5310   ex4$=rep$&'smsq_atari_driver_mono'
5320   ex5$=rep$&'smsq_atari_driver_ql'
5330   ex6$=rep$&'smsq_smsq_wman'
5340   ex7$=rep$&'smsq_smsq_hotkey'
5350   ex8$=rep$&'smsq_atari_sysspr'
5360   ex9$=rep$&'smsq_home_home'
5370   ex10$=rep$&'smsq_recent_recent'
5380   nl$=rep$&'sys_boot_null'
5390   IF 'm' INSTR cmdl$ = 0: ex4$ = nl$
5400   EW f$, ah$,ld$,hi$,os1f$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$, ex10$,rep$&'smsq_atari_SMSQ.PRG'
5410 END DEFine atari_target
5420 :
5430 DEFine PROCedure gc_target
5440 REMark there are  2 targets for the Goldcard!
5450   f$=rep$&'sys_boot_file'
5460   v$=rep$&'smsq_smsq_vers'
5470   h$=rep$&'smsq_gold_host'
5480   ld$=rep$&'smsq_smsq_loader'
5490   hi$=rep$&'smsq_gold_hwinit'
5500   os1$=rep$&'smsq_smsq_os'
5510   ca$=rep$&'smsq_smsq_cache'
5520   os2$=rep$&'smsq_sbas_control'
5530   ns1$=rep$&'smsq_gold_nasty'
5540   ns2$=rep$&'smsq_gold_nasty_s'
5550   ln1$=rep$&'smsq_smsq_lang'
5560   ln2$=rep$&'smsq_gold_kbd_lang'
5570   ln2a$=rep$&'smsq_gold_kbd_abc_lang'
5580   ln3$=rep$&'smsq_sbas_lang'
5590   ex1$=rep$&'smsq_sbas_procs_x'   : REMark this must be after "roms"
5600   ex2a$=rep$&'smsq_gold_kbd_abc'
5610   ex2$=rep$&'smsq_gold_driver_most'
5620   ex3a$=rep$&'smsq_gold_driver_ql'
5630   ex38$=rep$&'smsq_gold_driver_8'
5640   ex3q$=rep$&'smsq_gold_qimi'
5650   ex3w$=rep$&'smsq_smsq_wman'
5660   ex4$=rep$&'smsq_gold_driver_dv3'
5670   ex5$=rep$&'smsq_gold_driver_nd'
5680   ex6$=rep$&'smsq_gold_driver_nds'
5690   ex7$=rep$&'smsq_smsq_hotkey'
5700   ex8$=rep$&'smsq_gold_sysspr'
5710   ex9$=rep$&'smsq_home_home'
5720   ex10$=rep$&'smsq_gold_roms'
5730   ex11$=rep$&'smsq_recent_recent'
5740   nl$=rep$&'sys_boot_null'
5750   EW f$, v$,h$,ld$,hi$,os1$,ca$,os2$,ns1$,ns2$,ln1$,ln2$,ln2a$,ln3$,ex2a$,ex2$,ex3a$,ex3q$,ex3w$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$,ex10$, ex1$,ex11$,rep$&'SMSQ_GOLD_gold'
5760   EW f$, v$,h$,ld$,hi$,os1$,ca$,os2$,ns1$,ns2$,ln1$,ln2$,ln2a$,ln3$,ex2a$,ex2$,ex38$,ex3q$,ex3w$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$,ex10$, ex1$,ex11$,rep$&'SMSQ_GOLD_gold8'
5770 END DEFine gc_target
5780 :
5790 DEFine PROCedure aurora_target
5800   f$=rep$&'sys_boot_file'
5810   v$=rep$&'smsq_smsq_vers'
5820   h$=rep$&'smsq_gold_host'
5830   ld$=rep$&'smsq_smsq_loader'
5840   hi$=rep$&'smsq_gold_hwinit'
5850   os1$=rep$&'smsq_smsq_os'
5860   ca$=rep$&'smsq_smsq_cache'
5870   os2$=rep$&'smsq_sbas_control'
5880   ns1$=rep$&'smsq_gold_nasty'
5890   ns2$=rep$&'smsq_gold_nasty_s'
5900   ln1$=rep$&'smsq_smsq_lang'
5910   ln2$=rep$&'smsq_gold_kbd_lang'
5920   ln2a$=rep$&'smsq_gold_kbd_abc_lang'
5930   ln3$=rep$&'smsq_sbas_lang'
5940   ex1$=rep$&'smsq_sbas_procs_x'   : REMark this must be after "roms"
5950   ex2a$=rep$&'smsq_gold_kbd_abc'
5960   ex2$=rep$&'smsq_gold_driver_most'
5970   ex3a$=rep$&'smsq_gold_driver_ql'
5980   ex3b$=rep$&'smsq_aurora_driver_8'
5990   ex3q$=rep$&'smsq_gold_qimi'
6000   ex3w$=rep$&'smsq_smsq_wman'
6010   ex3sq$=rep$&'smsq_aurora_sysspr'
6020   ex3sh$=rep$&'smsq_gold_sysspr'
6030   ex4$=rep$&'smsq_gold_driver_dv3'
6040   ex5$=rep$&'smsq_gold_driver_nd'
6050   ex6$=rep$&'smsq_gold_driver_nds'
6060   ex8$=rep$&"smsq_home_home"
6070   ex9$=rep$&'smsq_smsq_hotkey'
6080   ex10$=rep$&'smsq_gold_roms'
6090   ex11$=rep$&'smsq_recent_recent'
6100   nl$=rep$&'sys_boot_null'
6110   EW f$, v$,h$,ld$,hi$,os1$,ca$,os2$,ns1$,ns2$,ln1$,ln2$,ln2a$,ln3$,ex2a$,ex2$,ex3a$,ex3b$,ex3q$,ex3w$,ex3sh$,ex4$,ex5$,ex6$,ex9$,ex10$,ex8$,ex1$,ex11$, rep$&'SMSQ_Aurora_SMSQE'
6120 END DEFine aurora_target
6130 :
6140 DEFine PROCedure qx0_target
6150   nl$=rep$&'sys_boot_null'
6160   f$=rep$&'sys_boot_file'
6170   qr$=rep$&'sys_boot_q40_rom'
6180   ld$=rep$&'smsq_smsq_loader'
6190   hi$=rep$&'smsq_q40_hwinit'
6200   os1$=rep$&'smsq_smsq_q40_os' : REMark -*** change for fast memory   **
6210   ca$=rep$&'smsq_smsq_cache40c'
6220   caq$=rep$&'smsq_q40_cache'
6230   caq4$=rep$&'smsq_q40_cachemode'
6240   os2$=rep$&'smsq_sbas_control'
6250   ns2$=rep$&'smsq_q40_nasty'
6260   ln1$=rep$&'smsq_smsq_lang'
6270   ln2$=rep$&'smsq_q40_kbd_lang'
6280   ln3$=rep$&'smsq_sbas_lang'
6290   ex1$=rep$&'smsq_sbas_procs_x'
6300   ex2$=rep$&'smsq_q40_driver_dv3'
6310   ex3$=rep$&'smsq_q40_driver_ser'
6320   ex4a$=rep$&'smsq_q40_driver_ql'
6330   ex4b$=rep$&'smsq_q40_driver_16'
6340   ex4w$=rep$&'smsq_smsq_wman'
6350   ex5$=rep$&'smsq_q40_sysspr'
6360   ex9$=rep$&'smsq_smsq_hotkey'
6370   ex10$=rep$&'smsq_home_home'
6380   ex11$=rep$&'smsq_recent_recent'
6390   EW f$, qr$,ld$,hi$,os1$,ca$,caq$,os2$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex4a$,ex4b$,ex4w$,ex5$,ex9$,ex10$,ex11$,ns2$,caq4$, rep$&'smsq_q40_rom'
6400 END DEFine qx0_target
6410 :
6420 DEFine PROCedure qxl_target
6430   IF FOP_IN (rep$&'smsq_qxl_qxlh.exe') <> -7: PRINT 'QXLH.EXE exists'; cmd$: QUIT
6440   p$   = rep$&'sys_boot_file'
6450   bl$  = rep$&'smsq_qxl_qxl2_exe'
6460   hst$ = rep$&'smsq_qxl_host'
6470   hi$  = rep$&'smsq_qxl_hwinit'
6480   ld$  = rep$&'smsq_smsq_loader'
6490   os1$ = rep$&'smsq_smsq_os'
6500   ca$  = rep$&'smsq_smsq_cache'
6510   os2$ = rep$&'smsq_sbas_control'
6520   ns1$ = rep$&'smsq_qxl_nasty_e'
6530   ln1$ = rep$&'smsq_smsq_lang'
6540   ln2$ = rep$&'smsq_qxl_kbd_lang'
6550   ln3$ = rep$&'smsq_sbas_lang'
6560   ex1$ = rep$&'smsq_qxl_procs_x'
6570   ex2$ = rep$&'smsq_qxl_driver_most'  : REMark Keyboard before CON
6580   ex3$ = rep$&'smsq_qxl_driver_ql'
6590   ex3b$ = rep$&'smsq_qxl_driver_16'
6600   ex3w$ = rep$&'smsq_smsq_wman'
6610   ex4$ = rep$&'smsq_qxl_driver_nd'
6620   ex5$ = rep$&'smsq_qxl_driver_dv3e'
6630   ex6$ = rep$&'smsq_smsq_hotkey'
6640   ex7$ = rep$&'smsq_qxl_sysspr'
6650   ex8$ = rep$&'smsq_home_home'
6660   ex10$= rep$&'smsq_recent_recent'
6670   last$ = rep$&'smsq_qxl_ecache'
6680   dml$ = rep$&'smsq_qxl_dummy'
6690   qm$  = rep$&'qmon_qxl_bin'
6700   r$='ram1_smsqe.exe' : f$=rep$&'smsq_qxl_smsqe.exe'
6710   cct$=rep$&"extras_exe_cct"
6720   DELETE f$
6730   EW p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3w$,ex4$,ex5$,ex6$,ex7$,ex8$,ex11$,last$, r$
6740   EW cct$, bl$,r$, f$
6750   DELETE r$
6760   OPEN #4,f$
6770   lenf=FLEN(#4)
6780   lens% = INT ((lenf+511)/512)
6790   lenb% = lenf - lens% * 512
6800   IF lenb%: lenb% = lenb% + 512
6810   BPUT #4\2, lenb% MOD 256, lenb% DIV 256, lens% MOD 256, lens% DIV 256
6820   CLOSE #4
6830 END DEFine qxl_target
6840 :
6850 DEFine PROCedure java_target
6860   f$=rep$&'sys_boot_file'
6870   v$=rep$&'smsq_smsq_vers'
6880   h$=rep$&'smsq_java_host'
6890   ld$=rep$&'smsq_smsq_loader'
6900   hi$=rep$&'smsq_java_hwinit'
6910   os1$=rep$&'smsq_java_smsq_os'
6920   os3$=rep$&'smsq_java_smsq_1mb_os'     : REMark must be after os
6930   ca$=rep$&'smsq_smsq_cache'
6940   os2$=rep$&'smsq_sbas_control'
6950   ln1$=rep$&'smsq_smsq_lang'
6960   ln2$=rep$&'smsq_gold_kbd_lang'
6970   ln3$=rep$&'smsq_sbas_lang'
6980   sb$=rep$&'smsq_sbas_procs_x'
6990   dr1$=rep$&'smsq_java_driver_most'
7000   dr2$=rep$&'smsq_java_driver_ql'
7010   dr3$=rep$&'smsq_java_driver_8'
7020   dr4$=rep$&'smsq_java_driver_16'
7030   dr5$=rep$&'smsq_smsq_wman'
7040   dr6$=rep$&'smsq_java_driver_dv3e'
7050 rem  dr7$=rep$&'smsq_java_driver_qsd_qsd'
7060   hk$=rep$&'smsq_smsq_hotkey'
7070   sp$=rep$&'smsq_java_sysspr'
7080   hm$=rep$&'smsq_home_home'
7090   ip$=rep$&'smsq_java_ip_x'
7100   re$=rep$&'smsq_recent_recent'
7110   EW f$,h$,ld$,hi$,os1$,os3$,ca$,os2$,ln1$,ln2$,ln3$,sb$,dr1$,dr2$,dr3$,dr4$,dr5$,dr6$,hk$,sp$,hm$,ip$,re$, rep$&'SMSQ_java_java'
7120 END DEFine java_target
7130 :
7140 DEFine PROCedure qpc_target
7150   p$   = rep$&'sys_boot_file'
7160   hst$ = rep$&'smsq_qpc_host'
7170   hi$  = rep$&'smsq_qpc_hwinit'
7180   ld$  = rep$&'smsq_smsq_loader'
7190   os1$ = rep$&'smsq_smsq_qpc_os'
7200   ca$  = rep$&'smsq_smsq_cache'
7210   os2$ = rep$&'smsq_sbas_control'
7220   ns1$ = rep$&'smsq_qpc_nasty_e'
7230   ln1$ = rep$&'smsq_smsq_lang'
7240   ln2$ = rep$&'smsq_qpc_kbd_lang'
7250   ln3$ = rep$&'smsq_sbas_lang'
7260   ex1$ = rep$&'smsq_sbas_procs_x'
7270   ex2$ = rep$&'smsq_qpc_driver_most'  : REMark Keyboard before CON
7280   ex3$ = rep$&'smsq_qpc_driver_ql'
7290   ex3b$= rep$&'smsq_qpc_driver_16'
7300   ex3c$= rep$&'smsq_qpc_driver_8'
7310   ex3w$= rep$&'smsq_smsq_wman'
7320   ex3s$= rep$&'smsq_qpc_sysspr'
7330   ex4$ = rep$&'smsq_qpc_driver_dv3e'
7340   ex5$ = rep$&'smsq_smsq_hotkey'
7350   ex6$ = rep$&'smsq_qpc_procs_x'
7360   ex7$ = rep$&'smsq_qpc_cdaudio_x'
7370   ex8$ = rep$&'smsq_qpc_dos_x'
7380   ex9$ = rep$&'smsq_qpc_ip_x'
7390   exa$ = rep$&'smsq_home_home'
7400   exb$ = rep$&'smsq_recent_recent'
7410   qm$ =  rep$&"qmon_qpc_smsq"
7420   r$='ram1_smsqe.bin'
7430   EW p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3c$,ex3w$,ex3s$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$,exa$,exb$, r$
7440   COPY_O r$,rep$&'smsq_qpc_smsqe.bin'
7450   DELETE r$
7460   REMark rd$='ram1_smsqe.deb'
7470   REMark EW p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3c$,ex3w$,ex3s$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$,exa$,qm$, rd$
7480   REMark COPY_O r$,qpc$&'release_smsqe.bin'
7490   REMark COPY_O rd$,qpc$&'exe_smsqe.bin'
7500 END DEFine qpc_target
7510 :
7520 DEFine PROCedure q68_target
7530   local c%
7540   tgt$= rep$&'smsq_q68_RAM_SYS'
7550   leng=350000
7560   nl$=rep$&'sys_boot_null'
7570   f$=rep$&'sys_boot_file'
7580   qr$=rep$&'sys_boot_q68_rom_bin'
7590   ld$=rep$&'smsq_smsq_loader'
7600   hi$=rep$&'smsq_q68_hwinit'
7610   os1$=rep$&'smsq_smsq_q68_os' : REMark change for fast memory
7620   ca$  = rep$&'smsq_smsq_cache'
7630   ns2$=rep$&'smsq_q68_nasty'
7640   os2$=rep$&'smsq_sbas_control'
7650   ln1$=rep$&'smsq_smsq_lang'
7660   ln2$=rep$&'smsq_q68_kbd_lang'
7670   ln3$=rep$&'smsq_sbas_lang'
7680   ex1$=rep$&'smsq_q68_sbas_procs_x'
7690   ex2$=rep$&'smsq_q68_driver_dv3'
7700   ex3$=rep$&'smsq_q68_driver_most'
7710   ex4a$=rep$&'smsq_q68_driver_ql'
7720   ex4b$=rep$&'smsq_q68_driver_16'
7730   ex4c$=rep$&'smsq_q68_driver_8'
7740   ex4w$=rep$&'smsq_smsq_wman'
7750   ex5$=rep$&'smsq_q40_sysspr'
7760   ex9$=rep$&'smsq_smsq_hotkey'
7770   ex10$=rep$&'smsq_home_home'
7780   ex11$=rep$&'smsq_recent_recent'
7790   EW f$, qr$,ld$,hi$,os1$,ca$,os2$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex4a$,ex4b$,ex4c$,ex4w$,ex5$,ex9$,ex10$,ex11$,ns2$,tgt$ : rem no net
7800   COPY_O tgt$,rep$&"smsq_q68_SMSQ_4_WIN"
7810   c%=fop_in (tgt$)
7820   fleng=flen(#c%)
7830   close#c%
7840   a=ALCHP (leng)
7850   LBYTES tgt$,a
7860   poke_l a+16,fleng                               : rem set length here for loader
7870   SBYTES_O tgt$,a,leng
7880   RECHP a
7890 END DEFine q68_target
7900 :
7910 DEFine PROCedure findit
7920 LOCal lp%,a$
7930 restore 7930
7940   DATA p$, hst$,ld$,hi$,os1$,ca$,os2$,ns1$,ln1$,ln2$,ln3$,ex1$,ex2$,ex3$,ex3b$,ex3c$,ex3w$,ex3s$,ex4$,ex5$,ex6$,ex7$,ex8$,ex9$,exa$, r$,""
7950   REPeat lp%
7960     READ a$:IF a$="":EXIT lp%
7970     t%=FOP_IN(a$ )
7980     IF (t%<0)
7990        PRINT "not found "& a$
8000     END IF
8010  END REPeat lp%
8020 END DEFine findit
8030 :
8040 DEFine FuNction find_target% (current%)
8050   IF "SMSQ Generic" INSTR mdata$(current%):RETurn 1
8060   IF "Atari" INSTR mdata$(current%):RETurn 2
8070   IF "GoldCard" INSTR mdata$(current%):RETurn 4
8080   IF "Q40" INSTR mdata$(current%):RETurn 8
8090   IF "QXL" INSTR mdata$(current%):RETurn 16
8100   IF "Aurora" INSTR mdata$(current%):RETurn 32
8110   IF "Java" INSTR mdata$(current%):RETurn 64
8120   IF "Ptr_Gen" INSTR mdata$(current%):RETurn 128
8130   IF "QPC" INSTR mdata$(current%):RETurn 256
8140   IF "Q68" INSTR mdata$(current%):RETurn 512
8150   RETurn 0                                     : REMark huh???
8160 END DEFine find_target%
8170 :
8180 define procedure change_size (x%,y%)
8190 rem this uses the GLOBAL vars : maxx%,maxy%, xsize%,ysize%,main_xxx...
8200 local xrel%,yrel%,temp,a$,ttemp%(main_lit%),abs%,yabs%,t%,bt$,mtemp%(0,0)
8210   main_lfl%(size_it%)=1                 : remark reset to available
8220   dim mtemp%(dimn(main_mfl%,1),dimn(main_mfl%,2))
8230   arrcopy main_lfl%,ttemp%              : remark keep statusses
8240   arrcopy main_mfl%,mtemp%
8250   ch_win main_defn,xrel%,yrel%                    : remark get ptr displacement
8260   xsize%=xsize%-xrel%+3
8270   if xsize%<420:xsize%=420
8280   ysize%=ysize%-yrel%                             : remark new sizes
8290   t%=2^4+2^5                                      : rem return immediately from read ptr call
8300   rptr xabs%,yabs%,t%,t%,xrel%,yrel%,bt$: remark get absolute coords
8310   if xsize%>maxx%-16:xsize%=maxy%-16
8320   if ysize%>maxy%-16:ysize%=maxy%-16    : remark max values
8330   dr_unst main_defn                               : remark no more wdw defn...
8340   dr_remv main_defn                               : remark .... now!
8350   app_addr=0                                      : remark nor any appsub wdw
8360   rows%=-1
8370   make_main_wdw                         : remark make window anew
8380   arrcopy ttemp%,main_lfl%
8390   arrcopy mtemp%,main_mfl%
8400   t%=lxs%*3
8410   xabs%=xabs%-t%:if xabs%<0:xabs%=0     : remark position ptr nicely
8420   yabs%=yabs%-8:if yabs%<0:yabs%=0
8430   sptr xabs%,yabs%,0                              : remark now
8440   if compiled
8450      dr_ppos main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8460   else
8470      dr_puld main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8480   end if
8490   pos_ptr main_defn,x%*65536+y%,1      : remark position pointer in wdw
8500 end define change_size
8510 :
8520 def proc autochange_size (x%,y%)
8530 rem change size when items added/removed
8540 rem this tries to change the wdw position as little as possible
8550 local lp%,xrel%,yrel%,ttemp%(main_lit%),abs%,yabs%,t%,bt$
8560   t%=2^4+2^5                                      : rem return immediately from read ptr call
8570   rptr xabs%,yabs%,t%,t%,xrel%,yrel%,bt$: remark get absolute coords
8580   arrcopy main_lfl%,ttemp%              : remark keep statusses
8590   dr_unst main_defn                               : remark no more wdw defn...
8600   dr_remv main_defn                               : remark .... now!
8610   app_addr=0                                      : remark nor any appsub wdw
8620   rows%=data_count%-1
8630   make_main_wdw                         : remark make window anew
8640   for lp%=0 to dimn(main_lfl%,1)
8650      main_lfl%(lp%)=ttemp%(lp%)+1
8660   end for lp%
8670   set_statusses
8680   main_cty%(0,1)=1
8690   xabs%=xabs%-x%:if xabs%<0:xabs%=x%    : remark position ptr nicely
8700   yabs%=yabs%-y%:if yabs%<0:yabs%=y%
8710   sptr xabs%,yabs%,0                              : remark now
8720   if compiled
8730      dr_ppos main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8740   else
8750      dr_puld main_defn,-1,-1,main_lfl%,main_mfl%,main_cty%
8760   end if
8770   pos_ptr main_defn,x%*65536+y%,1       : remark position pointer in wdw
8780 end define autochange_size
8790 :
8800 DEFine PROCedure set_statusses
8810 REMark set all statusses of menu appsub objects
8820 LOCal temp%,lp%,stat%
8830   temp%=DIMN(main_mfl%,1)               : REMark how many are there?
8840   stat%=main_lfl%(all_it%)              : REMark status of "all" item
8850   FOR lp%=0 TO temp%
8860     IF mdata$(lp%+1,1)='*'
8870       main_mfl%(lp%,0)=16               : REMark comments set to unavailable
8880     ELSE
8890       main_mfl%(lp%,0)=stat%            : REMark all other to status
8900     END IF
8910   END FOR lp%
8920 END DEFine set_statusses
8930 :
8940 define procedure make_main_wdw
8950 rem make the main window - a pretty standard window with 1 menu appsub wdw
8960 local main_lot,main_iwt,main_iot1,infy1%,lxs%,lys%,xesp%,nbr_post%,nbr_trgs%
8970 local title$,title_size%,title_x%,temp%,appwinoffset%,li_xorig%,li_xsize%
8980 :
8990   appwinoffset%=16                      : remark appsub win additional y offset
9000   lxs%=24:lys%=12                       : remark standard item x,y, sizes
9010   inf1y%=lys%+4                         : remark y orig of inner border
9020   xesp%=lxs%+2                                    : remark loose items x spacing
9030   nbr_post%=5                                     : remark nbr of item right & left in title bar
9040   li_xorig%=6
9050   li_xsize%=7*6 + 2
9060   nbr_trgs%=10                                     : rem number of targets
9070 :
9080   title$="dir: "&rep$&" "
9090   rem first make sure of the wdw sizes (we also come here from change_size!)
9100   temp%=(xsize%-li_xorig%) div nbr_trgs% : rem x size of 1 target loose item
9110   xsize%=temp%*nbr_trgs%+ li_xorig% +3
9120   xsize%=xsize%-(xsize% mod 4)                    : rem make into nbr divisible by 4
9130 :
9140   rem calculate the y size of the wdw so that it always looks nice, in that
9150   rem the rows in the appsub always fill the appsub entirely
9160   app_y_orig%=inf1y% + appwinoffset%    : rem y offset for appsub win within wdw
9170   calc_ysize 0                                    : rem set ysize% and rows% variables
9180 :
9190   rem first calc info obj size - this also influences one loose item, used
9200   rem in the title bar
9210   title_size%=len(title$)*6             : rem length in pixels
9220   title_x%=int((xsize%-title_size%)/2): rem x orig
9230 :
9240   rem first the loose items
9250 :
9260   esc%=0:move_it%=esc%+1:size_it%=move_it%+1
9270   sleep_it%=size_it%+1:all_it%=sleep_it%+1:go_it%=all_it%+1
9280   dir_it%=go_it%+1:target_its%=dir_it%+1:make_it%=target_its%+nbr_trgs%
9290   info_it%=make_it%+1:del_it%=info_it%+1:alltargets_it%=del_it%+1
9300 :
9310 restore 9310
9320 :
9330   main_lit%=20:dim main_lfl%(main_lit%)   : rem there are 21 items
9340   main_lot=rd_lot(std_iattr,main_lit%)
9350     data lxs%,lys%,4+xesp%*0,2,0,0,cancel$,text+retr,'ESC'
9360     data lxs%,lys%,4+xesp%*1,2,0,0,move$,sprite+retr,move_sprite
9370     data lxs%,lys%,4+xesp%*2,2,0,0,size$,sprite+retn,size_sprite
9380     data lxs%,lys%,xsize%-2-xesp%*1,2,0,0,sleep$,sprite+retr,sleep_sprite
9390     data lxs%,lys%,xsize%-2-xesp%*3,2,0,0,'A',sous1+retn,"All"
9400     data lxs%,lys%,xsize%-2-xesp%*4,2,0,0,'O',sous1+retn,"Ok"
9410     data 6*6,lys%-2,title_x%+30,3,0,0   ,'D',text+retn,rep$
9420     data li_xsize%,lys%,li_xorig%,inf1y%+2,0,0,        'G',sous1+retn,"Generic"
9430     data li_xsize%,lys%,li_xorig%+temp%,inf1y%+2,0,0,  'T',sous2+retn,"Atari"
9440     data li_xsize%,lys%,li_xorig%+temp%*2,inf1y%+2,0,0,'L',sous3+retn,"Goldcrd"
9450     data li_xsize%,lys%,li_xorig%+temp%*3,inf1y%+2,0,0,'Q',sous1+retn,"Q40/Q60"
9460     data li_xsize%,lys%,li_xorig%+temp%*4,inf1y%+2,0,0,'X',sous2+retn,"Qxl"
9470     data li_xsize%,lys%,li_xorig%+temp%*5,inf1y%+2,0,0,'U',sous2+retn,"Aurora"
9480     data li_xsize%,lys%,li_xorig%+temp%*6,inf1y%+2,0,0,'J',sous1+retn,"Java"
9490     data li_xsize%,lys%,li_xorig%+temp%*7,inf1y%+2,0,0,'P',sous1+retn,"PtrGen"
9500     data li_xsize%,lys%,li_xorig%+temp%*8,inf1y%+2,0,0,'C',sous3+retn,"QPC"
9510     data li_xsize%,lys%,li_yorig%+temp%*9,inf1y%+2,0,0,'8',sous3+retn,"Q68"
9520     data 4*6,lys%,xsize%-2-xesp%*2,2,0,0,'M',sous1+retn,"Make"
9530     data 4*6,lys%,xsize%-2-xesp%*5,2,0,0,'?',sous1+retn,"?"
9540     data lxs%,lys%,4+xesp%*3,2,0,0,"E",sous2+retn,"DEL"
9550     data lxs%,lys%,4+xesp%*4,2,0,0,"S",sous1+retn,"SaT"
9560 :
9570 rem now info wdw objects - here only one, the title
9580   rem make the title data: calculate size and x position of this object
9590   main_iot1=rd_iot(0)
9600     data title_size%,10,4,int((lys%-10)/2),sous1,sp.titlefg,0,0,title$
9610 :
9620 rem now the info wdws
9630   main_iwt=rd_iwt(2)                              : rem there are 3
9640   rem first the title bar
9650     data xsize%-8-(2*nbr_post%*xesp%),lys%+2,xesp%*nbr_post%+4,0       : rem x,y sizes & origs
9660     data 0,0,sp.infwinbd,sp.titlebg     : rem shadow, border size & col,paper col
9670     data 0                                        : rem object pointer (none)
9680 :
9690   rem now wdw containing title itself
9700     data title_size%+8,lys%,title_x%-4,2
9710     data 0,0,sp.infwindbd,sp.infwinbg
9720     data main_iot1                      : rem one object
9730 :
9740   rem inner border
9750     data xsize%-8,ysize%-inf1y%-2,4,inf1y%
9760     data 0,1,sp.infwinbd,sp.infwinbg
9770     data 0
9780 :
9790 rem now the appsub wdw - use the outptr functions for this
9800   main_app_list=0                       : rem appsub win list
9810   app_addr=0                                      : rem there is no appsub win yet
9820   menu_selkeys$=""                      : rem selkeys to exclude
9830   appw_sections%=1                      : rem display only one section
9840   app_addr=mk_main_app(app_addr,mdata$,0,0,1,0,0,0) : rem make apsub wdw
9850   main_app_list = app_addr+180                    : rem list built by outptr
9860   set_statusses                         : rem set statusses of menu items
9870 :
9880 rem the working defn
9890   main_defn=rd_wdef
9900     data 2,1,sp.winbd,sp.winbg                    : rem shad,border size & col,pap col
9910     data xsize%,ysize%,0,0              : rem x,y size & initial ptr pos
9920     data main_sprite,main_lot,main_iwt,main_app_list : rem sprite,loose items, info wins, appsubs
9930 end define make_main_wdw
9940 :
9950 def fn warning_pos% (mess$,channel%,title$,pos)
9960 rem warning wdw with pointer positioning
9970   pos_ptr main_defn,pos,-1
9980   return warning%(mess$,channel%,title$)
9990 end def warning_pos%
10000 :
10010 define function warning%(mess$,channel%,title$)
10020 rem shows a warning message (mess$) in a small window. hit esc or ok
10030 rem to return; returns 0 if esc, 1 if ok  hit
10040 local item%,lp%,chan%,y%,swnum%,infot%
10050   stop_info
10060   if channel%
10070     chan%=channel%
10080   else
10090     chan%=fopen("con")
10100   endif
10110   ch_item warn_defn,-3,0,-1,'','Attention'
10120   ch_item warn_defn,-1,0,-1,cancel$,'ESC'
10130   ch_item warn_defn,-1,1,-1,'O','OK'
10140   warn_lfl%(0)=1:warn_lfl%(1)=1
10150   poke_w warn_defn+44,sp.errmg                           : rem border colour of wdw
10160   poke_w warn_defn+46,sp.errbg                           : rem paper colour of wdw
10170   poke_w warn_wdw_addr+14,sp.errbg             : rem paper of title info wdw
10180   obj_addr=peek_l(warn_wdw_addr+16)            : rem ptr to object list
10190   poke_w obj_addr+10,sp.errfg                            : rem info object text  colour
10200   dr_puld warn_defn,-1,-1
10210   dr_iwdf #chan%,warn_defn,0
10220   wm_paper#chan%,sp.errbg
10230   wm_ink#chan%,sp.errfg
10240   cls#chan%
10250   if title$<>"":print#chan%,title$;" :"
10260   print #chan%,mess$
10270   pos_ptr warn_defn,160*65536+10,-1
10280   repeat lp%
10290     rd_ptr warn_defn,item%,swnum%,y%,y%,y%,warn_lfl%
10300     if swnum%=-1:exit lp%
10310   end repeat lp%
10320   if not channel%:close#chan%
10330   dr_unst warn_defn
10340   return item%
10350 end define warning%
10360 :
10370 def proc info_pos (mess$,channel%,pos)
10380 rem warning wdw with positioning
10390   pos_ptr main_defn,pos,-1
10400   info mess$,channel%
10410 end def info_pos
10420 :
10430 define procedure info(mess$,channel%)
10440 rem shows window containing mess$. channel% is a screen channel, if this is 0,
10450 rem a temp screen channel will be opened.
10460 local chan%,infot%,obj_addr
10470   if channel%
10480     chan%=channel%
10490   else
10500     chan%=fopen("con")
10510   endif
10520   ch_item warn_defn,-3,0,-1,"",'  Info.  '
10530   ch_item warn_defn,-1,0,-1,"",'Info'
10540   ch_item warn_defn,-1,1,-1,"",'Info'
10550   poke_w warn_defn+44,sp.infwinbg                 : rem paper colour of wdw
10560   poke_w warn_defn+46,sp.winbd                              : rem border around wdw
10570   poke_w warn_wdw_addr+14,sp.infwinbg             : rem paper of title info wdw
10580   obj_addr=peek_l(warn_wdw_addr+16)               : rem ptr to object list
10590   poke_w obj_addr+10,sp.infwinfg                  : rem info object text        colour
10600   dr_puld warn_defn,-1,-1
10610   pos_ptr warn_defn,90*65536+70,-1
10620   dr_iwdf #chan%,warn_defn,0
10630   wm_paper#chan%,sp.infwinbg
10640   wm_ink#chan%,sp.infwinfg
10650   cls#chan%
10660   print #chan%,mess$
10670   if not channel%:close#chan%
10680   info_is_pulled_down%=1
10690 end define info
10700 :
10710 def proc info_wait(mess$,channel%)
10720 rem shows info wdw, waits until user clicks, closed info wdw
10730   show_info mess$,channel%
10740   info_wait_to_close
10750 end def info_wait
10760 :
10770 def proc info_wait_to_close
10780 local item%,lp%,chan%,y%,swnum%,infot%
10790   repeat lp%
10800     rd_ptr warn_defn,item%,swnum%,y%,y%,y%,warn_lfl%
10810     if swnum%=-1:exit lp%
10820   end repeat lp%
10830   stop_info
10840 end def info_wait_to_close
10850 :
10860 def proc info_pos_wait (mess$,channel%,pos)
10870 rem positions & shows info wdw, waits until user clicks,closes info wdw
10880   info_pos mess$,channel%,pos
10890   info_wait_to_close
10900 end def info_pos_wait
10910 :
10920 def proc stop_info
10930   if info_is_pulled_down%
10940     dr_unst warn_defn
10950     info_is_pulled_down%=0
10960   endif
10970 end def stop_info
10980 :
10990 def proc show_info (mess$,channel%)
11000 rem either opens the info wdw and shows the message or shows the message in
11010 rem the existing info wdw
11020 local chan%
11030   if channel%
11040     chan%=channel%
11050   else
11060     chan%=fopen("con")
11070   endif
11080   if info_is_pulled_down%
11090     cls#chan%
11100     wm_paper#chan%,sp.infwinbg
11110     wm_ink#chan%,sp.infwinfg
11120     cls#chan%
11130     print #chan%,mess$
11140   else
11150     info mess$,chan%
11160   endif
11170   if not channel%:close#chan%
11180 end def show_info
11190 :
11200 DEFine PROCedure button (def_trav,menu_drap%,app_drap%,control%,chaine$,type_col%)
11210 REMark les parametres sont, dans l'ordre:
11220 REMark la dƒfinition de la fen‘tre, suivie des tableaux pour
11230 REMark les postes du menu dƒliƒ, les postes de la sous-fen‘tre d'appl.
11240 REMark et la dƒfinition de contr˜le, suivi du nom du bouton et
11250 REMark du type couleurs.
11260 REMark Il est supposƒ que vous avez ouvert une fen‘tre #1 si
11270 REMark le programme est compilƒ
11280   DR_UNST def_trav
11290   IF compiled: CLOSE#1
11300   rem button_wait chaine$
11310   BTN chaine$,type_col%
11320   IF compiled
11330     OPEN#1,"CON_"
11340     DR_PPOS def_trav,-1,-1,menu_drap%,app_drap%,control%
11350   ELSE
11360     DR_PULD def_trav,-1,-1,menu_drap%,app_drap%,control%
11370   END IF
11380 END DEFine button
11390 :
11400 DEFine FuNction centr$(ctr$,leng)
11410 rem this "centres" the string ctr$ (i.e. left padds it with spaces) so that
11420 rem it is centred in a window of leng width (leng is length in chars)
11430   LOCal l%,cta$
11440   cta$=ctr$
11450   strip_spaces cta$
11460   l%=INT(leng-LEN(cta$))/2
11470   if l%<0:return cta$
11480   return FILL$(' ',l%)&cta$&FILL$(' ',l%)
11490 END DEFine centr$
11500 :
11510 def proc calc_ysize (y_csize%)
11520 rem This tries to calculate the window y size depending on the given y size,
11530 rem the number of rows wished in the menu appsub window and the y position of
11540 rem the menu appsub window.
11550 rem It uses and changes the GLOBAL variables rows%, app_y_orig% and ysize%.
11560 rem It also uses the GLOBAL var maxy% which is the maximum y size a window
11570 rem could have in the current screen resolution.
11580 rem algo is as follows:
11590 rem if both ysize and rows% are undefined (=-1) : make wdw as big as possible
11600 rem if one is undefined, calc the other
11610 rem if both are defined, give precedence to the rows number
11620 rem
11630 rem param : y_csize% is the y character height, either 0 (10 pix) or 1 (20 pix)
11640 rem
11650 local y_spcg%
11660   if rows%=0:return
11670   y_spcg% = 12+(y_csize%*10)
11680   if rows%= -1
11690     if ysize%= -1
11700       rows%=(maxy%-14-app_y_orig%) div y_spcg% : rem max nbr of rows
11710     else
11720       rows%= (ysize%-app_y_orig%-4) div y_spcg%
11730     endif
11740   endif
11750   if rows%<2:rows%=2
11760   ysize%=rows%*y_spcg%+app_y_orig%+4
11770   if ysize%>=maxy%-14
11780     ysize%=maxy%-app_y_orig%-14
11790     rows%=ysize% div y_spcg%
11800     ysize%=rows%*y_spcg% + app_y_orig% + 4
11810   endif
11820   if ysize%<minysize%
11830     ysize%=minysize% -app_y_orig%-14
11840     rows%=ysize% div y_spcg%
11850     ysize%=rows%*y_spcg% + app_y_orig% + 4
11860   endif
11870 end def calc_ysize
11880 :
11890 DEFine PROCedure scroll_arrows(rows%,nbr_objects%,appfen,cty%)
11900 rem This determined whether an appsub wdw should have scroll arrows.
11910 rem Params: number of visible rows in the appsub wdw, ,total nbr of object rows
11920 rem in the abbsub wdw (not the visible rows, but the rows with objects),
11930 rem pointer to the appsub wdw defn returned by the APP_MAKE or APP_MAKE2 function
11940 rem and the control definition
11950   IF nbr_objects%<=rows%
11960     POKE_W appfen+150,0       : rem all objects fit , so no scroll arrows
11970                                         : rem and no y offset to start of menu
11980     poke_l appfen+96,0                  : rem no scroll bars
11990     cty%(1,2)=nbr_objects%    : rem nbr of columns/rows
12000   ELSE
12010     POKE_W appfen+150,6       : rem leave space for arrows
12020     cty%(1,2)=rows%-1                   : rem if scroll arrows are there, there is one line less in the window
12030     poke_l appfen+96,hex("2210222")
12040   END IF
12050   IF DIMN(cty%,1)=2:cty%(2,2)=cty%(1,2)
12060   cty%(0,1)=1                            : rem show that definition has changed
12070 END DEFine scroll_arrows
12080 :
12090 DEFine FuNction getstr$(poste%,drap%,defn,a$)
12100 REMark opens and sets a window over a loose item and proposes a sting to be edited.
12110 REMark parameters:
12120 REMark - item nbr
12130 REMark - falg whether result MUST be a numbrr (flag<>0)
12140 REMark - the working definition
12150 REMark - the string o edit
12160 rem returns the string or ""
12170 rem uses the global (!) vars sp.litemselbg and sp.litemselfg
12180 rem
12190 local b$,chan%
12200   chan%=FOPEN("con")
12210   b$=getstr2$(poste%,drap%,defn,a$,chan%)
12220   close#chan%
12230   return b$
12240 END DEFine getstr$
12250 :
12260 DEFine FuNction getstr2$(poste%,drap%,defn,a$,chan%)
12270 REMark sets a window over a loose item and proposes a sting to be edited.
12280 REMark parameters:
12290 REMark - item nbr
12300 REMark - falg whether result MUST be a numbrr (flag<>0)
12310 REMark - the working definition
12320 REMark - the string o edit
12330 remark - a screen channel to be used
12340 rem returns the string or ""
12350 rem uses the global (!) vars sp.litemselbg and sp.litemselfg
12360 rem
12370   LOCal b$,res
12380   b$=" ":b$=a$           : REMark c'est curieusement nƒcessaire
12390   wm_PAPER#chan%,sp.litemselbg
12400   wm_INK#chan%,sp.litemselfg
12410   DR_LWDF#chan%,defn,poste%             : rem open channel over item
12420   CLS#chan%
12430   res=GET_STR(#chan%,drap%,b$)                                : rem get string
12440   IF res<0:b$=""                        : rem ooops
12450   CH_ITEM defn,-1,poste%,-1,"",b$
12460   RETurn b$
12470 END DEFine getstr2$
12480 :
12490 def fn showcont$(string$,length%)
12500 rem this adds '...' at the end of a string, to show that it continues
12510 local l%,lengt%
12520   l%=len(string$)
12530   if not l%:return ""                             : rem empty string
12540   lengt%=length% div 6
12550   if l%<=lengt%:return string$                    : rem entire string fits wdw
12560   return string$(1 to lengt%-3)&"..."
12570 end def showcont$
12580 :
12590 def fn get_free_text$(defn,item%,prompt$,length%)
12600 rem this opens wdw over loose-item item% of the working definition defn
12610 rem allows free text to be entered
12620 rem params: working defintion,item over which wdw is to be opened
12630 rem           first value of string, length of max string in wdw, if this is...
12640 rem              -1, the length will be determined here
12650 local chan%,string$,tempsizes%(3)
12660   chan%=fopen('con')
12670   if chan%<0:return prompt$
12680   dr_lwdf#chan%,defn,item%              : rem open wdw over item
12690   paper#chan%,menu_brd
12700   ink#chan%,menu_ink
12710   cls#chan%
12720   string$=wedit$(#chan%,prompt$)
12730   if length%=-1
12740      wsipo#chan%,tempsizes%
12750      length%=tempsizes%(0)
12760   endif
12770   close#chan%
12780   if length%
12790     ch_item defn,-1,item%,-1,"",showcont$(string$,length%)
12800   else
12810     ch_item defn,-1,item%,-1,"",string$
12820   endif
12830   return string$
12840 end def get_free_text$
12850 :
12860 def proc make_my_palette (cw%)
12870   sp.winbd            = hex('0200') : rem Window border
12880   sp.winbg            = hex('0201') : rem Window background
12890   sp.winfg            = hex('0202') : rem Window foreground
12900   sp.winmg            = hex('0203') : rem Window middleground
12910   sp.titlebg          = hex('0204') : rem Title background
12920   sp.titletextbg  = hex('0205') : rem Title text background
12930   sp.titlefg          = hex('0206') : rem Title foreground
12940   sp.litemhigh        = hex('0207') : rem Loose item highlight
12950   sp.litemavabg   = hex('0208') : rem Loose item available background
12960   sp.litemavafg   = hex('0209') : rem Loose item available foreground
12970   sp.litemselbg   = hex('020a') : rem Loose item selected background
12980   sp.litemselfg   = hex('020b') : rem Loose item selected foreground
12990   sp.litemunabg   = hex('020c') : rem Loose item unavailable background
13000   sp.litemunafg   = hex('020d') : rem Loose item unavailable foreground
13010   sp.infwinbd         = hex('020e') : rem Information window border
13020   sp.infwinbg         = hex('020f') : rem Information window background
13030   sp.infwinfg         = hex('0210') : rem Information window foreground
13040   sp.infwinmg         = hex('0211') : rem Information window middleground
13050   sp.subinfbd         = hex('0212') : rem Subsidiary information window border
13060   sp.subinfbg         = hex('0213') : rem Subsidiary information window background
13070   sp.subinffg         = hex('0214') : rem Subsidiary information window foreground
13080   sp.subinfmg         = hex('0215') : rem Subsidiary information window middleground
13090   sp.appbd            = hex('0216') : rem Application window border
13100   sp.appbg            = hex('0217') : rem Application window background
13110   sp.appfg            = hex('0218') : rem Application window foreground
13120   sp.appmg            = hex('0219') : rem Application window middleground
13130   sp.appihigh         = hex('021a') : rem Application window item highlight
13140   sp.appiavabg        = hex('021b') : rem Application window item available background
13150   sp.appiavafg        = hex('021c') : rem Application window item available foreground
13160   sp.appiselbg        = hex('021d') : rem Application window item selected background
13170   sp.appiselfg        = hex('021e') : rem Application window item selected foreground
13180   sp.appiunabg        = hex('021f') : rem Application window item unavailable background
13190   sp.appiunafg        = hex('0220') : rem Application window item unavailable foreground
13200   sp.scrbar           = hex('0221') : rem Pan/scroll bar
13210   sp.scrbarsec        = hex('0222') : rem Pan/scroll bar section
13220   sp.scrbararr        = hex('0223') : rem Pan/scroll bar arrow
13230   sp.buthigh          = hex('0224') : rem Button highlight
13240   sp.butbd            = hex('0225') : rem Button border
13250   sp.butbg            = hex('0226') : rem Button background
13260   sp.butfg            = hex('0227') : rem Button foreground
13270   sp.hintbd           = hex('0228') : rem Hint border
13280   sp.hintbg           = hex('0229') : rem Hint background
13290   sp.hintfg           = hex('022a') : rem Hint foreground
13300   sp.hintmg           = hex('022b') : rem Hint middleground
13310   sp.errbg            = hex('022c') : rem Error message background
13320   sp.errfg            = hex('022d') : rem Error message foreground
13330   sp.errmg            = hex('022e') : rem Error message middleground
13340   sp.shaded           = hex('022f') : rem sp.shaded area
13350   sp.3ddark           = hex('0230') : rem Dark 3D border shade
13360   sp.3dlight          = hex('0231') : rem Light 3D border shade
13370   sp.vertfill         = hex('0232') : rem Vertical area fill
13380   sp.subtitbg         = hex('0233')  : rem Subtitle background
13390   sp.subtittxtbg  = hex('0234')  : rem Subtitle text background
13400   sp.subtitfg         = hex('0235')  : rem Subtitle foreground
13410   sp.mindexbg         = hex('0236')  : rem Menu index background
13420   sp.mindexfg         = hex('0237')  : rem Menu index foreground
13430   sp.separator        = hex('0238')  : rem Seperator lines etc.
13440   if cw%
13450     if not (is_open(#0) or is_open(#1))
13460       open#1,'con'
13470       sp_jobpal -1,cw%
13480       close#1
13490     else
13500       sp_jobpal -1,cw%
13510     endif
13520   endif
13530 end def make_my_palette
13540 :
13550 def fn set_colours% (force_mode%)
13560 rem this sets colour variables according to the colour mode wished, if possible.
13570 rem force_mode%=
13580 rem       0 if ql colours wished (mode 4 only)
13590 rem       1 if pal colours wished
13600 rem       2 if 24 bit colours wished
13610 rem This function returns the true QL mode set (4,8,32,33 etc.).
13620 rem This function also sets the GLOBAL variable mycolour_mode% to the
13630 rem mode 0,1,2 as above - whatever is possible on the machine, i.e.
13640 rem if colour_24 is wished on a 4 colour machine (which won't succeed)
13650 rem this function will set set that variable to 0, i.e. QL mode.
13660 rem
13670 rem This function needs the outptr toolkit
13680 local mode%
13690   mode%=rmode                                     : rem get current mode now
13700   select on force_mode%
13710       = 0                                         : rem mode 4 wished
13720        select on mode%
13730             = 4                                   : rem already on, so do nothing
13740             = 0,1,8 : mode 4            : rem old modes, set to 4 colours
13750             = remainder
13760               colour_ql                           : rem if higher colour mode, set to "mode 4"
13770               mode 4
13780        end select
13790        mode%=0                                    : rem new mode we're in  - 4 colour mode
13800       = 1                                         : rem PALette wished
13810        select on mode%
13820             = 16,32,33 : colour_pal:mode%=1  : rem we're in high colour mode, but PAL colours wished
13830             = remainder
13840               if mode%<>4:mode 4
13850               mode%=0
13860        end select
13870       = 2
13880        select on mode%
13890             = 32,33 : colour_24 :mode%=2          : rem we're in high col mode 24 bit colours
13900             = 16 : colour_pal : mode%=1
13910             = remainder
13920               if mode%<>4:mode 4
13930               mode%=0
13940        end select
13950   end select
13960   mycolour_mode%=mode%                            : rem set this global variable now:
13970   rem now set some colour variables
13980   select on mode%
13990        = 0                                        : rem Ql 4 mode colours
14000           Black            = 0
14010           White            = 7
14020           Red              = 2
14030           Green            = 4
14040           wg_striped     = 92
14050           br_striped     = 82
14060           wr_striped     = 107
14070           bg_striped     = 100
14080        = 1                              : rem Colour_pal
14090           Black            = 0
14100           White            = 1
14110           Red              = 2
14120           Green            = 3
14130           wg_striped     = light_green
14140           br_striped     = dark_red
14150           wr_striped     = light_red
14160           bg_striped     = dark_green
14170        = 2                              : rem colour_24
14180           Black            = hex('000000')
14190           White            = hex('FFFFFF')
14200           Red              = hex('FF0000')
14210           Green            = hex('00FF00')
14220           wg_striped     = light_green
14230           br_striped     = dark_red
14240           wr_striped     = light_red
14250           bg_striped     = dark_green
14260   end select
14270   mode%=rmode
14280   ret mode%                             : rem return current screen mode now
14290 end def set_colours%
14300 :
14310 def fn do_caps(a$,caps%)
14320 rem set string to capitales etc,caps% determines whether the string....
14330 REMark ...must be lower case (=0), upper case(=1), all words capitalized (=2),
14340 REMark ... first word only capitalized (=3), or nothing(=-1)
14350   SELect ON caps%
14360    =0: MIN a$
14370    =1: MAJ a$
14380    =2: CAP2 a$
14390    =3: CAP a$
14400   END SELect
14410   return a$
14420 end def do_caps
14430 :
14440 def fn mk_main_app (app_addr,subwinarray$,x_csize%,y_csize%, use_apm2%,hit_is_do%,sizex%,origx%)
14450 rem This makes a standard menu appsub with standard global variables.
14460 rem It presumes that the followng vars have been set:
14470 rem  * rows% holds the number of rows to be seen in the appsub window when there
14480 rem    are no scroll arrows (if there are, 1 less row will be seen)
14490 rem  * app_y_orig% = y origin of appsub within the main wdw
14500 rem  * xsize% = x size of main window (NOT subwindow)
14510 rem  * menu_selkeys$ holds the selkeys to exclude (string with upper cased keys)
14520 rem  *      set to "" if no selkeys wished, set to " " if no selkeys are excluded
14530 rem  * appw_sections% holds the nbr of sections to show
14540 rem  * main_cty% (DIMed here) is the  control sections array
14550 rem  * main_mfl% (DIMed here) is the menu items flag array
14560 rem
14570 rem Params:
14580 rem  * app_addr is the address of the appsub window, but 0 on first call
14590 rem  * subwinarry$ holds the data (2 dimensional string array)
14600 rem  * x, y_csize% are the csizes of objects in the appsub, standard values
14610 rem  * use_apm2% whether we use (=1) AP_MAKE2 or not (=0)
14620 rem  * hit_is_do% if hit should be = do
14630 rem  * sizex%= wished x size, leave at 0 if automatic size wished
14640 rem  * origx%= wished x orig, leave at 0 if automatic orig wished
14650 rem
14660 local temp%,selk%,app_attrs%(3,1),xs%,xo%
14670   if app_addr:rechp app_addr
14680   dim main_cty%(0):dim main_mfl%(0,0)
14690   temp%=x_csize%*16                               : rem x csize into upper nibble
14700   temp%=(temp%+y_csize%)*256            : rem y into lower, all into upper byte
14710   temp%=temp%+appw_sections%            : rem temp% is changed by the call to fen_app
14720   if menu_selkeys$=""
14730     selk%=0                                       : rem use no selkeys
14740   else
14750     selk%=1
14760   endif
14770   if hit_is_do%:selk%=selk%+256         : rem hit should be do
14780   if sizex%<1
14790     xs%=xsize%-16
14800   else
14810     xs%=sizex%
14820   endif
14830   if origx%<1
14840     xo%=0
14850   else
14860     xo%=origx%
14870   endif
14880   if use_apm2%
14890     app_addr=ap_make2(selk%,xs%,rows%,xo%,app_y_orig%,temp%,subwinarray$)
14900   else
14910     app_addr=ap_make(selk%,xs%,rows%,xo%,app_y_orig%,temp%,subwinarray$,menu_selkeys$&" ")
14920   endif                                 : rem on return temp%=nbr of objects
14930   IF app_addr = 0: RETurn 0             : rem  error, return 0
14940 :
14950   dim main_cty%(appw_sections%,2)       : rem control defn
14960   main_cty%(0,0)=1                      : rem at start show 1 section
14970   if temp%>rows%
14980     main_cty%(1,2)=rows%                : rem nbr of rows to show
14990   else
15000     main_cty%(1,2)=temp%                : rem there are less objects than rows
15010   endif
15020   main_cty%(1,2)=rows%
15030   if appw_sections%=2:main_cty%(2,2)=2
15040   if temp%
15050      dim main_mfl%(temp%-1,0)                     : rem flag array if there are any objects
15060   end if
15070   scroll_arrows rows%,temp%,app_addr,main_cty%
15080   return app_addr
15090 end define mk_main_app
15100 :
15110 def proc make_standard_sprites
15120 rem This makes standard move, sleep and wake sprites and sets the
15130 rem GLOBAL vars move_sprite,, sleep_sprite, wake_sprite and size_sprite to them.
15140 rem If there are system sprites, these are used.
15150 rem This also makes the "main_sprite" pointer sprite.
15160 :
15170   espace_vide=ALCHP(100)         : rem for pointers with no mask
15180 :
15190 restore 15190
15200   main_sprite=RD_SPRT(0)         : REMark ici un masque normal
15210     data 11,13,6,5,4
15220     data '     www     '
15230     data '     waw     '
15240     data '     waw     '
15250     data '     waw     '
15260     data 'wwwwwa awwwww'
15270     data 'waaaa   aaaaw'
15280     data 'wwwwwa awwwww'
15290     data '     waw     '
15300     data '     waw     '
15310     data '     waw     '
15320     data '     www     '
15330 :
15340   if sys_tspr_addr(6)<>0
15350     move_sprite=6
15360   else
15370 restore 15370
15380     move_sprite=RD_SPRT(1)         : REMark ici un masque 0
15390     data 10,14,5,4,4
15400     data 'aaaaaaaaaa    '
15410     data 'awwwwwwwwa    '
15420     data 'awwrrrrwwa    '
15430     data 'awwrrrrwwaaaaa'
15440     data 'awwrrwwwwwwwwa'
15450     data 'awwwwwwwwrrwwa'
15460     data 'aaaaawwrrrrwwa'
15470     data '    awwrrrrwwa'
15480     data '    awwwwwwwwa'
15490     data '    aaaaaaaaaa'
15500   endif
15510 :
15520   if sys_tspr_addr(10)<>0
15530     sleep_sprite=10
15540   else
15550 restore 15550
15560     sleep_sprite= RD_SPRT(1)             : REMark ici un masque 0
15570     data 7,15,0,0,4
15580     data 'wwwww          '
15590     data '   w           '
15600     data '  w  wwww      '
15610     data ' w     w       '
15620     data 'wwwww w  wwww  '
15630     data '     wwww  w   '
15640     data '          wwww '
15650   endif
15660 :
15670   if sys_tspr_addr(11)<>0
15680     wake_sprite=11
15690   else
15700 restore 15700
15710     wake_sprite=RD_SPRT(1)          : REMark ici un masque 0
15720     data 9,14,0,0,4
15730     data "             w"
15740     data "            w "
15750     data "      w   ww  "
15760     data "     ww www   "
15770     data "    wwwwww    "
15780     data "   www ww     "
15790     data "  w   w      "
15800     data " w            "
15810     data "w             "
15820   endif
15830 :
15840   if sys_tspr_addr(7)<>0
15850     size_sprite=7
15860   else
15870 restore 15870
15880     size_sprite=RD_SPRT(1)
15890     data 9,14,5,4,4
15900     data 'aaaaaaaaaaaaaa'
15910     data 'awwwwwwwwwwwwa'
15920     data 'awwrrrrrrrrwwa'
15930     data 'awwrrrrrrrrwwa'
15940     data 'awwrrwwwwwwwwa'
15950     data 'awwrrwwrrrrwwa'
15960     data 'awwrrwwrrrrwwa'
15970     data 'awwwwwwwwwwwwa'
15980     data 'aaaaaaaaaaaaaa'
15990   endif
16000 :
16010 end def make_standard_sprites
16020 :
16030 DEFine PROCedure warn_make
16040 rem makes warning & info window
16050 rem uses global vars sp.xxx
16060 rem SETS the global var warning_width% (nbr of chars in one line in wdw)
16070 local lys%,warn_lot,warn_iot1,warn_iwt
16080 local x%,y%,warning_paper,warning_brd
16090 restore 16090
16100   x%=200:y%=82
16110   lys%=10
16120   DIM warn_lfl%(1)
16130   warn_lot=RD_LOT(std_iattr,1)
16140     DATA 30,lys%,4,4,0,0,cancel$,text+retr,'ESC'
16150     DATA 30,lys%,x%-34,4,0,0,'O',text+retr,"OK"
16160 :
16170   warn_iot1=RD_IOT (0)
16180     DATA 12*9,10,0,1,text,sp.errfg,2,0,'Attention'
16190 :
16200   warn_iwt=RD_IWT(1)
16210     DATA x%-16,y%-32,8,24
16220     DATA 0,1,sp.winbd,sp.errbg
16230     DATA 0
16240 :
16250     DATA 110,12,(x%-110) div 2,4
16260     DATA 0,1,sp.winbd,sp.errbg
16270     DATA warn_iot1
16280 :
16290   warn_defn=RD_WDEF
16300     DATA 2,1,sp.winbd,sp.errbg
16310     DATA x%,y%,0,0
16320     DATA main_sprite,warn_lot,warn_iwt,0
16330 :
16340   warning_width%=(x%-16) div 6                    : rem width of warning window in chars
16350   info_is_pulled_down%=0
16360   warn_wdw_addr=peek_l(warn_defn+100)+20: rem ptr to 2nd info wdw
16370  rem warn_wdw_addr=peek_l(warn_wdw_addr+16): rem ptr to object list
16380 END DEFine warn_make
16390 :
16400 DEFine PROCedure about_make (titre$,version$)
16410 local lxs%,lys%,xesp%,inf1y%,abt_lot,longueur_titre%,titre_x%
16420 local abt_iwt,abt_iot1,abt_iot2
16430   ab_xt%=200:ab_yt%=120    : REMark tailles x et y: la taille x devrait
16440                                    : REMark ‘tre un chiffre divisible par 4
16450   lxs%=24:lys%=10                    : REMark tailles x et y pour postes standard
16460   inf1y%=lys%+4            : REMark posi. y de la fen. d'inf. intƒrieure
16470   xesp%=lxs%+2
16480   nbr_post%=0                      : REMark nombre de postes dans un coin
16490 :
16500 restore 16500
16510 wolfsoft_sprite=rD_SPrT(0)
16520     DATA 23,51,0,0,4
16530     DATA 'rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr'
16540     DATA 'rrgggggggggggggggggggggggggggggggggggggggggggggggrr'
16550     DATA 'rrggggggggrrrrrrrrrrrrrrrrgggggggggggggggggggggggrr'
16560     DATA 'rrgggggggggggggggggggggrgggggggggggggggggggggggggrr'
16570     DATA 'rrggggggggggggggggggggrggggggggggggggggggggggggggrr'
16580     DATA 'rrggggggggagggggagggrrrrrrrrrrrrrggaaaaaaaaggggggrr'
16590     DATA 'rrggggggggagggggaggggggggggggggggggagggggggggggggrr'
16600     DATA 'rrggggggggaggaggaggaaaaaaaggaggggggaaaaaaagggggggrr'
16610     DATA 'rrggggggggagaaagaggaawwaaaggaggggggagggggggggggggrr'
16620     DATA 'rrggggggggaaagaaaggaawwwwaggaggggggagggggggggggggrr'
16630     DATA 'rrggrrrrrgaagggaaggawwwwaaggaggggggagggggrrrrrrrgrr'
16640     DATA 'rrgrgggggrgggggggggaaawwaaggaggggggggggrrrgggggggrr'
16650     DATA 'rrgrggggggrggggggggaaaaaaaggaaaaaagggrrggrgggggggrr'
16660     DATA 'rrgrgggggggggggggrrrgggggggggggrrrggrggggrgggggggrr'
16670     DATA 'rrggrrrrrrggggggrgggrrgggggggrrggggggggggrgggggggrr'
16680     DATA 'rrggggggggrrrgggrgggggrrgggrrggggggggggggrgggggggrr'
16690     DATA 'rrgggggggggggrggrgggggggrggrgggggggggggggrgggggggrr'
16700     DATA 'rrggggggggggggrgrggggggggrgrrrrrrrgggggggrgggggggrr'
16710     DATA 'rrgrggggggggggrgrggggggggrgrgggggggggggggrgggggggrr'
16720     DATA 'rrggrgggggggrrgggrggggggrggrgggggggggggggrgggggggrr'
16730     DATA 'rrgggrrrrrrrggggggrrrrrrgggrgggggggggggggrgggggggrr'
16740     DATA 'rrgggggggggggggggggggggggggggggggggggggggggggggggrr'
16750     DATA 'rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr'
16760 :
16770   yinf1y%=inf1y%+4:
16780 :
16790   DIM abt_lfl%(0)
16800   abt_lot=RD_LOT(std_iattr,0)
16810     DATA ab_xt%-16,lys%,8,ab_yt%-lys%-8,0,0,cancel$,text+retr,'Super!'
16820 :
16830 : REMark  D'abord le titre qui est un objet d'une sous-fen‘tre d'info.
16840 :
16850   longueur_titre%=LEN(" Version "&version$)*6               : REMark on calcule la taille et la
16860   titre_x%=INT((ab_xt%-longueur_titre%)/2)  : REMark position x de cet objet
16870   abt_iot2=RD_IOT(1)
16880     DATA longueur_titre%,lys%,4,8,text,sp.winfg,0,0," Version "&version$
16890     DATA 52,24,ab_xt%-60,40,sprite,0,wolfsoft_sprite
16900   longueur_titre%=LEN(titre$)*6     : REMark on calcule la taille et la
16910   titre_x%=INT((ab_xt%-longueur_titre%)/2)  : REMark position x de cet objet
16920   abt_iot1=RD_IOT(0)
16930     DATA longueur_titre%,lys%,4,INT((lys%-10)/2),text,sp.titlefg,0,0,titre$
16940   abt_iwt=RD_IWT(2)               : REMark on veut 3 sous-fen. d'info
16950 REMark d'abord la fen‘tre contenant la barre entourant le titre
16960     DATA ab_xt%-8-(2*nbr_post%*xesp%),lys%+2,xesp%*nbr_post%+4,0  : REMark taille x,y, origines x,y
16970     DATA 0,0,sp.infwinbd,sp.titlebg     : REMark ombre, taille & couleur bordure
16980                                    : REMark puis couleur papier
16990     DATA 0                         : REMark pointeur vers objets
17000 REMark maintenant la fen‘tre qui contient le titre
17010     DATA longueur_titre%+8,lys%,titre_x%-2,2   : REMark on utilise titre_x% etc
17020     DATA 0,0, sp.infwinbd,sp.titletextbg
17030     DATA abt_iot1                 : REMark un objet, le titre
17040 REMark maintenant la fen‘tre de la bordure intƒrieure
17050     DATA ab_xt%-8,ab_yt%-inf1y%-2,4,inf1y%
17060     DATA 0,1,sp.infwinbd,sp.infwinbg
17070     DATA abt_iot2
17080   abt_defn=RD_WDEF
17090     DATA 2,1,sp.winbd,sp.winbg: REMark ombre, larg. & coul. bord., coul. papier
17100     DATA ab_xt%,ab_yt%,10,10 : REMark taille x,y et position pointeur
17110     DATA main_sprite,abt_lot,abt_iwt,0
17120 :
17130 end def about_make
17140 :
17150 DEFine PROCedure about (datet$)
17160   LOCal loop%,item%,dummy%,chan%
17170   DR_PULD abt_defn,-1,-1,abt_lfl%
17180   chan%=fopen('con')
17190   dr_iwdf#chan%,abt_defn,2
17200   wm_ink#chan%,sp.infwinfg
17210   wm_paper#chan%,sp.infwinbg
17220   at#chan%,4,2
17230   print#chan%,"Copyright (C) "
17240   at#chan%,5,2
17250   print#chan%, datet$
17260   at#chan%,6,2
17270   print#chan%,"Wolfgang H. Lenerz"
17280   close#chan%
17290   REPeat loop%
17300     RD_PTR abt_defn,item%,dummy%,dummy%,dummy%,dummy%,abt_lfl%
17310     SELect ON item%
17320             =0       : EXIT loop%
17330     END SELect
17340   END REPeat loop%
17350   DR_UNST abt_defn
17360 END DEFine about
17370 :
17380 def proc do_popup(string$)
17390 rem this pops up a small "hint" window showing the string$ passed
17400 rem as parameter.
17410 rem The string MUST be 1 line long and MUST fit
17420 rem inside the window (YOU must make sure of that!)
17430   do_popup2 string$,0
17440 end def do_popup
17450 :
17460 def proc popup_make
17470 rem make a small window defn
17480 local x%,y%,p_iot,popsub(0)
17490 restore 17490
17500   p_sprt=rd_sprt(0)                     : rem make an invisible pointer, all transparent
17510     data 1,2,0,0,4
17520     data '  '
17530   x%=14                                 : rem bogus window sizes
17540   y%=10
17550   popsub(0)=rd_appw                     : rem the info wdw
17560     DATA x%,y%,0,0
17570     DATA 0,0, sp.hintbd,sp.hintbg
17580     DATA 0,""
17590   popup_defn=RD_WDEF                    : rem the working defn
17600     DATA 0,1,sp.hintbd,sp.hintbg        : rem no shadow, border size & col, paper col
17610     DATA x%,y%,40,2
17620     DATA p_sprt,0,0,mk_awl(popsub)
17630 end def popup_make
17640 :
17650 def proc do_popup2(string$,main_defn)
17660 rem This pops up a small "hint" window showing the string$ passed
17670 rem as parameter.
17680 rem main_defn is the working defintion of the window over which the hint
17690 rem window is to hover. Position the pointer there where you need it before
17700 rem calling this.
17710 rem If the string is too long to fit into the window (which can only be as long
17720 rem as the outline of the working defn) then the string is split up at the
17730 rem first convenient space and put on a second line, and so on.
17740 rem If this would lead to the hint window being too high, only as many
17750 rem lines as possible will be displayed.
17760 rem !!!!!
17770 rem This presumes that a char is 10 pixels high & 6 pixels wide (standard ql 6x10 matrix)..
17780 rem !!!!!
17790 rem The string may contain the char chr$(10) - there will be a newline.
17800 rem
17810 rem note : do not try to pass a screen chaneel, open & close one here.
17820 rem
17830 local dummy%,lp%,address,con%,temp%,lastspace%,xs%,ys%,temp$
17840 local hint$(10),slen% ,maxlength%,popup_lfl%(0),popup_mfl%(0,0)
17850   if string$="":return                  : rem empty string, do nothing
17860   strip_spaces string$                 : rem no spaces at ends
17870   con%=fopen("con")
17880   if main_defn<>0
17890     xs%=peek_w (main_defn+32)
17900     ys%=peek_w(main_defn+34)            : rem get max sizes the hint wdw may have
17910   else
17920     scr_size#con%,xs,ys%
17930   endif
17940   xs%=(xs%-4) div 6                     : rem max nbr of chars in 1 line
17950   ys%=(ys%-4) div 10                    : rem max nbr of lines in wdw
17960   if xs%=0 or ys%=0:close#con%:return   : rem nothing will really fit, just leave
17970   dim hint$(ys%,xs%)                    : rem array to contain string
17980   rem now parse the string, find newlines, make sure of string length
17990   dummy%=1                              : rem start of current string section
18000   temp%=0                               : rem line
18010   slen%=0                               : rem current length of string
18020   for lp%=1 to len(string$)
18030     if string$(lp%)=chr$(10)
18040       hint$(temp%)=string$(dummy% to lp%-1): rem cut string here
18050       temp%=temp%+1
18060       if temp%=ys%:exit lp%             : rem max nbr of lines reached
18070       dummy%=lp%+1                      : rem this is where new start of string is
18080       lastspace%=lp%
18090     else
18100       if string$(lp%)=" "
18110         lastspace%=lp%                  : rem this is where last space is
18120       endif
18130     endif
18140     slen%=slen%+1                       : rem one more char
18150     if slen% > xs%
18160       hint$(temp%)=string$(dummy% to lastspace%-1) : rem too many chars in line
18170       slen%=0
18180       temp%=temp%+1                     : rem we need nother line
18190       if temp%=ys%:exit lp%             : rem max nbr of lines reached
18200       dummy%=lastspace%+1
18210     endif
18220   end for lp%
18230   if temp%<ys%
18240      hint$(temp%)=string$(dummy% to)       : rem add last part
18250      temp%=temp%+1
18260   endif
18270   maxlength%=0
18280   for lp%=0 to temp%
18290     temp$= hint$(lp%)
18300     strip_spaces temp$                 : rem use intermediary var, because of QLIB
18310     if maxlength%<len(temp$):maxlength%=len (temp$)
18320   end for lp%
18330   lp%=(maxlength%*6)+4                  : rem hint window length
18340   poke_w popup_defn+32,lp%              : rem set window xsize
18350   poke_w popup_defn+34,temp%*10+2       : rem
18360   address=peek_l(popup_defn+112)        : rem ptr to app sub wdw...
18370   address=peek_l(address)               : rem ...now
18380   poke_w address,lp%-2                  : rem set its length
18390   poke_w address+2,temp%*10             : rem set its height
18400   dr_puld popup_defn,-1,-1,popup_lfl%,popup_mfl%
18410   dr_awdf#con%,popup_defn,0             : rem pull wdw over info wdw
18420   wm_paper#con%,sp.hintbg
18430   wm_ink#con%,sp.hintfg
18440   for lp%=0 to dimn(hint$,1)
18450     if hint$(lp%)<>"":temp$=hint$(lp%):strip_spaces temp$:print#con%,temp$
18460   end for lp%
18470   temp%=0:slen%=0:xs%=0:ys%=0:dummy%=0
18480   RD_PTR popup_defn,temp%,dummy%,slen%,xs%,ys%,popup_lfl%,popup_mfl%: rem comes back immediatley
18490   RD_PTR popup_defn,temp%,dummy%,slen%,xs%,ys%,popup_lfl%,popup_mfl%
18500   close#con%
18510   dr_unst popup_defn
18520 end def do_popup2
18530 :
18540 DEFine FuNction RD_SPRT(drap%)
18550 REMark drap% determine si masque 0
18560   LOCal tmp_patt$(32,32)
18570   LOCal xs,ys,xo,yo, md, l
18580   READ ys,xs,xo,yo,md
18590   DIM tmp_patt$(ys,xs)
18600   FOR l=0 TO ys-1:READ tmp_patt$(l)
18610   l=ALCHP(SPRSP(xs,ys))
18620   SPSET l,xo,yo,md,tmp_patt$(0 TO ys-1,1 TO xs)
18630   IF drap%
18640     POKE_L l+16,espace_vide-(l+16)
18650   END IF
18660   RETurn l
18670 END DEFine RD_SPRT
18680 :
18690 DEFine FuNction RD_WDEF
18700 rem read window defn
18710   LOCal ldef%(3), lspr, lloose, linfo, lappl, lattr%(3)
18720   RD_WATT lattr%
18730   READ ldef%(0), ldef%(1), ldef%(2), ldef%(3)
18740   READ lspr, lloose, linf, lappl
18750   RETurn MK_WDEF (ldef%, lattr%, lspr, lloose, linf, lappl)
18760 END DEFine RD_WDEF
18770 :
18780 DEFine FuNction RD_LOT (lattr,nitem)
18790   LOCal count(3)
18800   LOCal item, ltyp, a$, lsk$
18810   LOCal ldef%(nitem,6), lptr(3,nitem), lstr$(nitem,85)
18820   lsk$=''
18830   FOR item = 0 TO nitem
18840     READ ldef%(item,0), ldef%(item,1), ldef%(item,2), ldef%(item,3)
18850     READ ldef%(item,4), ldef%(item,5)
18860     READ a$: lsk$=lsk$ & a$
18870     READ ltyp
18880     ldef%(item,6)=ltyp: ltyp=(ltyp MOD 256)/2
18890     IF ltyp>10 or ltyp <0:ltyp=0
18900     IF ltyp
18910       READ lptr(ltyp,count(ltyp))
18920     ELSE
18930       READ lstr$(count(0))
18940     END IF
18950     count(ltyp)=count(ltyp)+1
18960   END FOR item
18970   RETurn MK_LIL (lattr, ldef%(TO, 0 TO 1), ldef%(TO, 2 TO 3), ldef%(TO, 4 TO 5), lsk$, ldef%(TO, 6), lstr$, lptr(1), lptr(2), lptr(3))
18980 END DEFine RD_LOT
18990 :
19000 DEFine FuNction RD_IWT(nitem)
19010   LOCal item,mc1
19020   LOCal ldef%(nitem,3), latt%(nitem,3), lptr(nitem)
19030   FOR item = 0 TO nitem
19040     READ ldef%(item,0), ldef%(item,1), ldef%(item,2), ldef%(item,3)
19050     READ latt%(item,0), latt%(item,1), latt%(item,2), latt%(item,3)
19060     READ lptr(item)
19070   END FOR item
19080   RETurn MK_IWL (ldef%, latt%, lptr)
19090 END DEFine RD_IWT
19100 :
19110 DEFine FuNction RD_IOT(nitem)
19120   LOCal count(3)
19130   LOCal item, ltyp, work1, work2
19140   LOCal ldef%(nitem,4), lptr(3,nitem), lstr$(nitem,85)
19150   FOR item = 0 TO nitem
19160     READ ldef%(item,0), ldef%(item,1), ldef%(item,2), ldef%(item,3)
19170     READ ltyp
19180     ldef%(item,4)=ltyp:  ltyp=(ltyp MOD 256)/2
19190     IF ltyp >10:ltyp=0
19200     IF ltyp
19210       READ lptr(0,item),lptr(ltyp,count(ltyp))
19220     ELSE
19230       if mycolour_mode%=2
19240           read work1,work2,work3
19250           lptr(0,item)=WL_4_IOL(work1,work2,work3)
19260       else
19270           READ work1
19280           READ work2: work1=work1*256+work2
19290           READ work2: lptr(0,item)=work1*256+work2
19300       endif
19310       READ lstr$(count(0))
19320     END IF
19330     count(ltyp) = count(ltyp) + 1
19340   END FOR item
19350   RETurn MK_IOL (ldef%(TO, 0 TO 1), ldef%(TO, 2 TO 3), lptr(0), ldef%(TO, 4), lstr$, lptr(1), lptr(2), lptr(3))
19360 END DEFine RD_IOT
19370 :
19380 DEFine PROCedure RD_IATT (lattr)
19390   LOCal i
19400   READ lattr(0,0), lattr(0,1)
19410   FOR i=1 TO 3: READ lattr(i,0), lattr(i,1), lattr(i,2), lattr(i,3)
19420 END DEFine RD_IATT
19430 :
19440 DEFine PROCedure RD_WATT (lattr%)
19450   READ lattr%(0), lattr%(1),lattr%(2),lattr%(3)
19460 END DEFine RD_WATT
19470 :
19480 DEFine FuNction RD_APPW
19490   LOCal ldef%(3), lspr, sk$, lattr%(3)
19500   READ ldef%(0), ldef%(1), ldef%(2), ldef%(3)
19510   RD_WATT lattr%
19520   READ lspr, sk$
19530   RETurn MK_APPW (ldef%, lattr%, lspr,sk$)
19540 END DEFine
19550 :
